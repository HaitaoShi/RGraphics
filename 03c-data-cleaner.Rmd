# 数据清洁工 {#data-cleaner}

## `grep` 和 `grepl` {#grep-grepl}


```r
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)
```

- `ignore.case`: `TRUE` 表示忽略大小写，`FALSE` 表示匹配的时候区分大小写

- `grep` 返回匹配到的字符串向量x的元素的下标，如果 `value=TRUE` 则返回下标对应的值

```{r,echo=TRUE}
grep("[a-z]", letters)
grep("[a-z]", letters, value = TRUE)
```

```{r,echo=TRUE}
grep(x = c("apple", "banana"), pattern = "a")
grep(x = c("apple", "banana"), pattern = "b")
grep(x = c("apple", "banana"), pattern = "a", value = TRUE)
grep(x = c("apple", "banana"), pattern = "b", value = TRUE)
```


```r
grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
      fixed = FALSE, useBytes = FALSE)
```

- `grepl` 返回一个逻辑向量，字符串向量x中的每个元素是否匹配到，匹配到返回 `TRUE`，没有匹配到返回 `FALSE`

```{r,echo=TRUE}
grepl(x = c("apple", "banana"), pattern = "a")
grepl(x = c("apple", "banana"), pattern = "b")
```

- `fixed=TRUE` 表示启用原生字符raw strings匹配，或者 literal regular expression 字面正则表达式，默认情况下 `fixed=FALSE`

::: sidebar
R 是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式
::: 

在 R 里面分别表示 `a\\b` 和 `a\b`

```{r,echo=TRUE}
writeLines(c("a\\\\b", "a\\b"))
```

下面在 R 里面分别匹配字符串 `a\\b` 和 `a\b` 中的 `\\` 和 `\`

```{r,echo=TRUE}
# 匹配字符串中的一个反斜杠
grep(x = c("a\\\\b", "a\\b"), pattern = "\\", value = TRUE, fixed = TRUE)
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\", value = TRUE, fixed = FALSE)

# 匹配字符串中的两个反斜杠
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\", value = TRUE, fixed = TRUE)
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\\\\\", value = TRUE, fixed = FALSE)

# 匹配字符串中的两个反斜杠 \\
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = FALSE)
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = TRUE)
grepl(x = "a\\\\b", pattern = "\\\\", fixed = TRUE)
```

此外，还有一个函数 `grepRaw` 用于匹配 Raw Vectors 

## `sub` 与 `gsub` {#sub-gsub}

两个 `*sub` 函数的区别：sub 替换第一次匹配到的结果，gsub 替换所有匹配的结果

```{r,echo=TRUE}
sub(" .*", "", extSoftVersion()["PCRE"])
```


```{r,echo=TRUE}
gsub(pattern =  "([ab])", replacement = "\\1_\\1_", x = "abc and ABC")
```

## `regexpr`  `gregexpr`  `regexec` 和 `regmatches` {#regexpr-gregexpr-regexec-regmatches}

::: sidebar
`?grep` 帮助文档至少看50遍
:::

当启用 `perl=TRUE` 时， 函数 `regexpr` 和 `gregexpr` 支持 Python 环境下的 named capture，但是不支持长向量的输入. If groups are named, e.g., `(?<first>[A-Z][a-z]+)` then the positions of the matches are also returned by name. 函数 `sub` 不支持 Named backreferences

函数 `regmatches` 用来提取函数`regexpr`, `gregexpr` 和 `regexec` 匹配到的子字符串

```r
regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
        fixed = FALSE, useBytes = FALSE)
gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
         fixed = FALSE, useBytes = FALSE)
regexec(pattern, text, ignore.case = FALSE, perl = FALSE,
        fixed = FALSE, useBytes = FALSE)        
```


`regexpr` 返回一个整型向量，第一次匹配的初始位置，-1 表示没有匹配到，返回的属性 `match.length`  表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，-1 表示没有匹配到

The match positions and lengths are in characters unless `useBytes = TRUE` is used, when they are in bytes (as they are for an ASCII-only matching: in either case an attribute useBytes with value TRUE is set on the result). 

If named capture is used there are further attributes "capture.start", "capture.length" and "capture.names".

`gregexpr` 返回一个列表，returns a list of the same length as text each element of which is of the same form as the return value for `regexpr`, except that the starting positions of every (disjoint) match are given.


`regexec` 返回一个列表，长度 returns a list of the same length as text each element of which is either -1 if there is no match, or a sequence of integers with the starting positions of the match and all substrings corresponding to parenthesized subexpressions of pattern, with attribute "match.length" a vector giving the lengths of the matches (or -1 for no match). 位置、长度和属性的解释与 `regexpr` 一致

::: sidebar
Where matching failed because of resource limits (especially for PCRE) this is regarded as a non-match, usually with a warning.
:::

举个例子

```{r,echo=TRUE}
## Decompose a URL into its components.
## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
x <- "http://stat.umn.edu:80/xyz"
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
m
regmatches(x, m)
```

我们可以在 <https://regex101.com/> 上测试表达式，如图\@ref(fig:regex101)所示，表达式 `^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)` 包含7个组，每个组的匹配结果见图的右下角，这样我们不难理解，函数 `regmatches` 返回的第列表中，第3个位置是传输协议 protocol `http` ，第4个位置是主机 host `stat.umn.edu`， 第6个位置是端口 port `80` ，第7个位置是路径 path `/xyz`，所以函数 `regmatches` 的作用就是根据函数 `regexec` 匹配的结果抽取子字符串。

```{r regex101,fig.cap="正则表达式匹配结果",fig.link="https://regex101.com/"}
knitr::include_graphics(path = "figures/regexp.png")
```

进一步，我们可以用 `regmatches` 函数抽取 URL 的部分内容，如前面提到的传输协议，主机等

```{r,echo=TRUE}
URL_parts <- function(x) {
  m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
  parts <- do.call(
    rbind,
    lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L))
    # 3,4,6,7是索引位置
  )
  colnames(parts) <- c("protocol", "host", "port", "path")
  parts
}
URL_parts(x)
```

目前还没有 `gregexec` 函数，但是可以模拟一个，首先用 `gregexpr` 函数返回匹配的位置，`regmatches` 抽取相应的值，然后用 `regexec` 作用到每一个提取的值，做再一次匹配和值的抽取。另一个例子

```{r,echo=TRUE}
## There is no gregexec() yet, but one can emulate it by running
## regexec() on the regmatches obtained via gregexpr().  E.g.:
pattern <- "([[:alpha:]]+)([[:digit:]]+)"
s <- "Test: A1 BC23 DEF456"
gregexpr(pattern, s)
regmatches(s, gregexpr(pattern, s))
lapply(
  regmatches(s, gregexpr(pattern, s)),
  function(e) regmatches(e, regexec(pattern, e))
)
```


```{r,echo=TRUE}
data(acq, package = "tm")
writeLines(acq$content[[1]]$content)
```

```{r,echo=TRUE}
regexpr(pattern = "<.*>", text = acq$content[[1]]$content)
```

```{r,echo=TRUE}
txt <- c(
  "The", "licenses", "for", "most", "software", "are",
  "designed", "to", "take", "away", "your", "freedom",
  "to", "share", "and", "change", "it.",
  "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
  "is", "intended", "to", "guarantee", "your", "freedom", "to",
  "share", "and", "change", "free", "software", "--",
  "to", "make", "sure", "the", "software", "is",
  "free", "for", "all", "its", "users"
)
# gregexpr("en", txt)
regexpr("en", txt)
```


## 性能 {#performance}

当你对一个很长的字符串进行大量的正则表达式匹配的时候，你需要考虑性能问题了，这时候该考虑启用合适的选项，一般来讲， PCRE 比默认的正则表达式引擎快，`fixed=TRUE` 可以继续加快匹配速度，特别是当每个模式只匹配少量次数时。

基于 PCRE 的匹配

`options` 默认控制PCRE的三个选项 `PCRE_limit_recursion=NA` 、`PCRE_study=10` 和 `PCRE_use_JIT=TRUE`

看看本系统环境下 PCRE 的支持情况

```{r,echo=TRUE}
pcre_config()
```

查看系统的PCRE配置

```{r,echo=TRUE}
sapply(c("PCRE_limit_recursion", "PCRE_study", "PCRE_use_JIT"), getOption)
```

## stringi 和 stringr {#stringi-stringr}

[Handling Strings with R](https://www.gastonsanchez.com/r4strings/) 和 [Text Mining with R A Tidy Approach](https://www.tidytextmining.com/) 字符串入门介绍 [R for Data Science](https://r4ds.had.co.nz/strings.html)

[stringr](https://stringr.tidyverse.org/) 基于 [stringi](https://github.com/gagolews/stringi) 包字符串处理包，[re2r](https://github.com/qinwf/re2r/) 包基于 Google 开发的 C++ 库 [re2](https://github.com/google/re2)，Google 编程之夏项目提供了一份，[正则表达式性能综述](https://github.com/rstats-gsoc/gsoc2016/wiki/re2-regular-expressions)

Pattern Matching and Replacement 模式匹配和替换

正则表达式 is ervrywhere，is 高级/hacker's skill 技能

- [正则表达式速查表 -- Python3](https://www.dataquest.io/blog/large_files/python-regular-expressions-cheat-sheet.pdf)
- [Online regex tester and debugger](https://regex101.com/)
- [Regular expression operations](https://docs.python.org/3/library/re.html)
- [Handling Strings with R](http://www.gastonsanchez.com/r4strings/) 字符串处理

## RCurl 和 XML {#rcurl-xml}

用 R 语言写爬虫 解析网页

web 服务都会用到正则吧

curl 和 xml2 以及 rvest

libcurl 库的版本

```{r,echo=TRUE}
libcurlVersion()
```

## 扩展阅读 {#more-readings}

[How did Axios rectangle Trump's PDF schedule? A try with R](https://masalmon.eu/2019/02/11/trump-schedule/) 使用 pdftools 和 magick 处理表格，这两个R包分别依赖 Poppler C++ 和 ImageMagick++

如何在 Ubuntu 18.04 上安装 `poppler >= 0.73` [^install-poppler]

[^install-poppler]: https://askubuntu.com/questions/1112856

[Manipulating strings with the {stringr} package](https://www.brodrigues.co/blog/2019-02-10-stringr_package/)

PDF 表格抽取工具 [tabulizer](https://github.com/ropensci/tabulizer)

在 Ubuntu 上安装 pdftools 和 magick

```bash
sudo apt-get install libpoppler-cpp-dev libmagick++-dev
```

```{r,echo=TRUE,eval=FALSE}
install.packages(c("pdftools", "magick"))
```
