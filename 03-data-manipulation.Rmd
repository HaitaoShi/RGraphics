# 数据操作 {#data-manipulation}

```{r,include=FALSE}
library(magrittr) # %>%
```

数据变形，分组统计聚合等，用以作为模型的输入，绘图的对象，操作的数据对象是数据框(data.frame)类型的

## 清洗 {#clean}

清晰目标是提取字段，整理成数据框的数据存储形式 grep sub gsub

Pattern Matching and Replacement 模式匹配和替换

正则表达式 is ervrywhere，is 高级/hacker's skill 技能

- [正则表达式速查表 -- Python3](https://www.dataquest.io/blog/large_files/python-regular-expressions-cheat-sheet.pdf)
- [Online regex tester and debugger](https://regex101.com/)
- [Regular expression operations](https://docs.python.org/3/library/re.html)
- [Handling Strings with R](http://www.gastonsanchez.com/r4strings/) 字符串处理

R 基础包提供了丰富的字符串处理函数

```{r,eval=FALSE,echo=TRUE}
help.search(keyword = "character", package = "base")
```

R 包维护者

```{r,echo=TRUE}
gsub(" <([^<>]*)>", "", lapply(.packages(TRUE), maintainer) %>%
  unlist()) %>%
  table() %>%
  sort() %>%
  tail(10)
```

我安装 Hadley Wickham 维护的 R 包有 33 个

## 重塑 {#reshape}

重复测量数据的变形 Reshape Grouped Data

数据框宽格式 wide 变长格式 long

reshape 支持正则表达式

```{r,echo=TRUE}
str(Indometh)
summary(Indometh)
```
```{r,echo=TRUE}
wide <- reshape(Indometh, v.names = "conc", idvar = "Subject",
                timevar = "time", direction = "wide")
wide[,1:6]
```


## 转换 {#transform}

transform 对数据框中的某些列做计算，取对数，将计算的结果单存一列加到数据框中

```{r,echo=TRUE}
transform(iris, scale.sl = (max(Sepal.Length) - Sepal.Length)/(max(Sepal.Length) - min(Sepal.Length))) %>% head(5)
```

::: sidebar
Warning: This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting arithmetic functions, and in particular the non-standard evaluation of argument `transform` can have unanticipated consequences.
:::

## 子集 {#subset}

`subset(x, subset, select, drop = FALSE, ...)` 参数 subset 代表行操作，select 代表列操作

subset() 从数据框中提取部分数据

```{r,echo=TRUE}
subset(iris, Species == "virginica") %>% head(5)
# summary(iris$Sepal.Length)  mean(iris$Sepal.Length)
# 且的逻辑
# subset(iris, Species == "virginica" & Sepal.Length > 5.84333) %>% head(5)
subset(iris, Species == "virginica" & 
         Sepal.Length > mean(Sepal.Length)
       ) %>% head(5)
# 在行的子集范围内
subset(iris, Species %in% c("virginica","versicolor") & 
         Sepal.Length > mean(Sepal.Length)
       ) %>% head(5)
# 在列的子集内 先选中列
subset(iris, Sepal.Length > mean(Sepal.Length), 
       select = c("Sepal.Length","Species")
       ) %>% head(5)
```

高级操作：加入正则表达式筛选

```{r,echo=TRUE}
## sometimes requiring a logical 'subset' argument is a nuisance
nm <- rownames(state.x77)
start_with_M <- nm %in% grep("^M", nm, value = TRUE)
subset(state.x77, start_with_M, Illiteracy:Murder)
# 简化
# subset(state.x77, subset = grepl("^M", rownames(state.x77)), select = Illiteracy:Murder)
# 继续简化
subset(state.x77, grepl("^M", rownames(state.x77)), Illiteracy:Murder)
```

::: sidebar
警告：这是一个为了交互使用打造的便捷函数。对于编程，最好使用标准的子集函数，如 `[`，特别地，参数 `subset` 的非标准计算(non-standard evaluation)[^non-standard-eval]可能带来意想不到的后果。
:::

使用索引 `[` 

```{r,echo=TRUE}
iris[iris$Species == "virginica", ] %>% head(5)
iris[iris$Species == "virginica" &  
       iris$Sepal.Length > mean(iris$Sepal.Length), 
     ] %>% head(5)

iris[iris$Species == "virginica" &  
       iris$Sepal.Length > mean(iris$Sepal.Length), 
     c("Sepal.Length","Species")] %>% head(5)
```

[^non-standard-eval]: Thomas Lumley (2003) Standard nonstandard evaluation rules. https://developer.r-project.org/nonstandard-eval.pdf

## 排序 {#order}

在数据框内，根据(order)某一列或几列对行进行排序(sort)，根据鸢尾花(iris)的类别(Species)对萼片(sepal)的长度进行排序，其余的列随之变化

```{r,echo=TRUE}
# 对萼片的长度排序
iris[order(iris$Species,iris$Sepal.Length),] %>% head(5)
# 对花瓣的长度排序
iris[order(iris$Species,iris$Petal.Length),] %>% head(5)
# 先对花瓣的宽度排序，再对花瓣的长度排序
iris[order(iris$Petal.Width,iris$Petal.Length),] %>% head(5)
```

sort 排序

## 拆分 {#split}

```{r,echo=TRUE}
## Notice that assignment form is not used since a variable is being added
g <- airquality$Month
l <- split(airquality, g) # 分组
l <- lapply(l, transform, Oz.Z = scale(Ozone)) # 计算
aq2 <- unsplit(l, g) # 合并
head(aq2)
```

```{r,echo=TRUE}
with(aq2, tapply(Oz.Z,  Month, sd, na.rm = TRUE))
```

以 iris 数据集为例

```{r,echo=TRUE}
g <- iris$Species
l <- split(iris, g) # 分组
l <- lapply(l, transform, scale.sl = scale(Sepal.Length)) # 计算
unsplit(l, g) %>% head(5) # 合并
```

## 聚合 {#aggregate}

分组统计，都给出 dplyr 和 purrr 的便捷方式

```{r,echo=TRUE}
apropos("apply")
```

```{r,echo=TRUE}
# 分组求和 colSums colMeans max
unique(iris$Species)
# 分类求和
# colSums(iris[iris$Species == "setosa", -5])
# colSums(iris[iris$Species == "virginica", -5])
colSums(iris[iris$Species == "versicolor", -5])
# apply(iris[iris$Species == "setosa", -5], 2, sum)
# apply(iris[iris$Species == "setosa", -5], 2, mean)
# apply(iris[iris$Species == "setosa", -5], 2, min)
# apply(iris[iris$Species == "setosa", -5], 2, max)
apply(iris[iris$Species == "setosa", -5], 2, quantile)
```

aggregate: Compute Summary Statistics of Data Subsets

```{r,echo=TRUE}
# 按分类变量 Species 分组求和
# aggregate(subset(iris, select = -Species), by = list(iris[, "Species"]), FUN = sum)
aggregate(iris[, -5], list(iris[, 5]), sum)
# 先确定位置，假设有很多分类变量
ind <- which("Species" == colnames(iris))
# 分组统计
aggregate(iris[, -ind], list(iris[, ind]), sum)
```

table 多个分类变量分组计数统计

```{r,echo=TRUE}
# 分类变量计数
with(warpbreaks, table(wool, tension))
```

Function `by` is an object-oriented wrapper for `tapply` applied to data frames. 

```{r,echo=TRUE}
# 分组求和
# by(iris[, 1], INDICES = list(iris$Species), FUN = sum)
# by(iris[, 2], INDICES = list(iris$Species), FUN = sum)
by(iris[, 3], INDICES = list(iris$Species), FUN = sum)
```

Group Averages Over Level Combinations of Factors 分组平均

```{r,echo=TRUE}
str(warpbreaks)
ave(warpbreaks$breaks, warpbreaks$wool)
warpbreaks %>% head(5)
with(warpbreaks, ave(breaks, tension, FUN = function(x) mean(x, trim = 0.1)))
# 分组求和
with(warpbreaks, ave(breaks, tension, FUN = function(x) sum(x)))
# 分组求和
with(iris,ave(Sepal.Length,Species, FUN = function(x) sum(x)))
```

长 long 变 wide 宽格式

```{r,echo=TRUE,eval=FALSE}
data(gambia,package = 'geoR')
# Building a "village-level" data frame
ind <- paste("x",gambia[,1], "y", gambia[,2], sep="")
village <- gambia[!duplicated(ind),c(1:2,7:8)]
village$prev <- as.vector(tapply(gambia$pos, ind, mean))
head(village)
```

[apply-family]: https://stackoverflow.com/questions/3505701/grouping-functions-tapply-by-aggregate-and-the-apply-family
