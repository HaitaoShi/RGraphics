# 数据操作 {#data-manipulation}

```{r,include=FALSE}
library(magrittr) # %>%
```

数据变形，分组统计聚合等，用以作为模型的输入，绘图的对象，操作的数据对象是数据框(data.frame)类型的

## 清洗 {#clean}

清晰目标是提取字段，整理成数据框的数据存储形式 grep sub gsub

Pattern Matching and Replacement 模式匹配和替换

R 基础包提供了丰富的字符串处理函数

```{r,eval=FALSE,echo=TRUE}
help.search(keyword = "character", package = "base")
```

R 包维护者

```{r,echo=TRUE}
gsub(" <([^<>]*)>", "", lapply(.packages(TRUE), maintainer) %>%
  unlist()) %>%
  table() %>%
  sort() %>%
  tail(10)
```

我安装 Hadley Wickham 维护的 R 包有 33 个

## 重塑 {#reshape}

重复测量数据的变形 Reshape Grouped Data

数据框宽格式 wide 变长格式 long

reshape 支持正则表达式

```{r,echo=TRUE}
str(Indometh)
summary(Indometh)
```
```{r,echo=TRUE}
wide <- reshape(Indometh, v.names = "conc", idvar = "Subject",
                timevar = "time", direction = "wide")
wide[,1:6]
```


## 转换 {#transform}

transform 对数据框中的某些列做计算，取对数，将计算的结果单存一列加到数据框中

```{r,echo=TRUE}
transform(iris, scale.sl = (max(Sepal.Length) - Sepal.Length)/(max(Sepal.Length) - min(Sepal.Length))) %>% head(5)
```

::: sidebar
Warning: This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting arithmetic functions, and in particular the non-standard evaluation of argument `transform` can have unanticipated consequences.
:::

## 子集 {#subset}

`subset(x, subset, select, drop = FALSE, ...)` 参数 subset 代表行操作，select 代表列操作

subset() 从数据框中提取部分数据

```{r,echo=TRUE}
subset(iris, Species == "virginica") %>% head(5)
# summary(iris$Sepal.Length)  mean(iris$Sepal.Length)
# 且的逻辑
# subset(iris, Species == "virginica" & Sepal.Length > 5.84333) %>% head(5)
subset(iris, Species == "virginica" & Sepal.Length > mean(Sepal.Length)) %>% head(5)
# 在行的子集范围内
subset(iris, Species %in% c("virginica","versicolor") & Sepal.Length > mean(Sepal.Length)) %>% head(5)
# 在列的子集内 先选中列
subset(iris, select = c("Sepal.Length","Species"), Sepal.Length > mean(Sepal.Length)) %>% head(5)
```

高级操作：加入正则表达式筛选

```{r,echo=TRUE}
## sometimes requiring a logical 'subset' argument is a nuisance
nm <- rownames(state.x77)
start_with_M <- nm %in% grep("^M", nm, value = TRUE)
subset(state.x77, start_with_M, Illiteracy:Murder)
# 简化
# subset(state.x77, subset = grepl("^M", rownames(state.x77)), select = Illiteracy:Murder)
# 继续简化
subset(state.x77, grepl("^M", rownames(state.x77)), Illiteracy:Murder)
```

::: sidebar
Warning: This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting functions like `[`, and in particular the non-standard evaluation of argument `subset` can have unanticipated consequences.
:::

## 排序 {#order}

在数据框内，根据(order)某一列或几列对行进行排序(sort)，根据鸢尾花(iris)的类别(Species)对萼片(sepal)的长度进行排序，其余的列随之变化

```{r,echo=TRUE}
# 对萼片的长度排序
iris[order(iris$Species,iris$Sepal.Length),] %>% head(5)
# 对花瓣的长度排序
iris[order(iris$Species,iris$Petal.Length),] %>% head(5)
# 先对花瓣的宽度排序，再对花瓣的长度排序
iris[order(iris$Petal.Width,iris$Petal.Length),] %>% head(5)
```

sort 排序

## 拆分 {#split}

```{r}
## Notice that assignment form is not used since a variable is being added
g <- airquality$Month
l <- split(airquality, g) # 分组
l <- lapply(l, transform, Oz.Z = scale(Ozone)) # 计算
aq2 <- unsplit(l, g) # 合并
head(aq2)
```

```{r}
with(aq2, tapply(Oz.Z,  Month, sd, na.rm = TRUE))
```

以 iris 数据集为例

```{r}
g <- iris$Species
l <- split(iris, g) # 分组
l <- lapply(l, transform, scale.sl = scale(Sepal.Length)) # 计算
unsplit(l, g) %>% head(5) # 合并
```

## 聚合 {#aggregate}

分组统计

aggregate

Compute Summary Statistics of Data Subsets

table

都给出 dplyr 和 purrr 的便捷方式

```{r,echo=TRUE}
apropos("apply")
```

Function `by` is an object-oriented wrapper for `tapply` applied to data frames. 

Group Averages Over Level Combinations of Factors 分组平均

```{r,echo=TRUE}
str(warpbreaks)
ave(warpbreaks$breaks, warpbreaks$wool)
warpbreaks %>% head(5)
with(warpbreaks, ave(breaks, tension, FUN = function(x) mean(x, trim = 0.1)))
# 分组求和
with(warpbreaks, ave(breaks, tension, FUN = function(x) sum(x)))
# 分组求和
with(iris,ave(Sepal.Length,Species, FUN = function(x) sum(x)))
```

长 long 变 wide 宽格式

```{r,echo=TRUE,eval=FALSE}
data(gambia,package = 'geoR')
# Building a "village-level" data frame
ind <- paste("x",gambia[,1], "y", gambia[,2], sep="")
village <- gambia[!duplicated(ind),c(1:2,7:8)]
village$prev <- as.vector(tapply(gambia$pos, ind, mean))
head(village)
```

[apply-family]: https://stackoverflow.com/questions/3505701/grouping-functions-tapply-by-aggregate-and-the-apply-family
