# 字符串操作 I {#string-manipulation}

```{r,include=FALSE}
library(magrittr) # 提供管道操作 %>%
```

字符和字符串类型的数据值得单独拿出来讲，不仅因为内容多，而且比较难，应用范围最广，特别是面对文本类型的数据时，几乎是避不开的！R 的前身是 S，S 的前身是一些 Fortran 和 C 子程序，最早在贝尔实验室是用于文本分析领域，因此在 R 基础包中提供了丰富的字符串处理函数，你可以在R控制台中执行如下一行命令查看

```{r,eval=FALSE,echo=TRUE}
help.search(keyword = "character", package = "base")
```

本章主要介绍 R 内置的字符串操作函数，参考 [字符串处理](https://blog.csdn.net/duqi_yc/article/details/9817243) 和 [grep等函数](https://blog.csdn.net/lhf_tiger/article/details/9280549)

## 字符数统计 {#base-count}

`nchar` 函数统计字符串向量中每个元素的字符个数，注意与函数`length` 的差别，它统计向量中元素的个数，即向量的长度。

```{r,echo=TRUE}
nchar(c("Hello", "world", "!"))
R.version.string
nchar(R.version.string)
deparse(base::mean)
nchar(deparse(base::mean))
```

一些特殊的情况

```{r,echo=TRUE}
nchar("")
nchar(NULL)
nchar(0)
pi
nchar(pi)
exp(1)
nchar(exp(1))
nchar(NA)
```

## 字符串翻译 {#base-translations}

`tolower` 将字符串或字符串向量中含有的大写字母全都转化为小写， `toupper` 函数正好与之相反.

```{r,echo=TRUE}
tolower(c("HELLO", "Hello, R", "hello"))
toupper(c("HELLO", "Hello, R", "hello"))
```

## 字符串连接 {#base-concatenate}

`paste` 函数设置参数 sep 作为连接符，设置参数 collapse 可以将字符串拼接后连成一个字符串

```{r,echo=TRUE}
paste("A", "B", sep = "")
paste(c("A", "B", "C"), 1:3, sep = "-")
paste(c("A", "B", "C"), 1:3, sep = "-", collapse = ";")
```

`paste0` 相当于 sep 设为空，没有连接符 

```{r,echo=TRUE}
paste0("A", "B")
paste0(c("A", "B", "C"), 1:3)
paste0(c("A", "B", "C"), 1:3, collapse = ";")
```

## 字符串拆分 {#base-split}

```{r,eval=FALSE,echo=TRUE}
strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)
```

`strsplit` 函数用于字符串拆分，参数 x 是被拆分的字符串向量，其每个元素都会被拆分，而参数 split 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。

参数 fixed 默认设置 `fixed = FALSE` 表示正则表达式匹配，而 `fixed = TRUE` 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。

当启用 `perl = TRUE` 时，由 `PCRE_use_JIT` 控制细节。`perl` 参数的设置与 Perl 软件版本有关，如果正则表达式很长，除了正确设置正则表达式，使用 `perl = TRUE` 可以提高运算速度

参数 useBytes 设置是否按照逐个字节地进行匹配，默认设置为 FALSE，即按照字符而不是字节进行匹配

```{r,echo=TRUE}
x <- c(as = "asfef", qu = "qwerty", "yuiop[", "b", "stuff.blah.yech")
# 按字母 e 拆分字符串向量 x
strsplit(x, "e")
```

参数 split 支持通过正则表达式的方式指明拆分位置

```{r,echo=TRUE}
# 默认将点号 . 看作一个正则表达式，它是一个元字符，匹配任意字符
strsplit("a.b.c", ".")
# 这才是按点号拆分
strsplit("a.b.c", ".", fixed = TRUE)
# 或者
strsplit("a.b.c", "[.]")
# 或者转义点号，去掉元字符的特殊意义
strsplit("a.b.c", "\\.")
```

这里介绍一个将字符串逆序的函数 `str_rev`

```{r,echo=TRUE}
str_rev <- function(x)
        sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
str_rev(c("abc", "Statistics"))
```

为了加深理解，再举几个例子

```{r,echo=TRUE}
# 最后一个空字符没有产生
strsplit(paste(c("", "a", ""), collapse="#"), split="#")
# 空字符只有有定义的时候才会产生
strsplit("", " ")
strsplit(" ", " ")
```

## 字符串匹配 {#base-match}

近似匹配 `agrep` for approximate matching.

部分匹配 `charmatch`  `pmatch` for partial matching,

`match` for matching to whole strings, 

`startsWith` for matching of initial parts of strings.

## 字符串查询 {#base-search}

`grep` 和 `grepl`

```r
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)
```

- `ignore.case`: `TRUE` 表示忽略大小写，`FALSE` 表示匹配的时候区分大小写

- `grep` 返回匹配到的字符串向量x的元素的下标，如果 `value=TRUE` 则返回下标对应的值

```{r,echo=TRUE}
grep("[a-z]", letters)
grep("[a-z]", letters, value = TRUE)
```

```{r,echo=TRUE}
grep(x = c("apple", "banana"), pattern = "a")
grep(x = c("apple", "banana"), pattern = "b")
grep(x = c("apple", "banana"), pattern = "a", value = TRUE)
grep(x = c("apple", "banana"), pattern = "b", value = TRUE)
```


```r
grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
      fixed = FALSE, useBytes = FALSE)
```

- `grepl` 返回一个逻辑向量，字符串向量x中的每个元素是否匹配到，匹配到返回 `TRUE`，没有匹配到返回 `FALSE`

```{r,echo=TRUE}
grepl(x = c("apple", "banana"), pattern = "a")
grepl(x = c("apple", "banana"), pattern = "b")
```

- `fixed=TRUE` 表示启用原生字符raw strings匹配，或者 literal regular expression 字面正则表达式，默认情况下 `fixed=FALSE`

::: sidebar
R 是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式
::: 

在 R 里面分别表示 `a\\b` 和 `a\b`

```{r,echo=TRUE}
writeLines(c("a\\\\b", "a\\b"))
```

下面在 R 里面分别匹配字符串 `a\\b` 和 `a\b` 中的 `\\` 和 `\`

```{r,echo=TRUE}
# 匹配字符串中的一个反斜杠
grep(x = c("a\\\\b", "a\\b"), pattern = "\\", value = TRUE, fixed = TRUE)
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\", value = TRUE, fixed = FALSE)

# 匹配字符串中的两个反斜杠
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\", value = TRUE, fixed = TRUE)
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\\\\\", value = TRUE, fixed = FALSE)

# 匹配字符串中的两个反斜杠 \\
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = FALSE)
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = TRUE)
grepl(x = "a\\\\b", pattern = "\\\\", fixed = TRUE)
```

此外，还有一个函数 `grepRaw` 用于匹配 Raw Vectors 

`regexpr`  `gregexpr`  `regexec` 和 `regmatches` 

::: sidebar
`?grep` 帮助文档至少看50遍
:::

当启用 `perl=TRUE` 时， 函数 `regexpr` 和 `gregexpr` 支持 Python 环境下的 named capture，但是不支持长向量的输入. If groups are named, e.g., `(?<first>[A-Z][a-z]+)` then the positions of the matches are also returned by name. 函数 `sub` 不支持 Named backreferences

函数 `regmatches` 用来提取函数`regexpr`, `gregexpr` 和 `regexec` 匹配到的子字符串

```r
regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
        fixed = FALSE, useBytes = FALSE)
gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
         fixed = FALSE, useBytes = FALSE)
regexec(pattern, text, ignore.case = FALSE, perl = FALSE,
        fixed = FALSE, useBytes = FALSE)        
```


`regexpr` 返回一个整型向量，第一次匹配的初始位置，-1 表示没有匹配到，返回的属性 `match.length`  表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，-1 表示没有匹配到

The match positions and lengths are in characters unless `useBytes = TRUE` is used, when they are in bytes (as they are for an ASCII-only matching: in either case an attribute useBytes with value TRUE is set on the result). 

If named capture is used there are further attributes "capture.start", "capture.length" and "capture.names".

`gregexpr` 返回一个列表，returns a list of the same length as text each element of which is of the same form as the return value for `regexpr`, except that the starting positions of every (disjoint) match are given.


`regexec` 返回一个列表，长度 returns a list of the same length as text each element of which is either -1 if there is no match, or a sequence of integers with the starting positions of the match and all substrings corresponding to parenthesized subexpressions of pattern, with attribute "match.length" a vector giving the lengths of the matches (or -1 for no match). 位置、长度和属性的解释与 `regexpr` 一致

::: sidebar
Where matching failed because of resource limits (especially for PCRE) this is regarded as a non-match, usually with a warning.
:::

举个例子

```{r,echo=TRUE}
## Decompose a URL into its components.
## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
x <- "http://stat.umn.edu:80/xyz"
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
m
regmatches(x, m)
```

我们可以在 <https://regex101.com/> 上测试表达式，如图\@ref(fig:regex101)所示，表达式 `^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)` 包含7个组，每个组的匹配结果见图的右下角，这样我们不难理解，函数 `regmatches` 返回的第列表中，第3个位置是传输协议 protocol `http` ，第4个位置是主机 host `stat.umn.edu`， 第6个位置是端口 port `80` ，第7个位置是路径 path `/xyz`，所以函数 `regmatches` 的作用就是根据函数 `regexec` 匹配的结果抽取子字符串。

```{r regex101,fig.cap="正则表达式匹配结果",fig.link="https://regex101.com/"}
knitr::include_graphics(path = "figures/regexp.png")
```

进一步，我们可以用 `regmatches` 函数抽取 URL 的部分内容，如前面提到的传输协议，主机等

```{r,echo=TRUE}
URL_parts <- function(x) {
  m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
  parts <- do.call(
    rbind,
    lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L))
    # 3,4,6,7是索引位置
  )
  colnames(parts) <- c("protocol", "host", "port", "path")
  parts
}
URL_parts(x)
```

目前还没有 `gregexec` 函数，但是可以模拟一个，首先用 `gregexpr` 函数返回匹配的位置，`regmatches` 抽取相应的值，然后用 `regexec` 作用到每一个提取的值，做再一次匹配和值的抽取。另一个例子

```{r,echo=TRUE}
## There is no gregexec() yet, but one can emulate it by running
## regexec() on the regmatches obtained via gregexpr().  E.g.:
pattern <- "([[:alpha:]]+)([[:digit:]]+)"
s <- "Test: A1 BC23 DEF456"
gregexpr(pattern, s)
regmatches(s, gregexpr(pattern, s))
lapply(
  regmatches(s, gregexpr(pattern, s)),
  function(e) regmatches(e, regexec(pattern, e))
)
```


```{r,echo=TRUE}
data(acq, package = "tm")
writeLines(acq$content[[1]]$content)
```

```{r,echo=TRUE}
regexpr(pattern = "<.*>", text = acq$content[[1]]$content)
```

```{r,echo=TRUE}
txt <- c(
  "The", "licenses", "for", "most", "software", "are",
  "designed", "to", "take", "away", "your", "freedom",
  "to", "share", "and", "change", "it.",
  "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
  "is", "intended", "to", "guarantee", "your", "freedom", "to",
  "share", "and", "change", "free", "software", "--",
  "to", "make", "sure", "the", "software", "is",
  "free", "for", "all", "its", "users"
)
# gregexpr("en", txt)
regexpr("en", txt)
```

## 字符串替换 {#base-replacement}

`chartr` 支持正则表达式的替换，`chartr` 是对应字符的替换操作

```{r,echo=TRUE}
x <- "MiXeD cAsE 123"
# 将字符 iXs 替换为 why
chartr("iXs", "why", x)
# 将字符串 a-cX 中的字符挨个对应地替换为 D-Fw
chartr("a-cX", "D-Fw", x)
```

两个 `*sub` 函数的区别：sub 替换第一次匹配到的结果，gsub 替换所有匹配的结果

```{r,echo=TRUE}
sub(" .*", "", extSoftVersion()["PCRE"])
```

```{r,echo=TRUE}
gsub(pattern =  "([ab])", replacement = "\\1_\\1_", x = "abc and ABC")
```

## 字符串提取 {#base-extract}

`substr` 和 `substring`

