# 正则表达式 {#regex}

::: sidebar
以下所述，都不考虑 `perl=TRUE` 的情况，R 语言中提供了扩展的（默认的）和类似 Perl 的两套正则表达式。作为入门，我们这里只关注前者，启用 Perl 正则表达式只需在函数如 `grep` 中将选项 `perl = TRUE` 即可，并将后者统一命名为 Perl 正则表达式[^learn-regex]。
:::

正则表达式 (**reg**ular **exp**ression，简称 regexp)， 函数 `regexpr` 和 `gregexpr` 的名称就好理解了，在控制台输入 `?regex` 查看 R 支持的正则表达式，谢老大建议把 `?regex` 至少看百八十遍。

[Handling Strings with R](https://www.gastonsanchez.com/r4strings/) 和 [Text Mining with R A Tidy Approach](https://www.tidytextmining.com/) 字符串入门介绍 [R for Data Science](https://r4ds.had.co.nz/strings.html)

[stringr](https://stringr.tidyverse.org/) 基于 [stringi](https://github.com/gagolews/stringi) 包字符串处理包，[re2r](https://github.com/qinwf/re2r/) 包基于 Google 开发的 C++ 库 [re2](https://github.com/google/re2)，Google 编程之夏项目提供了一份，[正则表达式性能综述](https://github.com/rstats-gsoc/gsoc2016/wiki/re2-regular-expressions)


常用的字符串处理函数有 `grep`、`grepl`、`sub`、`gsub`、`regexpr`、`gregexpr` 、 `regmatches` 和 `strsplit` 它们都支持正则表达式语法，其中，函数 `grep`, `glob2rx` 和 `strsplit` 其实是通过 `grep` 使用正则表达式的。


正则表达式的构造方式类似算术表达式，通过各种操作组合子（更小的）表达式，整个表达式匹配一个或多个字符[^char-byte]。大多数字符，包括所有的字母和数字，是匹配自身的正则表达式。带有特定意义的任何元字符可以通过反斜杠引用。在常用正则表达式中，元字符 metacharacters 是 

```
. \ | ( ) [ { ^ $ * + ? 
```

要注意，它们是否有特殊意义取决于所在的内容。

一个字符集 character class 是用一对中括号`[]`括起来的字符列表，用来匹配在哪个列表中的任意一（单）个字符，除非列表中的第一个字符是 `^`，它用来匹配任意的不在这个列表中的字符。 `[0123456789]` 用来匹配任意单个数字，`[^abc]` 用来匹配除字符 `a,b,c` 以外的任意字符。

字符范围可以通过第一个和最后一个字符指定，中间用连字符连接，但是由于这种解释依赖于区域和具体实现，所以指定字符范围这个方式最好避免。

唯一可移植（便携）的方式是作为字符类，在列表中列出所有的 ASCII 字母，
`[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]`.

某些命名的字符类是预定义的，它们的解释 interpretation 依赖于区域 locale，下面的解释是  POSIX locale

- `[:alnum:]` 表示  `[:alpha:]` 和 `[:digit:]`，含义是 `[0-9A-Za-z]`，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号 `[]` 是符号名的一部分，是必须要包含的。在字符集中，大多数元字符失去它们特殊的意义。

- `[:alpha:]` 表示 `[:lower:]` 和 `[:upper:]`
- `[:blank:]` 表示 空格 space 制表符 tab
- `[:cntrl:]` 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。 
- `[:digit:]` 表示数字 0,1,2,3,4,5,6,7,8,9
- `[:graph:]` 表示 `[:alnum:]` 和 `[:punct:]`.
- `[:lower:]` 表示当前区域下的小写字母
- `[:print:]` 表示可打印的字符  `[:alnum:]`, `[:punct:]` 和空格.
- `[:punct:]` 表示标点字符 

  ```
  ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~`
  ```

- `[:space:]` 表示空格字符： 水平制表符 tab， 换行符 newline，垂直制表符 vertical tab，换页符 form feed，回车符 carriage return，空格符 space 
- `[:xdigit:]` 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.


要包含字面的 `]` 就把它放在列表的开头，类似地，要包含字面 `^`，除了开头可以放在任意位置。要包含字面 `-` 把它放在开头或者结尾。只有 `^ - \ ]` 在字符集内是有特殊的含义

点号 `.` 匹配任意单个字符，`\w` 匹配一个词 word 字符(是`[[:alnum:]_]`的同义词，一个扩展) ，而 `\W` 是 `\w` 取反，意味着 `[^[:alnum:]_]`。 `\d`, `\s`, `\D` 和 `\S` 表示数字和空格类和它们的取反

caret `^` 和美元符号 `$` 是元字符，分别匹配一行的开头和结尾。符号 `\<` 和 `\>` 分别匹配一个词的开头和结尾的空字符串。`\b` 匹配词边缘的空字符串，`\B` 匹配不在词边缘的空字符串。 词 word 的解释依赖于区域和实现。


## 贪婪匹配 {#repetition-quantifiers}

默认情况下， 匹配方式是贪婪的，会使用最大可能的匹配，这个可以变为最小的匹配次数，通过在其之后添加 `?`，一个正则表达式可能跟着重复量词，下面的限定符都是限定跟在它前面的正则表达式

- `?` 前面的项目匹配至多 1 次
- `*` 前面的项目匹配 0 次或多次
- `+` 前面的项目匹配至少 1 次
- `{n}` 前面的项目匹配 n 次.
- `{n,}` 前面的项目匹配至少 n 次.
- `{n,m}` 前面的项目匹配至少 n 次 至多 m 次

## 级联 {#concatenation}

> Regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating the substrings that match the concatenated subexpressions.

正则表达式可以是级联 concatenation 的，是不是在讲一个正则表达式里面嵌套一个正则表达式

两个正则表达式可以通过中缀符号 `|` 联合，用两个子表达式的任意一个去匹配字符串，例如 `abba | cde` 要么匹配字符串 `abba` 要么匹配字符串 `cde`，要注意在字符集内，即 `abba|cde`，二选一的匹配不凑效，因为中缀符 `|` 有它的字面意思。

重复匹配 Repetition 的优先级高于级联，级联高于 `|` 。 整个子表达式可以括号括起来覆盖这些优先级规则。

## 反向引用 {#backreference}

反向引用 `\N` 这里 N 可取 1,2,...,9 匹配被之前第 N 个括起来的子表达式匹配的子字符串

## 命名组 {#groups}

The pattern `(?:...)` groups characters just as parentheses do but does not make a backreference.

Patterns `(?=...)` and `(?!...)` are zero-width positive and negative lookahead assertions: they match if an attempt to match the `...` forward from the current position would succeed (or not), but use up no characters in the string being processed. Patterns `(?<=...)` and `(?<!...)` are the lookbehind equivalents: they do not allow repetition quantifiers nor `\C` in `...`.

- `(?...)` 命名组 name group
- `(?=...)` 与 `(?!...)` 正向查找
- `(?<=...)` 与 `(?<!...)` 反向查找


函数 `regexpr` 和 `gregexpr` 支持 named capture. If groups are named, e.g., `(?<first>[A-Z][a-z]+)` then the positions of the matches are also returned by name. 函数 `sub` 不支持 Named backreferences

Atomic grouping, possessive qualifiers and conditional and recursive patterns are not covered here.


[^char-byte]: `useBytes = TRUE` 表示把字符看作字节。字符、字节和比特的关系是，一个字节 byte 八个比特 bit，一个英文字符 character 用一个字节表示，而一个中、日、韩文字符需要两个字节表示 
[^learn-regex]: 推荐的学习正则表达式的路径可以见统计之都论坛 <https://d.cosx.org/d/420410>


## 注释 {#comment}

The sequence `(?#` marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part at all in the pattern matching.

If the extended option is set, an unescaped `#` character outside a character class introduces a comment that continues up to the next newline character in the pattern.


## `grep` 和 `grepl` {#grep-grepl}

- `ignore.case`: `TRUE` 表示忽略大小写，`FALSE` 表示大小写敏感^[case sensitive]的，匹配的时候区分大小写

`grep` 返回匹配到的字符串向量x的元素的下标，如果 `value=TRUE` 则返回下标对应的值

```{r,echo=TRUE}
grep(x = c("apple", "banana"), pattern = "a")
grep(x = c("apple", "banana"), pattern = "b")
grep(x = c("apple", "banana"), pattern = "a", value = TRUE)
grep(x = c("apple", "banana"), pattern = "b", value = TRUE)
```

`grepl` 返回一个逻辑向量，字符串向量x中的每个元素是否匹配到，匹配到返回 `TRUE`，没有匹配到返回 `FALSE`

```{r,echo=TRUE}
grepl(x = c("apple", "banana"), pattern = "a")
grepl(x = c("apple", "banana"), pattern = "b")
```

- `fixed=TRUE` 表示启用原生字符raw strings匹配，或者 literal regular expression 字面正则表达式，默认情况下 `fixed=FALSE`

::: sidebar
R 是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式
::: 

在 R 里面分别表示 `a\\b` 和 `a\b`

```{r,echo=TRUE}
writeLines(c("a\\\\b", "a\\b"))
```

下面在 R 里面分别匹配字符串 `a\\b` 和 `a\b` 中的 `\\` 和 `\`

```{r,echo=TRUE}
# 匹配字符串中的一个反斜杠
grep(x = c("a\\\\b", "a\\b"), pattern = "\\", value = TRUE, fixed = TRUE)
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\", value = TRUE, fixed = FALSE)

# 匹配字符串中的两个反斜杠
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\", value = TRUE, fixed = TRUE)
grep(x = c("a\\\\b", "a\\b"), pattern = "\\\\\\\\", value = TRUE, fixed = FALSE)

# 匹配字符串中的两个反斜杠 \\
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = FALSE)
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = TRUE)
grepl(x = "a\\\\b", pattern = "\\\\", fixed = TRUE)
```

此外，还有一个函数 `grepRaw` 用于匹配 Raw Vectors 

## sub 与 gsub {#sub-gsub}

## regexpr 与 gregexpr {#regexpr-gregexpr}

## regmatches 

Extract or Replace Matched Substrings

Extract or replace matched substrings from match data obtained by regexpr, gregexpr or regexec.

## stringi 和 stringr {#stringi-stringr}


## RCurl 和 XML {#rcurl-xml}

用 R 语言写爬虫 解析网页

web 服务都会用到正则吧

curl 和 xml2 以及 rvest

## 扩展阅读 {#more-readings}

[How did Axios rectangle Trump's PDF schedule? A try with R](https://masalmon.eu/2019/02/11/trump-schedule/) 使用 pdftools 和 magick 处理表格，这两个R包分别依赖 Poppler C++ 和 ImageMagick++

如何在 Ubuntu 18.04 上安装 `poppler >= 0.73` [^install-poppler]

[^install-poppler]: https://askubuntu.com/questions/1112856

[Manipulating strings with the {stringr} package](https://www.brodrigues.co/blog/2019-02-10-stringr_package/)

PDF 表格抽取工具 [tabulizer](https://github.com/ropensci/tabulizer)

在 Ubuntu 上安装 pdftools 和 magick

```bash
sudo apt-get install libpoppler-cpp-dev libmagick++-dev
```

```{r,echo=TRUE,eval=FALSE}
install.packages(c("pdftools", "magick"))
```


