# 字符 {#regex}

  Handling Strings with R 

- https://www.gastonsanchez.com/r4strings/

  Text Mining with R A Tidy Approach

- https://www.tidytextmining.com/

  stringr: Simple, Consistent Wrappers for Common String Operations

- https://stringr.tidyverse.org/

在 R 控制台输入 `?regex` 查看正则表达式，`?regex` 可以看百八十遍

入门字符串处理

- https://r4ds.had.co.nz/strings.html

stringi: Character String Processing Facilities

- http://www.gagolewski.com/software/stringi/manual/

R 语言中有两套正则表达式

*extended regular expressions* (the default)
*Perl-like regular expressions* used by `perl = TRUE`
There is also `fixed = TRUE` which can be considered to use a *literal regular expression*.

> 注意 这里只关注 extended regular expressions

学习正则表达式的路径^[<https://d.cosx.org/d/420410>]



regex Regular Expressions as used in R

> grep and related functions grepl, regexpr, gregexpr, sub and gsub, as well as by strsplit.

谢益辉常用的操作函数是 `grep()`、`gsub()`、`gregexpr()` 和 `regmatches()`

支持正则表达式的函数 `grep`, `apropos`, `browseEnv`, `glob2rx`, `help.search`, `list.files`, `ls` and `strsplit`.

apropos, browseEnv, help.search, list.files and ls 函数通过使用 grep 使用正则表达式 extended regular expressions.


正则表达式的构造方式类似算术表达式，通过各种操作组合子（更小的）表达式，整个表达式匹配一个或多个字符。[^char-byte]

大多数字符，包括所有的字母和数字，是匹配自身的正则表达式。带有特定意义的任何元字符可以通过反斜杠引用。在 extended regular expressions 中，元字符是 

```
. \ | ( ) [ { ^ $ * + ? 
```

要注意，它们是否有特殊意义取决于所在的内容。

一个字符集 character class 是用一对中括号`[]`括起来的字符列表，用来匹配在哪个列表中的任意一（单）个字符，除非列表中的第一个字符是 `^`，它用来匹配任意的不在这个列表中的字符。 `[0123456789]` 用来匹配任意单个数字，`[^abc]` 用来匹配除字符 `a,b,c` 以外的任意字符。

字符范围可以通过第一个和最后一个字符指定，中间用连字符连接，但是由于这种解释依赖于区域和具体实现，所以指定字符范围这个方式最好避免。

唯一可移植（便携）的方式是作为字符类，在列表中列出所有的 ASCII 字母，
`[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]`.

某些命名的字符类是预定义的，它们的解释 interpretation 依赖于区域 locale，下面的解释是  POSIX locale

- `[:alnum:]` 表示  `[:alpha:]` 和 `[:digit:]`
- `[:alpha:]` 表示 `[:lower:]` 和 `[:upper:]`
- `[:blank:]` 表示 空格 space 制表符 tab
- `[:cntrl:]` 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。 
- `[:digit:]` 表示数字 0,1,2,3,4,5,6,7,8,9
- `[:graph:]` 表示 `[:alnum:]` 和 `[:punct:]`.
- `[:lower:]` 表示当前区域下的小写字母
- `[:print:]` 表示可打印的字符  `[:alnum:]`, `[:punct:]` 和空格.
- `[:punct:]` 表示标点字符 

  ```
  ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~`
  ```

- `[:space:]` 表示空格字符 tab（水平制表符）, newline 换行符, 垂直制表符 vertical tab, form feed 换页符, carriage return回车符, space 空格
- `[:xdigit:]` 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.
- `[[:alnum:]]` 的含义是 `[0-9A-Za-z]`，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号`[]`是符号名的一部分,是必须要包含的。在字符集中，大多数元字符 metacharacters 失去它们特殊的意义。

To include a literal ], place it first in the list. Similarly, to include a literal ^, place it anywhere but first. Finally, to include a literal -, place it first or last (or, for perl = TRUE only, precede it by a backslash). (Only ^ - \ ] are special inside character classes.)

点号 . 匹配任意单个字符，`\w` 匹配一个词 word 字符(是[[:alnum:]_]的同义词，一个扩展) ，而 `\W` 是 `\w` 取反，意味着 [^[:alnum:]_]。 `\d`, `\s`, `\D` 和 `\S` 表示数字和空格类和它们的取反

caret `^` 和美元符号 `$` 是元字符，分别匹配一行的开头和结尾。符号 `\<` 和 `\>` 分别匹配一个词的开头和结尾的空字符串。`\b` 匹配词边缘的空字符串，`\B` 匹配不在词边缘的空字符串。 词 word 的解释依赖于区域和实现。

一个正则表达式可能跟着重复量词 repetition quantifiers

- `?` 前面的项目匹配至多1次
- `*` 前面的项目匹配0次或多次
- `+` 前面的项目匹配至少1次
- `{n}` 前面的项目匹配 n 次.
- `{n,}` 前面的项目匹配至少 n 次.
- `{n,m}` 前面的项目匹配至少 n 次 至多 m 次

默认情况下， repetition 是贪婪的，会使用最大可能的重复匹配，这个可以变为最小的匹配次数，通过在其之后添加 ?

Regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating the substrings that match the concatenated subexpressions.

正则表达式可以是级联的，是不是在讲一个正则表达式里面嵌套一个正则表达式

> 高级特性

Two regular expressions may be joined by the infix operator |; the resulting regular expression matches any string matching either subexpression. For example, abba|cde matches either the string abba or the string cde. Note that alternation does not work inside character classes, where | has its literal meaning.

两个正则表达式可以通过中缀符号 | 联合，用两个子表达式的任意一个去匹配字符串，例如 `abba | cde` 要么匹配字符串 abba 要么匹配字符串 cde，要注意在字符集内，二选一的匹配不凑效，因为中缀符 | 有它的字面意思 literal meaning


重复匹配的优先级高于级联，级联高于 | 。 整个子表达式可以括号括起来覆盖这些优先级规则。
Repetition takes precedence over concatenation, which in turn takes precedence over alternation. A whole subexpression may be enclosed in parentheses to override these precedence rules.

反向引用 `\N` 这里 N 可取 1,2,...,9 匹配被之前第 N 个括起来的子表达式匹配的子字符串
The backreference `\N`, where N = 1 ... 9, matches the substring previously matched by the Nth parenthesized subexpression of the regular expression. 
(This is an extension for extended regular expressions: POSIX defines them only for basic ones.)

帮助页面是基于 TRE 文档和 POSIX 标准


[^char-byte]: read ‘character’ 字符 as ‘byte’ 字节 if `useBytes = TRUE` 字符、字节、位 bit什么关系 

## grep

```{r,echo=TRUE}
vec_a <- sample(letters, 100, replace = T)
vec_A <- sample(LETTERS, 100, replace = T)
vec_d <- sample(1:10, 100, replace = T)
vec <- paste(vec_a, vec_A, sep = '*',collapse = '+')
```


## sub 与 gsub {#sub-gsub}

## regexpr 与 gregexpr {#regexpr-gregexpr}

## regmatches 

Extract or Replace Matched Substrings

Extract or replace matched substrings from match data obtained by regexpr, gregexpr or regexec.


## 扩展阅读 {#more-readings}

[How did Axios rectangle Trump's PDF schedule? A try with R](https://masalmon.eu/2019/02/11/trump-schedule/) 使用 pdftools 和 magick 处理表格，这两个R包分别依赖 Poppler C++ 和 ImageMagick++

如何在 Ubuntu 18.04 上安装 `poppler >= 0.73` [^install-poppler]

[^install-poppler]: https://askubuntu.com/questions/1112856

[Manipulating strings with the {stringr} package](https://www.brodrigues.co/blog/2019-02-10-stringr_package/)

PDF 表格抽取工具 [tabulizer](https://github.com/ropensci/tabulizer)

在 Ubuntu 上安装 pdftools 和 magick

```bash
sudo apt-get install libpoppler-cpp-dev libmagick++-dev
```

```{r,echo=TRUE,eval=FALSE}
install.packages(c('pdftools', 'magick'))
```


