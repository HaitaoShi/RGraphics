# 数据可视化 {#data-visualization}

50 个 ggplot2 数据可视化例子[^fifty-ggplot2] 

[^fifty-ggplot2]: https://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html

## Why ggplot2? {#why-ggplot2}

为何使用 ggplot2 [^why-ggplot2]



[^why-ggplot2]: http://varianceexplained.org/r/why-I-use-ggplot2/

## ggplot2 简介 {#intro-ggplot2}

首先我们加载 R 包 ggplot2 

```{r,echo=TRUE}
library(ggplot2)
```

ggplot2 提供了很多函数

图层系统

```{r,echo=TRUE}
ls("package:ggplot2", pattern = "^geom_")
```

主题系统

```{r,echo=TRUE}
ls("package:ggplot2", pattern = "^theme_")
```

配色系统

```{r,echo=TRUE}
ls("package:ggplot2", pattern = "^scale_(color|fill)_")
```

坐标系统

```{r,echo=TRUE}
ls("package:ggplot2", pattern = "^coord_")
```

坐标轴刻度变换

```{r,echo=TRUE}
ls("package:ggplot2", pattern = "^scale_(x|y)_")
```


注释

```{r,echo=TRUE}
ls("package:ggplot2", pattern = "^annotate_")
```



## 散点图 {#ggplot2-scatter}

下面以 diamonds 数据集为例展示 ggplot2 的绘图过程，首先加载 diamonds 数据集，查看数据集的内容

```{r load-data,echo=TRUE}
data(diamonds)
str(diamonds)
```

数值型变量 carat 作为 x 轴

```{r diamonds-axis,fig.cap=c("指定 x 轴","数值变量 price 作为纵轴","有序分类变量 cut 指定颜色","指定统一颜色"),echo=TRUE,out.width="35%",fig.align='center',fig.ncol=2,fig.width=3}
ggplot(diamonds, aes(x = carat))
ggplot(diamonds, aes(x = carat, y = price))
ggplot(diamonds, aes(x = carat, color = cut))
ggplot(diamonds, aes(x = carat), color = "steelblue")
```

图 \@ref(fig:diamonds-axis) 的基础上添加数据图层

```{r scatter,fig.cap="添加数据图层",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()
```

给散点图\@ref(fig:scatter)上色

```{r scatter-color-1,fig.cap="散点图配色",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point(color = "steelblue")
```

让另一变量 cut 作为颜色分类指标

```{r scatter-color-2,fig.cap="分类散点图",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price, color = cut)) +
  geom_point()
```

当然还有一种类似的表示就是分组，默认情况下，ggplot2将所有观测点视为一组，以分类变量 cut 来分组

```{r scatter-group,echo=TRUE,fig.cap="分组",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price, group = cut)) +
  geom_point()
```

在图\@ref(fig:scatter-group) 上没有体现出来分组的意思，下面以 cut 分组线性回归为例

```{r group-lm,fig.cap="分组线性回归",echo=TRUE,fig.ncol=1}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth(method = "lm")
ggplot(diamonds, aes(x = carat, y = price, group = cut)) +
  geom_point() +
  geom_smooth(method = "lm")
```

我们当然可以选择更加合适的拟合方式，如局部多项式平滑 `loess` 但是该方法不太适用观测值比较多的情况，因为它会占用比较多的内存，建议使用广义可加模型作平滑拟合

```{r,eval=FALSE,echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price, group = cut)) +
  geom_point() +
  geom_smooth(method = "loess")
```
```{r group-gam,fig.cap="数据分组应用广义可加平滑",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price, group = cut)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))
```

为了更好地区分开组别，我们在图\@ref(fig:group-gam)的基础上分面或者配色

```{r group-facet,fig.cap=c("分组分面","分组配色"),echo=TRUE,fig.ncol=1}
ggplot(diamonds, aes(x = carat, y = price, group = cut)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) +
  facet_grid(~cut)
ggplot(diamonds, aes(x = carat, y = price, group = cut, color = cut)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"))
```

在分类散点图的另一种表示方法就是分面图，以 cut 变量作为分面的依据

```{r scatter-facet,fig.cap="分面散点图",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  facet_grid(~cut)
```

给图 \@ref(fig:scatter-facet) 上色

```{r scatter-facet-color-1,fig.cap="给分面散点图上色",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point(color = "steelblue") +
  facet_grid(~cut)
```

在图\@ref(fig:scatter-facet-color-1)的基础上，给不同的类上不同的颜色

```{r scatter-facet-color-2,fig.cap="给不同的类上不同的颜色",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price, color = cut)) +
  geom_point() +
  facet_grid(~cut)
```

去掉图例，此时图例属于冗余信息了

```{r scatter-facet-color-3,fig.cap="去掉图例",echo=TRUE}
ggplot(diamonds, aes(x = carat, y = price, color = cut)) +
  geom_point(show.legend = FALSE) +
  facet_grid(~cut)
```

图层、分组、分面和散点图介绍完了，接下来就是其它统计图形，如箱线图，小提琴图和条形图

## 箱线图 {#ggplot2-boxplot}

以钻石切割质量 cut 为分面依据，以钻石颜色类别 color 为 x 轴，钻石价格为 y 轴，绘制箱线图\@ref(fig:boxplot-facet-color)

```{r boxplot-facet-color,fig.cap="箱线图"}
ggplot(diamonds, aes(x = color, y = price, color = cut)) +
  geom_boxplot(show.legend = FALSE) +
  facet_grid(~cut)
```

我们当然还可以添加钻石的纯净度 clarity 作为分面依据，那么箱线图可以为图 \@ref(fig:boxplot-facet-color-clarity-1)，但是经过观察，我们发现水平分类过多，考虑用切割质量 cut 替换钻石颜色 color 绘图，但是由于分类过细，图信息展示不简练，反而不好，如图 \@ref(fig:boxplot-facet-color-clarity-2)

```{r boxplot-facet-color-clarity-1,fig.cap="复合分面箱线图",echo=TRUE}
ggplot(diamonds, aes(x = color, y = price, color = cut)) +
  geom_boxplot(show.legend = FALSE) +
  facet_grid(clarity ~ cut)
```

```{r boxplot-facet-color-clarity-2,echo=TRUE,fig.cap=c("切割质量cut上色","钻石颜色配色"),fig.ncol=1}
ggplot(diamonds, aes(x = cut, y = price, color = cut)) +
  geom_boxplot(show.legend = FALSE) +
  facet_grid(clarity ~ color)
ggplot(diamonds, aes(x = cut, y = price, color = color)) +
  geom_boxplot(show.legend = FALSE) +
  facet_grid(clarity ~ color)
```

## 条形图 {#ggplot2-barplot}

条形图特别适合分类变量的展示，我们这里展示钻石切割质量 cut 不同等级的数量，当然我们可以直接展示各类的数目，在图层 `geom_bar` 中指定 `stat="identity"`

```{r,echo=TRUE,eval=FALSE}
# 需要映射数据框的两个变量，相当于自己先计算了每类的数量
with(diamonds, table(cut))
cut_df <- as.data.frame(table(diamonds$cut))
ggplot(cut_df, aes(x = Var1, y = Freq)) + geom_bar(stat = "identity")
```
```{r diamonds-barplot-1,fig.cap="频数条形图",echo=TRUE}
ggplot(diamonds, aes(x = cut)) + geom_bar()
```

还有另外三种表示方法

```{r,eval=FALSE,echo=TRUE}
ggplot(diamonds, aes(x = cut)) + geom_bar(stat = "count")
ggplot(diamonds, aes(x = cut, y = ..count..)) + geom_bar()
ggplot(diamonds, aes(x = cut, y = stat(count))) + geom_bar()
```

我们还可以在图 \@ref(fig:diamonds-barplot-1) 的基础上再添加一个分类变量钻石的纯净度 clarity，形成堆积条形图

```{r diamonds-barplot-2,echo=TRUE,fig.cap="堆积条形图"}
ggplot(diamonds, aes(x = cut, fill = clarity)) + geom_bar()
```

再添加一个分类变量钻石颜色 color 比较好的做法是分面

```{r diamonds-barplot-3,fig.cap="分面堆积条形图",echo=TRUE}
ggplot(diamonds, aes(x = color, fill = clarity)) +
  geom_bar() +
  facet_grid(~cut)
```

实际上，绘制图\@ref(fig:diamonds-barplot-3)包含了对分类变量的分组计数过程，如下

```{r,echo=TRUE}
with(diamonds, table(cut, color))
```

还有一种堆积的方法是按比例，而不是按数量，如图\@ref(fig:diamonds-barplot-4)

```{r diamonds-barplot-4,fig.cap="比例堆积条形图",echo=TRUE}
ggplot(diamonds, aes(x = color, fill = clarity)) +
  geom_bar(position = "fill") +
  facet_grid(~cut)
```

接下来就是复合条形图

```{r diamonds-barplot-5,fig.cap="复合条形图",echo=TRUE}
ggplot(diamonds, aes(x = color, fill = clarity)) +
  geom_bar(position = "dodge")
```

再添加一个分类变量，就是需要分面大法了，图 \@ref(fig:diamonds-barplot-5) 展示了三个分类变量，其实我们还可以再添加一个分类变量用作分面的列依据

```{r diamonds-barplot-6,fig.cap="分面复合条形图",echo=TRUE}
ggplot(diamonds, aes(x = color, fill = clarity)) +
  geom_bar(position = "dodge") +
  facet_grid(rows = vars(cut))
```

图 \@ref(fig:diamonds-barplot-6) 展示的数据如下

```{r,echo=TRUE}
with(diamonds, table(color, clarity, cut))
```

## 折线图 {#ggplot2-line}

时间序列数据的展示，时序图

```{r,fig.cap="时序图",echo=TRUE}
ggplot(economics, aes(date, unemploy)) + geom_line()
```


## 直方图 {#ggplot2-histogram}

直方图用来查看连续变量的分布

```{r,fig.cap="钻石价格的分布",echo=TRUE}
ggplot(diamonds, aes(price)) + geom_histogram(bins = 30)
```

堆积直方图

```{r,fig.cap="钻石价格随切割质量的分布",echo=TRUE}
ggplot(diamonds, aes(x = price, fill = cut)) + geom_histogram(bins = 30)
```

## 提琴图 {#violin}

提琴图

```{r violin,fig.cap=c("箱线图","小提琴图"),echo=TRUE,fig.ncol=1}
ggplot(diamonds, aes(x = cut, y = price)) + geom_boxplot()
ggplot(diamonds, aes(x = cut, y = price)) + geom_violin()
```

## 抖动图 {#jitter}

```{r,fig.cap="抖动图",echo=TRUE}
ggplot(diamonds, aes(x = cut, y = price)) + geom_jitter()
```

分面抖动图

```{r,fig.cap=c("抖动图","根据钻石颜色上色"),fig.ncol=1,echo=TRUE}
ggplot(diamonds, aes(x = color, y = price)) +
  geom_jitter() +
  facet_grid(~cut)
ggplot(diamonds, aes(x = color, y = price, color = color)) +
  geom_jitter() +
  facet_grid(~cut)
```

筛选钻石颜色为 D 纯净度为 SI2 的数据集，全数据集太大，不适合用抖动图表示

```{r,fig.cap="抖动图的反例",echo=TRUE}
ggplot(diamonds, aes(x = color, y = price)) +
  geom_boxplot() + geom_jitter() +
  facet_grid(cut ~ clarity)
```

## 密度图 {#ridge}

添加透明度，解决遮挡

```{r density,fig.cap=c("密度图","添加透明度的密度图"),echo=TRUE,fig.ncol=1}
ggplot(diamonds, aes(x = price, fill = cut)) + geom_density()
ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(alpha = 0.5)
```

堆积密度图

```{r stack-density,fig.cap="堆积密度图",echo=TRUE}
ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(position = "stack")
```

条件密度估计

```{r,fig.cap="条件密度估计图",echo=TRUE}
# You can use position="fill" to produce a conditional density estimate
ggplot(diamonds, aes(carat, stat(count), fill = cut)) +
  geom_density(position = "fill")
```

## 玫瑰图 {#nightingale-rose}

南丁格尔风玫瑰图[^nightingale-rose] 可以作为堆积条形图，分组条形图

```{r stack-to-rose,fig.cap="堆积条形图转风玫瑰图",echo=TRUE}
ggplot(diamonds, aes(x = color, fill = clarity)) +
  geom_bar()
ggplot(diamonds, aes(x = color, fill = clarity)) +
  geom_bar() +
  coord_polar()
```


[^nightingale-rose]: https://mbostock.github.io/protovis/ex/crimea-rose-full.html

## 空间数据 {#sp-vis}

美国各州的犯罪率数据 USArrests

准备数据集

```{r,echo=TRUE}
crimes <- data.frame(state = tolower(rownames(USArrests)), USArrests)
crimesm <- reshape2::melt(crimes, id = 1)
head(crimesm)
```

添加地图数据

```{r,echo=TRUE}
library(maps)
states_map <- map_data("state")
head(states_map)
```

绘图

```{r,echo=TRUE,fig.cap="1973年美国各州的犯罪率数据",echo=TRUE}
ggplot(crimes, aes(map_id = state)) +
  geom_map(aes(fill = Murder), map = states_map) +
  expand_limits(x = states_map$long, y = states_map$lat) + 
  coord_map()
```


```{r,fig.cap="四类犯罪在各州的分布",echo=TRUE}
ggplot(crimesm, aes(map_id = state)) +
  geom_map(aes(fill = value), map = states_map) +
  expand_limits(x = states_map$long, y = states_map$lat) +
  facet_wrap(~variable)
```


[sp-gallery]: https://edzer.github.io/sp/


### raster 对象

星号 * 标记的是 S3 方法

```{r,echo=TRUE}
methods(plot)
```

查看函数的定义

```{r,echo=TRUE}
getAnywhere(plot.raster)
```

rasterImage 函数来绘制图像，如果想知道 `rasterImage` 的内容可以继续看 `getAnywhere(rasterImage)`

```{r,echo=TRUE}
getAnywhere(rasterImage)
```

通过查看函数的帮助 `?rasterImage` ，我们需要重点关注一下
参数 *image* 传递的 raster 对象

### sp 对象

空间数据对象，以类 sp 方式存储 [@Pebesma_2005_sp]

```{r,fig.cap="气泡图",echo=TRUE}
library(sp)
data(meuse)
coords <- SpatialPoints(meuse[c("x", "y")])
meuse <- SpatialPointsDataFrame(coords, meuse)
plot(meuse, pch = 1, cex = .05 * sqrt(meuse$zinc))
```

```{r,echo=TRUE}
library(maptools)
fname <- system.file("shapes/sids.shp", package = "maptools")
p4s <- CRS("+proj=longlat +datum=NAD27")
nc <- readShapePoly(fname, proj4string = p4s)
plot(nc, axes = TRUE, col = grey(1 - nc$SID79 / 57))
```

```{r,echo=TRUE}
# Trellis maps
arrow <- list("SpatialPolygonsRescale",
  layout.north.arrow(2),
  offset = c(-76, 34), scale = 0.5, which = 2
)
spplot(nc, c("SID74", "SID79"),
  as.table = TRUE,
  scales = list(draw = T), sp.layout = arrow
)
```

::: warning
maptools 提供的 `readShapePoly` 函数去读取 shp 文件的方式已经过时，推荐使用 `rgdal::readOGR` 或者 `sf::st_read` 方式读取
:::

### sf 对象 {#simple-features}

- maps
- mapdata
- maptools
- mapproj

- rgeos
- rgdal
- sp

- ggmap
- sf

## 网络数据 {#net-vis}

[igraph](https://igraph.org/) 提供了 R 和 Python 接口 <https://github.com/igraph>。 [qgraph](https://github.com/SachaEpskamp/qgraph) 开发者 [Sacha Epskamp](http://sachaepskamp.com) 在个人主页上提供了很多网络数据分析的学习资料， [Rgraphviz](https://www.bioconductor.org/packages/release/bioc/html/Rgraphviz.html) 基于 [Graphviz](https://www.graphviz.org/)

```{r,echo=TRUE,eval=!require(Rgraphviz)}
BiocManager::install("Rgraphviz", version = "3.8")
```
