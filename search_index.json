[
["index.html", "数据可视化与R语言 Data Visualization with R: Base Lattice GGplot2 Grid 欢迎", " 数据可视化与R语言 Data Visualization with R: Base Lattice GGplot2 Grid 黄湘云 2019-06-06 11:30:17 CST 欢迎 写作动机，如何加入写作，版权声明 强调图的作用，检验模型的重要性 注意 本书要求复现环境是 R 3.6.0 因为书中涉及 barplot 新增的公式方法，新增多维数组操作函数 asplit， axis 函数的 gap.axis ，新增 hcl.colors 函数等，完整列表见官网 What’s New? "],
["01-preface.html", "前言 关于本书 本书结构 关于作者", " 前言 关于本书 这里写每章的主要内容介绍 R包数量增长如此之快 R包如此之多 R包之间依赖关系如此之复杂 每个base R包内的函数如此之多，函数参数之多，ls(\"package:base\") %&gt;% length 数据处理和可视化常用基本包 ggplot2 dplyr 程序设计风格如此之多，面向对象s3 s4 RC R5 R6、过程（函数调用）、响应式 shiny 动态图形、函数式编程（数据操作） 数据结构如此之多 列表list sp sf 统计学家的程序设计思维如此难懂 数据交换接口如此之多，数据库、网页、编程语言 python 等 本书结构 关于作者 热心开源事业，统计之都现任理事、副主编 Associated Editor of Captial of Statistics，经常混迹于统计之都论坛、Github 和爆栈网。个人主页 https://www.xiangyunhuang.com.cn/ "],
["02-introduction.html", "第 1 章 介绍 1.1 Why R 1.2 目标读者 1.3 获取帮助 1.4 发展历史 1.5 记号约定 1.6 软件信息", " 第 1 章 介绍 1.1 Why R 不管是在本科生还是研究生水平的教学中，R 语言都是帮助学习数理统计的理想平台 在数据科学领域内，选择 R 的理由 written by statisticians for statisticians built-in matrix type and matrix manipulations great graphics, both base and CRAN excellent parallelization facilities, etc. — Norm Matloff Python over R How GPL makes me leave R for Python Top 10 reasons R is bad for you R over Python R &gt; Python: A Concrete Example Choosing R or Python for Data Analysis? An Infographic 表 1.1: 我们不打嘴仗，不下结论，只做对比，不完善之处还请大家指出并补充1 比较内容 具体范围 R 包 Python 模块 数据获取 本地、数据库、远程 内置，RCurl、XML、rvest、data.table、 odbc scrapy 数据清理 正则表达式 内置，stringi、stringr、tidyr re 数据聚合 SQL支持的所有操作 内置，dplyr、purrr、dbplyr、sparklyr Numpy、Scipy、Pandas 数据分析 统计推断的所有方法 内置，lme4、rstan、mxnet、xgoost、 tensorflow xgboost、scikit-learn、tensorflow、mxnet 数据展示 数据可视化 内置，ggplot2、plotly matplotlib、bokeh、plotly 数据报告 网页文档、幻灯片 rmarkdown、bookdown、blogdown 数据落地 模型部署，调优，维护 plumber、opencpu、fiery 1.2 目标读者 接触过 R 语言的读者，本书起源于自己的学习笔记，侧重统计图形，当然也包括在制作统计图形之前的数据导入和变换操作，后续的可视化和动态文档 1.3 获取帮助 Getting Help with R 获取帮助 https://blog.rsquaredacademy.com/getting-help-in-r-updated/ https://www.r-project.org/help.html 1.4 发展历史 Ross Ihaka 维基主页 https://en.wikipedia.org/wiki/Ross_Ihaka Ross Ihaka 的学术族谱 https://www.stat.auckland.ac.nz/%7Eihaka/downloads/ihaka.pdf R: Lessons Learned, Directions for the Future. https://www.stat.auckland.ac.nz/%7Eihaka/downloads/JSM-Talk.pdf R语言的前世今生 https://www.cnblogs.com/chenkai/archive/2013/05/16/3082889.html Robert Gentleman 维基主页 https://en.wikipedia.org/wiki/Robert_Gentleman_(statistician) UseR 2016: Forty years of S UseR 2017: 20 years of CRAN 统计软件 JASP Rcmdr rattle radiant 1.5 记号约定 写作风格，R 包名称都加粗表示，如 bookdown， rmarkdown 等，软件、编程语言名称保持原样，如 TinyTeX，LyX，TeXLive，R，Python，Stan，C++，SQL等，在代码块中，我们不使用R&gt;或+，代码输出结果用#&gt;注释。knitr (Xie 2015) bookdown (Xie 2016) 和 Pandoc TinyTeX ，请使用 XeLaTeX 编译这本书，等宽字体为 inconsolata 默认的文本字体为 Times 1.6 软件信息 重现本书内容需要的 R 包 sessionInfo() #&gt; R version 3.6.0 (2019-04-26) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 8.1 x64 (build 9600) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=Chinese (Simplified)_China.936 #&gt; [2] LC_CTYPE=Chinese (Simplified)_China.936 #&gt; [3] LC_MONETARY=Chinese (Simplified)_China.936 #&gt; [4] LC_NUMERIC=C #&gt; [5] LC_TIME=Chinese (Simplified)_China.936 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] compiler_3.6.0 magrittr_1.5 bookdown_0.10 tools_3.6.0 #&gt; [5] htmltools_0.3.6 curl_3.3 yaml_2.2.0 Rcpp_1.0.1 #&gt; [9] stringi_1.4.3 rmarkdown_1.13 knitr_1.23 stringr_1.4.0 #&gt; [13] xfun_0.7 digest_0.6.19 evaluate_0.13 参考文献 "],
["03-setup.html", "第 2 章 安装与配置 2.1 仓库安装 2.2 源码安装 2.3 忍者安装 2.4 配置 2.5 命令行参数", " 第 2 章 安装与配置 主要参考 R-admin 2.1 仓库安装 2.1.1 Ubuntu 安装 openssh zsh 和 Git sudo apt-get install zsh openssh-server sudo add-apt-repository -y ppa:git-core/ppa sudo apt update &amp;&amp; sudo apt install git sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 只考虑最新的 Ubuntu 18.04 因为本书写成的时候，该版本应该已经大规模使用了，默认版本的安装和之前版本的安装就不再展示了。安装最新版 R-3.5.x，无论安装哪个版本，都要先导入密钥 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv E084DAB9 Ubuntu 14.04.5 提供的默认版本 R 3.0.2，安装 R 3.5.x 系列之前的版本，如 R 3.4.4 sudo apt-add-repository -y &quot;deb http://cran.rstudio.com/bin/linux/ubuntu `lsb_release -cs`/&quot; sudo apt-get install r-base-dev 添加完仓库后，都需要更新源sudo apt-get update，安装 R 3.5.x 系列最新版 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu trusty-cran35/&quot; Ubuntu 16.04.5 提供的默认版本 R 3.4.4，这是 R 3.4.x 系列的最新版，安装目前最新的 R 3.5.x 版本需要 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu xenial-cran35/&quot; Ubuntu 18.04.1 提供的默认版本 R 3.4.4，安装目前的最新版本需要 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu bionic-cran35/&quot; 接下来安装 R，详细安装指导见 CRAN 官网。 sudo apt-get install -y r-base-dev Michael Rutter 维护了编译好的二进制版本 https://launchpad.net/~marutter，比如 rstan 包可以通过安装 r-cran-rstan 完成 # R packages for Ubuntu LTS. Based on CRAN Task Views. sudo add-apt-repository -y ppa:marutter/c2d4u3.5 sudo apt-get install r-cran-rstan 2.1.2 CentOS 同样适用于 Fedora 安装指导2 2.2 源码安装 2.2.1 Ubuntu 首先启用源码仓库，否则执行 sudo apt-get build-dep r-base 会报如下错误 E: You must put some &#39;source&#39; URIs in your sources.list sudo sed -i -- &#39;s/#deb-src/deb-src/g&#39; /etc/apt/sources.list &amp;&amp; sudo sed -i -- &#39;s/# deb-src/deb-src/g&#39; /etc/apt/sources.list sudo apt-get update 安装编译 R 所需的系统依赖 sudo apt-get build-dep r-base-dev 编译安装 R ./configure make &amp;&amp; make install 自定义编译选项 ./configure --help 2.2.2 CentOS 基于 CentOS 7 和 GCC 4.8.5，参考 R-admin 手册 下载源码包 最新发布的稳定版 curl -fLo ./R-latest.tar.gz https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 10 28.7M 10 3232k 0 0 107k 0 0:04:34 0:00:30 0:04:04 118k 安装依赖 sudo yum install -y yum-utils epel-release &amp;&amp; sudo yum-builddep R-devel sudo dnf update &amp;&amp; sudo dnf builddep R-devel # Fedora 30 解压配置 mkdir R-latest &amp;&amp; tar -xzf ./R-latest.tar.gz -C ./R-latest &amp;&amp; cd R-3.5.2 ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 编译安装 make -j 2 all sudo make install BLAS 加持（可选） BLAS 对于加快矩阵计算至关重要，编译 R 带 BLAS 支持，添加 OpenBLAS 支持 --with-blas=\"-lopenblas\" 或 ATLAS 支持 --with-blas=\"-L/usr/lib64/atlas -lsatlas\" sudo yum install -y openblas openblas-threads openblas-openmp ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling \\ --with-blas=&quot;-lopenblas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, **BLAS(OpenBLAS)**, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 配置成功的标志，如 OpenBLAS checking for dgemm_ in -lopenblas... yes checking whether double complex BLAS can be used... yes checking whether the BLAS is complete... yes ATLAS 加持 sudo yum install -y atlas ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling \\ --with-blas=&quot;-L/usr/lib64/atlas -lsatlas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, **BLAS(generic)**, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes ATLAS 配置成功 checking for dgemm_ in -L/usr/lib64/atlas -lsatlas... yes checking whether double complex BLAS can be used... yes checking whether the BLAS is complete... yes 后续步骤同上 2.3 忍者安装 从源码自定义安装：加速 Intel MKL 和 大文件支持 https://software.intel.com/en-us/articles/using-intel-mkl-with-r 2.4 配置 2.4.1 初始会话 .Rprofile .Rprofile 文件位于 ~/ 目录下或者 R 项目的根目录下 查看帮助 ?.Rprofile 更多配置设置 startup 2.4.2 环境变量 .Renviron .Renviron 文件位于 ~/ 目录下 2.4.3 编译选项 Makevars Makevars 文件位于 ~/.R/ 目录下 2.5 命令行参数 commandArgs 从终端命令行中传递参数 rdoc 高亮 R 帮助文档中的 R 函数、关键字 NULL。启用需要在R控制台中执行 rdoc::use_rdoc() radian 代码自动补全和语法高亮，进入 R 控制台，终端中输入radian docopt 提供R命令行工具，如 littler 包，getopt 从终端命令行接受参数 optparse 命令行选项参数的解析器 安装完 R-littler R-littler-examples (centos) 或 littler r-cran-littler (ubuntu) 后，执行 # centos sudo ln -s /usr/lib64/R/library/littler/examples/install.r /usr/bin/install.r sudo ln -s /usr/lib64/R/library/littler/examples/install2.r /usr/bin/install2.r sudo ln -s /usr/lib64/R/library/littler/examples/installGithub.r /usr/bin/installGithub.r sudo ln -s /usr/lib64/R/library/littler/examples/testInstalled.r /usr/bin/testInstalled.r # ubuntu sudo ln -s /usr/lib/R/site-library/littler/examples/install.r /usr/bin/install.r sudo ln -s /usr/lib/R/site-library/littler/examples/install2.r /usr/bin/install2.r sudo ln -s /usr/lib/R/site-library/littler/examples/installGithub.r /usr/bin/installGithub.r sudo ln -s /usr/lib/R/site-library/littler/examples/testInstalled.r /usr/bin/testInstalled.r 这样可以载终端中安装 R 包了 install.r docopt 在 CentOS 7 上打造 R 语言编程环境↩ "],
["04-file-system.html", "第 3 章 文件管理员 3.1 查看文件 3.2 操作文件 3.3 压缩文件 3.4 路径操作 3.5 查找文件 3.6 文件权限 3.7 区域设置 3.8 进程管理 3.9 系统命令 3.10 时间管理 3.11 R 包管理 3.12 查找函数", " 第 3 章 文件管理员 考虑添加 Shell 下的命令实现，参考 命令行的艺术 library(magrittr) # 提供管道命令 %&gt;% fs 由 Jim Hester 开发，提供文件系统操作的统一接口，相比于 R 默认的文件系统的操作函数有显而易见的优点，详情请看 https://fs.r-lib.org/ 对于文件操作，Jim Hester 开发了 fs 包 目的是统一文件操作的命令，由于时间和历史原因，R内置的文件操作函数的命名很不统一，如 path.expand() 和 normalizePath()，Sys.chmod() 和 file.access() 等 # 加载 R 包 library(fs) 3.1 查看文件 文件夹只包含文件，目录既包含文件又包含文件夹，list.dirs 列出目录或文件夹，list.files 列出文件或文件夹 list.dirs(path = \".\", full.names = TRUE, recursive = TRUE) path: 指定完整路径名，默认使用当前路径 getwd() full.names: TRUE 返回相对路径，FALSE 返回目录的名称 recursive: 是否递归的方式列出目录，如果是的话，目录下的子目录也会列出 # list.dirs(path = &#39;.&#39;, full.names = TRUE, recursive = TRUE) list.dirs(path = &#39;.&#39;, full.names = TRUE, recursive = FALSE) #&gt; [1] &quot;./.git&quot; #&gt; [2] &quot;./.Rproj.user&quot; #&gt; [3] &quot;./_book&quot; #&gt; [4] &quot;./_bookdown_files&quot; #&gt; [5] &quot;./01-preface_cache&quot; #&gt; [6] &quot;./02-introduction_cache&quot; #&gt; [7] &quot;./04-file-system_cache&quot; #&gt; [8] &quot;./06-data-import-export_cache&quot; #&gt; [9] &quot;./08-data-manipulation_cache&quot; #&gt; [10] &quot;./08-data-manipulation_files&quot; #&gt; [11] &quot;./09-vector-manipulation_cache&quot; #&gt; [12] &quot;./10-data-cleaning-with-string_cache&quot; #&gt; [13] &quot;./11-data-cleaning-with-stringr_cache&quot; #&gt; [14] &quot;./12-data-cleaning-with-regexp_cache&quot; #&gt; [15] &quot;./13-data-visualization-with-plot_cache&quot; #&gt; [16] &quot;./13-data-visualization-with-plot_files&quot; #&gt; [17] &quot;./14-data-visualization-with-plot3d_cache&quot; #&gt; [18] &quot;./14-data-visualization-with-plot3d_files&quot; #&gt; [19] &quot;./15-data-visualization-with-ggplot2_cache&quot; #&gt; [20] &quot;./15-data-visualization-with-ggplot2_files&quot; #&gt; [21] &quot;./16-data-visualization-with-colors-fonts_cache&quot; #&gt; [22] &quot;./16-data-visualization-with-colors-fonts_files&quot; #&gt; [23] &quot;./17-interactive-graphics_cache&quot; #&gt; [24] &quot;./17-interactive-graphics_files&quot; #&gt; [25] &quot;./18-dynamic-documents_cache&quot; #&gt; [26] &quot;./18-dynamic-documents_files&quot; #&gt; [27] &quot;./19-data-cleaning-with-python_cache&quot; #&gt; [28] &quot;./code&quot; #&gt; [29] &quot;./css&quot; #&gt; [30] &quot;./data&quot; #&gt; [31] &quot;./figures&quot; #&gt; [32] &quot;./images&quot; #&gt; [33] &quot;./index_cache&quot; #&gt; [34] &quot;./index_files&quot; #&gt; [35] &quot;./latex&quot; #&gt; [36] &quot;./rsconnect&quot; list.dirs(path = &#39;.&#39;, full.names = FALSE, recursive = FALSE) #&gt; [1] &quot;.git&quot; #&gt; [2] &quot;.Rproj.user&quot; #&gt; [3] &quot;_book&quot; #&gt; [4] &quot;_bookdown_files&quot; #&gt; [5] &quot;01-preface_cache&quot; #&gt; [6] &quot;02-introduction_cache&quot; #&gt; [7] &quot;04-file-system_cache&quot; #&gt; [8] &quot;06-data-import-export_cache&quot; #&gt; [9] &quot;08-data-manipulation_cache&quot; #&gt; [10] &quot;08-data-manipulation_files&quot; #&gt; [11] &quot;09-vector-manipulation_cache&quot; #&gt; [12] &quot;10-data-cleaning-with-string_cache&quot; #&gt; [13] &quot;11-data-cleaning-with-stringr_cache&quot; #&gt; [14] &quot;12-data-cleaning-with-regexp_cache&quot; #&gt; [15] &quot;13-data-visualization-with-plot_cache&quot; #&gt; [16] &quot;13-data-visualization-with-plot_files&quot; #&gt; [17] &quot;14-data-visualization-with-plot3d_cache&quot; #&gt; [18] &quot;14-data-visualization-with-plot3d_files&quot; #&gt; [19] &quot;15-data-visualization-with-ggplot2_cache&quot; #&gt; [20] &quot;15-data-visualization-with-ggplot2_files&quot; #&gt; [21] &quot;16-data-visualization-with-colors-fonts_cache&quot; #&gt; [22] &quot;16-data-visualization-with-colors-fonts_files&quot; #&gt; [23] &quot;17-interactive-graphics_cache&quot; #&gt; [24] &quot;17-interactive-graphics_files&quot; #&gt; [25] &quot;18-dynamic-documents_cache&quot; #&gt; [26] &quot;18-dynamic-documents_files&quot; #&gt; [27] &quot;19-data-cleaning-with-python_cache&quot; #&gt; [28] &quot;code&quot; #&gt; [29] &quot;css&quot; #&gt; [30] &quot;data&quot; #&gt; [31] &quot;figures&quot; #&gt; [32] &quot;images&quot; #&gt; [33] &quot;index_cache&quot; #&gt; [34] &quot;index_files&quot; #&gt; [35] &quot;latex&quot; #&gt; [36] &quot;rsconnect&quot; list.files(path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE,ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 是否递归的方式列出目录，如果是的话，目录下的子目录也会列出 path: 指定完整路径名，默认使用当前路径 getwd() full.names: TRUE 返回相对路径，FALSE 返回目录的名称 recursive: 是否递归的方式列出目录，如果是的话，目录下的子目录也会列出 file.show(..., header = rep(\"\", nfiles), title = \"R Information\", delete.file = FALSE, pager = getOption(\"pager\"),encoding = \"\") 打开文件内容，file.show 会在R终端中新开一个窗口显示文件，如图3.1所示 rinternals &lt;- file.path(R.home(&quot;include&quot;), &quot;Rinternals.h&quot;) # file.show(rinternals) knitr::include_graphics(path = &#39;figures/show-file.png&#39;) 图 3.1: file.show 打开文件 file.info(..., extra_cols = TRUE) 获取文件信息，此外 file.mode(...) 、 file.mtime(...) 和 file.size(...) 分别表示文件的读写权限，修改时间和文件大小。 file.info(rinternals) #&gt; size isdir mode #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h 57273 FALSE 666 #&gt; mtime #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h 2019-04-11 23:02:02 #&gt; ctime #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h 2019-05-14 18:19:50 #&gt; atime exe #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h 2019-05-14 18:19:50 no file.mode(rinternals) #&gt; [1] &quot;666&quot; file.mtime(rinternals) #&gt; [1] &quot;2019-04-11 23:02:02 CST&quot; file.size(rinternals) #&gt; [1] 57273 # 查看当前目录的权限 file.info(&quot;.&quot;) #&gt; size isdir mode mtime ctime atime #&gt; . 0 TRUE 777 2019-05-27 00:47:32 2019-01-18 17:00:19 2019-05-27 00:47:32 #&gt; exe #&gt; . no # 查看指定目录权限 file.info(&quot;./_book/&quot;) #&gt; size isdir mode mtime ctime #&gt; ./_book/ 0 TRUE 777 2019-05-27 00:47:33 2019-05-27 00:00:36 #&gt; atime exe #&gt; ./_book/ 2019-05-27 00:47:33 no file.access(names, mode = 0) 文件是否可以被访问，第二个参数 mode 一共有四种取值 0，1，2，4，分别表示文件的存在性，可执行，可写和可读四种，返回值 0 表示成功，返回值 -1 表示失败。 file.access(rinternals,mode = 0) #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h #&gt; 0 file.access(rinternals,mode = 1) #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h #&gt; -1 file.access(rinternals,mode = 2) #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h #&gt; -1 file.access(rinternals,mode = 4) #&gt; C:/PROGRA~1/R/R-36~1.0/include/Rinternals.h #&gt; 0 dir(path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 查看目录，首先看看和目录操作有关的函数列表 apropos(&quot;^dir.&quot;) #&gt; [1] &quot;dir.create&quot; &quot;dir.exists&quot; &quot;dir_copy&quot; &quot;dir_create&quot; &quot;dir_delete&quot; #&gt; [6] &quot;dir_exists&quot; &quot;dir_info&quot; &quot;dir_ls&quot; &quot;dir_map&quot; &quot;dir_tree&quot; #&gt; [11] &quot;dir_walk&quot; &quot;dirname&quot; 显而易见，dir.create 和 dir.exists 分别是创建目录和查看目录的存在性。dirname 和 basename 是一对函数用来操作文件路径。以当前目录C:/Users/xy-huang/Desktop/RGraphics为例，dirname(getwd()) 返回 C:/Users/xy-huang/Desktop 而 basename(getwd()) 返回 RGraphics。对于文件路径而言，dirname(rinternals) 返回文件所在的目录C:/PROGRA1/R/R-361.0/include， basename(rinternals) 返回文件名Rinternals.h。dir 函数查看指定路径或目录下的文件，支持以模式匹配和递归的方式查找目录下的文件 # 当前目录下的子目录和文件 dir() #&gt; [1] &quot;_book&quot; #&gt; [2] &quot;_bookdown.yml&quot; #&gt; [3] &quot;_bookdown_files&quot; #&gt; [4] &quot;_common.R&quot; #&gt; [5] &quot;_deploy.sh&quot; #&gt; [6] &quot;_output.yml&quot; .... # 查看指定目录的子目录和文件 dir(path = &quot;./&quot;) #&gt; [1] &quot;_book&quot; #&gt; [2] &quot;_bookdown.yml&quot; #&gt; [3] &quot;_bookdown_files&quot; #&gt; [4] &quot;_common.R&quot; #&gt; [5] &quot;_deploy.sh&quot; #&gt; [6] &quot;_output.yml&quot; .... # 只列出以字母R开头的子目录和文件 dir(path = &quot;./&quot;, pattern = &quot;^R&quot;) #&gt; [1] &quot;README.md&quot; &quot;RGraphics.rds&quot; &quot;RGraphics.Rproj&quot; # 列出目录下所有目录和文件，包括隐藏文件 dir(path = &quot;./&quot;, all.files = TRUE) #&gt; [1] &quot;.&quot; #&gt; [2] &quot;..&quot; #&gt; [3] &quot;.git&quot; #&gt; [4] &quot;.gitignore&quot; #&gt; [5] &quot;.Rhistory&quot; #&gt; [6] &quot;.Rproj.user&quot; .... # 支持正则表达式 dir(pattern = &#39;^[A-Z]+[.]txt$&#39;, full.names=TRUE, system.file(&#39;doc&#39;, &#39;SuiteSparse&#39;, package=&#39;Matrix&#39;)) #&gt; [1] &quot;D:/library/Matrix/doc/SuiteSparse/AMD.txt&quot; #&gt; [2] &quot;D:/library/Matrix/doc/SuiteSparse/CHOLMOD.txt&quot; #&gt; [3] &quot;D:/library/Matrix/doc/SuiteSparse/COLAMD.txt&quot; #&gt; [4] &quot;D:/library/Matrix/doc/SuiteSparse/SPQR.txt&quot; # 在临时目录下递归创建一个目录 dir.create(paste0(tempdir(), &quot;/_book/tmp&quot;), recursive = TRUE) 查看当前目录下的文件和文件夹 tree -L 2 . 或者 ls -l . 3.2 操作文件 实现文件增删改查的函数如下 apropos(&quot;^file.&quot;) #&gt; [1] &quot;file.access&quot; &quot;file.append&quot; &quot;file.choose&quot; &quot;file.copy&quot; #&gt; [5] &quot;file.create&quot; &quot;file.edit&quot; &quot;file.exists&quot; &quot;file.info&quot; #&gt; [9] &quot;file.link&quot; &quot;file.mode&quot; &quot;file.mtime&quot; &quot;file.path&quot; #&gt; [13] &quot;file.remove&quot; &quot;file.rename&quot; &quot;file.show&quot; &quot;file.size&quot; #&gt; [17] &quot;file.symlink&quot; &quot;file_access&quot; &quot;file_chmod&quot; &quot;file_chown&quot; #&gt; [21] &quot;file_copy&quot; &quot;file_create&quot; &quot;file_delete&quot; &quot;file_exists&quot; #&gt; [25] &quot;file_info&quot; &quot;file_move&quot; &quot;file_show&quot; &quot;file_size&quot; #&gt; [29] &quot;file_temp&quot; &quot;file_temp_pop&quot; &quot;file_temp_push&quot; &quot;file_test&quot; #&gt; [33] &quot;file_touch&quot; &quot;fileSnapshot&quot; file.create(..., showWarnings = TRUE) 创建/删除文件，检查文件的存在性 file.create(&#39;demo.txt&#39;) #&gt; [1] TRUE file.exists(&#39;demo.txt&#39;) #&gt; [1] TRUE file.remove(&#39;demo.txt&#39;) #&gt; [1] TRUE file.exists(&#39;demo.txt&#39;) #&gt; [1] FALSE file.rename(from, to) 文件重命名 file.create(&#39;demo.txt&#39;) #&gt; [1] TRUE file.rename(from = &#39;demo.txt&#39;, to = &#39;tmp.txt&#39;) #&gt; [1] TRUE file.exists(&#39;tmp.txt&#39;) #&gt; [1] TRUE file.append(file1, file2) 追加文件 file2 的内容到文件 file1 上 if(!dir.exists(paths = &#39;data/&#39;)) dir.create(path = &#39;data/&#39;) # 创建两个临时文件 # file.create(c(&#39;data/tmp1.md&#39;,&#39;data/tmp2.md&#39;)) # 写入内容 cat(&quot;AAA\\n&quot;, file = &#39;data/tmp1.md&#39;) cat(&quot;BBB\\n&quot;, file = &#39;data/tmp2.md&#39;) # 追加文件 file.append(file1 = &#39;data/tmp1.md&#39;, file2 = &#39;data/tmp2.md&#39;) #&gt; [1] TRUE # 展示文件内容 readLines(&#39;data/tmp1.md&#39;) #&gt; [1] &quot;AAA&quot; &quot;BBB&quot; file.copy(from, to, overwrite = recursive, recursive = FALSE,copy.mode = TRUE, copy.date = FALSE) 复制文件，参考 https://blog.csdn.net/wzj_110/article/details/86497860 file.copy(from = &#39;Makefile&#39;, to = &#39;data/Makefile&#39;) #&gt; [1] FALSE file.symlink(from, to) 创建符号链接 file.link(from, to) 创建硬链接 Sys.junction(from, to) windows 平台上的函数，提供类似符号链接的功能 Sys.readlink(paths) 读取文件的符号链接（软链接） choose.files 在 Windows 环境下交互式地选择一个或多个文件，所以该函数只运行于 Windows 环境 # 选择 zip 格式的压缩文件或其它 if (interactive()) choose.files(filters = Filters[c(&quot;zip&quot;, &quot;All&quot;),]) Filters 参数传递一个矩阵，用来描述或标记R识别的文件类型，上面这个例子就能筛选出 zip 格式的文件 download.file 文件下载 download.file(url = &#39;https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz&#39;, destfile = &#39;data/R-latest.tar.gz&#39;, method = &#39;auto&#39;) 3.3 压缩文件 tar 和 zip 是两种常见的压缩文件工具，具有免费和跨平台的特点，因此应用范围广3。 R 内对应的压缩与解压缩命令是 tar/untar tar(tarfile, files = NULL, compression = c(&quot;none&quot;, &quot;gzip&quot;, &quot;bzip2&quot;, &quot;xz&quot;), compression_level = 6, tar = Sys.getenv(&quot;tar&quot;), extra_flags = &quot;&quot;) 比较常用的压缩文件格式是 .tar.gz 和 .tar.bz2，将目录 _book/及其文件分别压缩成 _book.tar.gz 和 _book.tar.bz2 压缩包的名字可以任意取，后者压缩比率高。.tar.xz 的压缩比率最高，需要确保系统中安装了 gzip，bzip2 和 xz-utils 软件，R 软件自带的 tar 软件来自 Rtools4，我们可以通过设置系统环境变量 Sys.setenv(tar=\"path/to/tar\") 指定外部 tar。tar 实际支持的压缩类型只有 .tar.gz5。zip/unzip 压缩与解压缩就不赘述了。 # 打包目录 _book tar(tarfile = &#39;data/_book.tar&#39;, files = &#39;_book&#39;, compression = &#39;none&#39;) # 文件压缩成 _book.xz 格式 tar(tarfile = &#39;data/_book.tar.xz&#39;, files = &#39;data/_book&#39;, compression = &#39;xz&#39;) # tar -cf data/_book.tar _book 然后 xz -z data/_book.tar.xz data/_book.tar # 或者一次压缩到位 tar -Jcf data/_book.tar.xz _book/ # 解压 xz -d data/_book.tar.xz 再次解压 tar -xf data/_book.tar # 或者一次解压 tar -Jxf data/_book.tar.xz # 文件压缩成 _book.tar.gz 格式 # tar -czf data/_book.tar.gz _book tar(tarfile = &#39;data/_book.tar.gz&#39;, files = &#39;_book&#39;, compression = &#39;gzip&#39;) # 解压 tar -xzf data/_book.tar.gz # 文件压缩成 .tar.bz2 格式 # tar -cjf data/book2.tar.bz2 _book tar(tarfile = &#39;data/_book.tar.bz2&#39;, files = &#39;_book&#39;, compression = &#39;bzip2&#39;) # 解压 tar -xjf data/book2.tar.bz2 untar(tarfile, files = NULL, list = FALSE, exdir = &quot;.&quot;, compressed = NA, extras = NULL, verbose = FALSE, restore_times = TRUE, tar = Sys.getenv(&quot;TAR&quot;)) 3.4 路径操作 环境变量算是路径操作 # 获取环境变量 Sys.getenv(&quot;PATH&quot;) #&gt; [1] &quot;C:\\\\Program Files\\\\R\\\\R-3.6.0\\\\bin\\\\x64;C:\\\\Rtools\\\\bin;C:\\\\Rtools\\\\mingw_64\\\\bin;C:\\\\Rtools\\\\mingw_32\\\\bin;C:\\\\Program Files\\\\Microsoft MPI\\\\Bin\\\\;C:\\\\Program Files (x86)\\\\Common Files\\\\Oracle\\\\Java\\\\javapath;C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v9.2\\\\bin;C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v9.2\\\\libnvvp;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Program Files\\\\Intel\\\\WiFi\\\\bin\\\\;C:\\\\Program Files\\\\Common Files\\\\Intel\\\\WirelessCommon\\\\;C:\\\\Program Files (x86)\\\\NVIDIA Corporation\\\\PhysX\\\\Common;D:\\\\Program Files\\\\qpdf-8.0.2\\\\bin;C:\\\\Program Files\\\\gs\\\\gs9.26\\\\bin;C:\\\\Users\\\\xy-huang\\\\AppData\\\\Local\\\\Programs\\\\orca;C:\\\\Program Files (x86)\\\\LyX 2.3\\\\Perl\\\\bin;D:\\\\Program Files (x86)\\\\optipng-0.7.7-win32;C:\\\\Program Files\\\\Inkscape;C:\\\\ProgramData\\\\chocolatey\\\\bin;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Program Files\\\\nodejs;C:\\\\Program Files\\\\PuTTY;C:\\\\Program Files\\\\Pandoc;C:\\\\Program Files\\\\Pandoc\\\\;D:\\\\Program Files (x86)\\\\bin;C:\\\\Program Files\\\\Intel\\\\WiFi\\\\bin\\\\;C:\\\\Program Files\\\\Common Files\\\\Intel\\\\WirelessCommon\\\\;C:\\\\Program Files\\\\Docker Toolbox;C:\\\\Users\\\\xy-huang\\\\AppData\\\\Local\\\\atom\\\\bin;D:\\\\TinyTeX\\\\bin\\\\win32;C:\\\\Program Files\\\\JetBrains\\\\PyCharm 2018.3.4\\\\bin;;C:\\\\Users\\\\xy-huang\\\\AppData\\\\Roaming\\\\npm&quot; # 设置环境变量 Windows # Sys.setenv(R_GSCMD = &quot;C:/Program Files/gs/gs9.26/bin/gswin64c.exe&quot;) # 设置 pandoc 环境变量 pandoc_path &lt;- Sys.getenv(&quot;RSTUDIO_PANDOC&quot;, NA) if (Sys.which(&quot;pandoc&quot;) == &quot;&quot; &amp;&amp; !is.na(pandoc_path)) { Sys.setenv(PATH = paste( Sys.getenv(&quot;PATH&quot;), pandoc_path, sep = if (.Platform$OS.type == &quot;unix&quot;) &quot;:&quot; else &quot;;&quot; )) } 操作文件路径 file.path Construct Path to File file.path(&#39;./_book&#39;) #&gt; [1] &quot;./_book&quot; path.expand(path) Expand File Paths path.expand(&#39;./_book&#39;) #&gt; [1] &quot;./_book&quot; path.expand(&#39;~&#39;) #&gt; [1] &quot;C:/Users/xy-huang/Documents&quot; normalizePath() Express File Paths in Canonical Form normalizePath(&#39;~&#39;) #&gt; [1] &quot;C:\\\\Users\\\\xy-huang\\\\Documents&quot; normalizePath(&#39;./_book&#39;) #&gt; [1] &quot;C:\\\\Users\\\\xy-huang\\\\Desktop\\\\RGraphics\\\\_book&quot; shortPathName(path) 只在 Windows 下可用，Express File Paths in Short Form cat(shortPathName(c(R.home(), tempdir())), sep = &quot;\\n&quot;) #&gt; C:\\PROGRA~1\\R\\R-36~1.0 #&gt; C:\\Users\\xy-huang\\AppData\\Local\\Temp\\RTMPQ8~1 Sys.glob Wildcard Expansion on File Paths Sys.glob(file.path(R.home(), &quot;library&quot;, &quot;*&quot;, &quot;R&quot;, &quot;*.rdx&quot;)) #&gt; [1] &quot;C:/PROGRA~1/R/R-36~1.0/library/KernSmooth/R/KernSmooth.rdx&quot; #&gt; [2] &quot;C:/PROGRA~1/R/R-36~1.0/library/MASS/R/MASS.rdx&quot; #&gt; [3] &quot;C:/PROGRA~1/R/R-36~1.0/library/Matrix/R/Matrix.rdx&quot; #&gt; [4] &quot;C:/PROGRA~1/R/R-36~1.0/library/base/R/base.rdx&quot; #&gt; [5] &quot;C:/PROGRA~1/R/R-36~1.0/library/boot/R/boot.rdx&quot; #&gt; [6] &quot;C:/PROGRA~1/R/R-36~1.0/library/class/R/class.rdx&quot; .... 3.5 查找文件 here 包用来查找你的文件，查找文件、可执行文件的完整路径、R 包 Sys.which Find Full Paths to Executables Sys.which(&#39;pandoc&#39;) #&gt; pandoc #&gt; &quot;C:\\\\PROGRA~3\\\\CHOCOL~1\\\\bin\\\\pandoc.exe&quot; system.file Find Names of R System Files system.file(&#39;CITATION&#39;,package = &#39;base&#39;) #&gt; [1] &quot;C:/PROGRA~1/R/R-36~1.0/library/base/CITATION&quot; R.home # R 安装目录 R.home() #&gt; [1] &quot;C:/PROGRA~1/R/R-36~1.0&quot; # R执行文件目录 R.home(&#39;bin&#39;) #&gt; [1] &quot;C:/PROGRA~1/R/R-36~1.0/bin/x64&quot; # 配置文件目录 R.home(&#39;etc&#39;) #&gt; [1] &quot;C:/PROGRA~1/R/R-36~1.0/etc&quot; # R 基础扩展包存放目录 R.home(&#39;library&#39;) #&gt; [1] &quot;C:/PROGRA~1/R/R-36~1.0/library&quot; .libPaths() R 包存放的路径有哪些 .libPaths() #&gt; [1] &quot;D:/library&quot; &quot;C:/Program Files/R/R-3.6.0/library&quot; find.package 查找R包所在目录 find.package(package = &#39;MASS&#39;) #&gt; [1] &quot;D:/library/MASS&quot; file.exist 检查文件是否存在 file.exists(paste(R.home(&#39;etc&#39;),&quot;Rprofile.site&quot;,sep = .Platform$file.sep)) #&gt; [1] TRUE apropos 和 find 查找对象 apropos(what, where = FALSE, ignore.case = TRUE, mode = &quot;any&quot;) find(what, mode = &quot;any&quot;, numeric = FALSE, simple.words = TRUE) 匹配含有 find 的函数 apropos(&quot;find&quot;) #&gt; [1] &quot;.find.package&quot; &quot;find&quot; #&gt; [3] &quot;Find&quot; &quot;find.package&quot; #&gt; [5] &quot;find_external_resources&quot; &quot;findClass&quot; #&gt; [7] &quot;findFunction&quot; &quot;findInterval&quot; #&gt; [9] &quot;findLineNum&quot; &quot;findMethod&quot; #&gt; [11] &quot;findMethods&quot; &quot;findMethodSignatures&quot; #&gt; [13] &quot;findPackageEnv&quot; &quot;findRestart&quot; #&gt; [15] &quot;findUnique&quot; 问号 ? 加函数名搜索R软件内置函数的帮助文档，如 ?regrex。如果不知道具体的函数名，可采用关键词搜索，如 help.search(keyword = &quot;character&quot;, package = &quot;base&quot;) browseEnv 函数用来在浏览器中查看当前环境下，对象的列表，默认环境是 sys.frame() 3.6 文件权限 操作目录和文件的权限 Manipulation of Directories and File Permissions dir.exists(paths) 检查目录是否存在 dir.exists(c(&#39;./_book&#39;,&#39;./book&#39;)) #&gt; [1] TRUE FALSE dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = \"0777\") 创建目录 dir.create(&#39;./_book/tmp&#39;) Sys.chmod(paths, mode = \"0777\", use_umask = TRUE) 修改权限 Sys.chmod(&#39;./_book/tmp&#39;) Sys.umask(mode = NA) 3.7 区域设置 Sys.getlocale(category = \"LC_ALL\") 查看当前区域设置 Sys.getlocale(category = &quot;LC_ALL&quot;) #&gt; [1] &quot;LC_COLLATE=Chinese (Simplified)_China.936;LC_CTYPE=Chinese (Simplified)_China.936;LC_MONETARY=Chinese (Simplified)_China.936;LC_NUMERIC=C;LC_TIME=Chinese (Simplified)_China.936&quot; Sys.setlocale(category = \"LC_ALL\", locale = \"\") 设置区域 # 默认设置 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;&quot;) #&gt; [1] &quot;LC_COLLATE=Chinese (Simplified)_China.936;LC_CTYPE=Chinese (Simplified)_China.936;LC_MONETARY=Chinese (Simplified)_China.936;LC_NUMERIC=C;LC_TIME=Chinese (Simplified)_China.936&quot; # 保存当前区域设置 old &lt;- Sys.getlocale() Sys.setlocale(&quot;LC_MONETARY&quot;, locale = &quot;&quot;) #&gt; [1] &quot;Chinese (Simplified)_China.936&quot; Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;CNY&quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;￥&quot; &quot;.&quot; &quot;,&quot; &quot;\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;4&quot; &quot;4&quot; Sys.setlocale(&quot;LC_MONETARY&quot;, &quot;de_AT&quot;) #&gt; Warning in Sys.setlocale(&quot;LC_MONETARY&quot;, &quot;de_AT&quot;): OS reports request to set #&gt; locale to &quot;de_AT&quot; cannot be honored #&gt; [1] &quot;&quot; Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;CNY&quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;￥&quot; &quot;.&quot; &quot;,&quot; &quot;\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;4&quot; &quot;4&quot; # 恢复区域设置 Sys.setlocale(locale = old) #&gt; Warning in Sys.setlocale(locale = old): OS reports request to set locale to #&gt; &quot;LC_COLLATE=Chinese (Simplified)_China.936;LC_CTYPE=Chinese (Simplified)_China. #&gt; 936;LC_MONETARY=Chinese (Simplified)_China.936;LC_NUMERIC=C;LC_TIME=Chinese #&gt; (Simplified)_China.936&quot; cannot be honored #&gt; [1] &quot;&quot; Sys.localeconv() 当前区域设置下，数字和货币的表示 Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;CNY&quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;￥&quot; &quot;.&quot; &quot;,&quot; &quot;\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;4&quot; &quot;4&quot; 本地化信息 l10n_info() #&gt; $MBCS #&gt; [1] TRUE #&gt; #&gt; $`UTF-8` #&gt; [1] FALSE #&gt; #&gt; $`Latin-1` #&gt; [1] FALSE #&gt; #&gt; $codepage #&gt; [1] 936 3.8 进程管理 ps 包用来查询进程信息 Sys.getpid 获取当前运行中的 R 控制台（会话）的进程 ID Sys.getpid() #&gt; [1] 8088 proc.time() R 会话运行时间，常用于计算R程序在当前R控制台的运行时间 t1 &lt;- proc.time() tmp &lt;- rnorm(1e6) proc.time() - t1 #&gt; user system elapsed #&gt; 0.08 0.01 0.10 system.time 计算 R 表达式/程序块运行耗费的CPU时间 system.time({ rnorm(1e6) }, gcFirst = TRUE) #&gt; user system elapsed #&gt; 0.08 0.00 0.08 gc.time 报告垃圾回收耗费的时间 gc.time() #&gt; [1] 0 0 0 0 0 3.9 系统命令 system 和 system2 调用系统命令，推荐使用后者，它更灵活更便携。此外，Jeroen Ooms 开发的 sys 包 可看作 base::system2 的替代品 system &lt;- function(...) cat(base::system(..., intern = TRUE), sep = &#39;\\n&#39;) system2 &lt;- function(...) cat(base::system2(..., stdout = TRUE), sep = &quot;\\n&quot;) system(command = &quot;xelatex --version&quot;) #&gt; XeTeX 3.14159265-2.6-0.999991 (TeX Live 2019/W32TeX) #&gt; kpathsea version 6.3.1 #&gt; Copyright 2019 SIL International, Jonathan Kew and Khaled Hosny. #&gt; There is NO warranty. Redistribution of this software is #&gt; covered by the terms of both the XeTeX copyright and #&gt; the Lesser GNU General Public License. #&gt; For more information about these matters, see the file #&gt; named COPYING and the XeTeX source. #&gt; Primary author of XeTeX: Jonathan Kew. #&gt; Compiled with ICU version 63.1; using 63.1 #&gt; Compiled with zlib version 1.2.11; using 1.2.11 #&gt; Compiled with FreeType2 version 2.9.1; using 2.9.1 #&gt; Compiled with Graphite2 version 1.3.13; using 1.3.13 #&gt; Compiled with HarfBuzz version 2.3.1; using 2.3.1 #&gt; Compiled with libpng version 1.6.36; using 1.6.36 #&gt; Compiled with poppler version 0.68.0 #&gt; Compiled with fontconfig version 2.13.1; using 2.13.1 system2(command = &#39;pdflatex&#39;, args = &#39;--version&#39;) #&gt; pdfTeX 3.14159265-2.6-1.40.20 (TeX Live 2019/W32TeX) #&gt; kpathsea version 6.3.1 #&gt; Copyright 2019 Han The Thanh (pdfTeX) et al. #&gt; There is NO warranty. Redistribution of this software is #&gt; covered by the terms of both the pdfTeX copyright and #&gt; the Lesser GNU General Public License. #&gt; For more information about these matters, see the file #&gt; named COPYING and the pdfTeX source. #&gt; Primary author of pdfTeX: Han The Thanh (pdfTeX) et al. #&gt; Compiled with libpng 1.6.36; using libpng 1.6.36 #&gt; Compiled with zlib 1.2.11; using zlib 1.2.11 #&gt; Compiled with xpdf version 4.01 3.10 时间管理 Sys.timezone 获取时区信息 Sys.timezone(location = TRUE) #&gt; [1] &quot;Asia/Taipei&quot; Sys.time 系统时间，可以给定时区下，显示当前时间，精确到秒，返回数据类型为 POSIXct # 此时美国洛杉矶时间 format(Sys.time(), tz = &#39;America/Los_Angeles&#39;, usetz = TRUE) #&gt; [1] &quot;2019-05-26 09:47:57 PDT&quot; # 此时加拿大东部时间 format(Sys.time(), tz = &#39;Canada/Eastern&#39;, usetz = TRUE) #&gt; [1] &quot;2019-05-26 12:47:57 EDT&quot; Sys.Date 显示当前时区下的日期，精确到日，返回数据类型为 date Sys.Date() #&gt; [1] &quot;2019-05-27&quot; date 返回当前系统日期和时间，数据类型是字符串 date() #&gt; [1] &quot;Mon May 27 00:47:57 2019&quot; ## 也可以这样表示 format(Sys.time(), &quot;%a %b %d %H:%M:%S %Y&quot;) #&gt; [1] &quot;周一 5月 27 00:47:57 2019&quot; as.POSIX* 是一个 Date-time 转换函数 as.POSIXlt(Sys.time(), &quot;GMT&quot;) # the current time in GMT #&gt; [1] &quot;2019-05-26 16:47:57 GMT&quot; 时间计算 (z &lt;- Sys.time()) # the current date, as class &quot;POSIXct&quot; #&gt; [1] &quot;2019-05-27 00:48:01 CST&quot; Sys.time() - 3600 # an hour ago #&gt; [1] &quot;2019-05-26 23:48:01 CST&quot; .leap.seconds 是内置的日期序列 .leap.seconds #&gt; [1] &quot;1972-07-01 08:00:00 CST&quot; &quot;1973-01-01 08:00:00 CST&quot; #&gt; [3] &quot;1974-01-01 08:00:00 CST&quot; &quot;1975-01-01 08:00:00 CST&quot; #&gt; [5] &quot;1976-01-01 08:00:00 CST&quot; &quot;1977-01-01 08:00:00 CST&quot; #&gt; [7] &quot;1978-01-01 08:00:00 CST&quot; &quot;1979-01-01 08:00:00 CST&quot; #&gt; [9] &quot;1980-01-01 08:00:00 CST&quot; &quot;1981-07-01 08:00:00 CST&quot; #&gt; [11] &quot;1982-07-01 08:00:00 CST&quot; &quot;1983-07-01 08:00:00 CST&quot; #&gt; [13] &quot;1985-07-01 08:00:00 CST&quot; &quot;1988-01-01 08:00:00 CST&quot; #&gt; [15] &quot;1990-01-01 08:00:00 CST&quot; &quot;1991-01-01 08:00:00 CST&quot; #&gt; [17] &quot;1992-07-01 08:00:00 CST&quot; &quot;1993-07-01 08:00:00 CST&quot; #&gt; [19] &quot;1994-07-01 08:00:00 CST&quot; &quot;1996-01-01 08:00:00 CST&quot; #&gt; [21] &quot;1997-07-01 08:00:00 CST&quot; &quot;1999-01-01 08:00:00 CST&quot; #&gt; [23] &quot;2006-01-01 08:00:00 CST&quot; &quot;2009-01-01 08:00:00 CST&quot; #&gt; [25] &quot;2012-07-01 08:00:00 CST&quot; &quot;2015-07-01 08:00:00 CST&quot; #&gt; [27] &quot;2017-01-01 08:00:00 CST&quot; 计算日期对应的星期weekdays，月 months 和季度 quarters weekdays(.leap.seconds) #&gt; [1] &quot;星期六&quot; &quot;星期一&quot; &quot;星期二&quot; &quot;星期三&quot; &quot;星期四&quot; &quot;星期六&quot; &quot;星期日&quot; &quot;星期一&quot; #&gt; [9] &quot;星期二&quot; &quot;星期三&quot; &quot;星期四&quot; &quot;星期五&quot; &quot;星期一&quot; &quot;星期五&quot; &quot;星期一&quot; &quot;星期二&quot; #&gt; [17] &quot;星期三&quot; &quot;星期四&quot; &quot;星期五&quot; &quot;星期一&quot; &quot;星期二&quot; &quot;星期五&quot; &quot;星期日&quot; &quot;星期四&quot; #&gt; [25] &quot;星期日&quot; &quot;星期三&quot; &quot;星期日&quot; months(.leap.seconds) #&gt; [1] &quot;七月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;七月&quot; #&gt; [11] &quot;七月&quot; &quot;七月&quot; &quot;七月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;七月&quot; &quot;七月&quot; &quot;七月&quot; &quot;一月&quot; #&gt; [21] &quot;七月&quot; &quot;一月&quot; &quot;一月&quot; &quot;一月&quot; &quot;七月&quot; &quot;七月&quot; &quot;一月&quot; quarters(.leap.seconds) #&gt; [1] &quot;Q3&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q1&quot; &quot;Q1&quot; #&gt; [16] &quot;Q1&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q1&quot; &quot;Q3&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q1&quot; Sys.setFileTime() 使用系统调用 system call 设置文件或目录的时间 # 修改时间前 file.info(&#39;./_common.R&#39;) #&gt; size isdir mode mtime ctime #&gt; ./_common.R 2978 FALSE 666 2019-05-27 00:39:45 2019-01-18 17:00:40 #&gt; atime exe #&gt; ./_common.R 2019-05-27 00:33:35 no # 修改时间后，对比一下 Sys.setFileTime(path = &#39;./_common.R&#39;, time = Sys.time()) file.info(&#39;./_common.R&#39;) #&gt; size isdir mode mtime ctime #&gt; ./_common.R 2978 FALSE 666 2019-05-27 00:48:05 2019-01-18 17:00:40 #&gt; atime exe #&gt; ./_common.R 2019-05-27 00:33:35 no strptime 用于字符串与 POSIXlt、 POSIXct 类对象之间的转化，format 默认 tz = \"\" 且 usetz = TRUE # 存放时区信息的数据库所在目录 list.files(file.path(R.home(&quot;share&quot;), &quot;zoneinfo&quot;)) #&gt; [1] &quot;Africa&quot; &quot;America&quot; &quot;Antarctica&quot; &quot;Arctic&quot; &quot;Asia&quot; #&gt; [6] &quot;Atlantic&quot; &quot;Australia&quot; &quot;Brazil&quot; &quot;Canada&quot; &quot;CET&quot; #&gt; [11] &quot;Chile&quot; &quot;CST6CDT&quot; &quot;Cuba&quot; &quot;EET&quot; &quot;Egypt&quot; #&gt; [16] &quot;Eire&quot; &quot;EST&quot; &quot;EST5EDT&quot; &quot;Etc&quot; &quot;Europe&quot; #&gt; [21] &quot;GB&quot; &quot;GB-Eire&quot; &quot;GMT&quot; &quot;GMT-0&quot; &quot;GMT+0&quot; #&gt; [26] &quot;GMT0&quot; &quot;Greenwich&quot; &quot;Hongkong&quot; &quot;HST&quot; &quot;Iceland&quot; #&gt; [31] &quot;Indian&quot; &quot;Iran&quot; &quot;iso3166.tab&quot; &quot;Israel&quot; &quot;Jamaica&quot; #&gt; [36] &quot;Japan&quot; &quot;Kwajalein&quot; &quot;Libya&quot; &quot;MET&quot; &quot;Mexico&quot; #&gt; [41] &quot;MST&quot; &quot;MST7MDT&quot; &quot;Navajo&quot; &quot;NZ&quot; &quot;NZ-CHAT&quot; #&gt; [46] &quot;Pacific&quot; &quot;Poland&quot; &quot;Portugal&quot; &quot;PRC&quot; &quot;PST8PDT&quot; #&gt; [51] &quot;ROC&quot; &quot;ROK&quot; &quot;Singapore&quot; &quot;Turkey&quot; &quot;UCT&quot; #&gt; [56] &quot;Universal&quot; &quot;US&quot; &quot;UTC&quot; &quot;VERSION&quot; &quot;W-SU&quot; #&gt; [61] &quot;WET&quot; &quot;zone.tab&quot; &quot;Zulu&quot; # 比较不同的打印方式 strptime(Sys.time(), format =&quot;%Y-%m-%d %H:%M:%S&quot;, tz = &quot;Asia/Taipei&quot;) #&gt; [1] &quot;2019-05-27 00:48:05 CST&quot; format(Sys.time(), format = &quot;%Y-%m-%d %H:%M:%S&quot;) # 默认情形 #&gt; [1] &quot;2019-05-27 00:48:05&quot; format(Sys.time(), format = &quot;%Y-%m-%d %H:%M:%S&quot;, tz = &quot;Asia/Taipei&quot;, usetz = TRUE) #&gt; [1] &quot;2019-05-27 00:48:05 CST&quot; 设置时区 Sys.timezone() #&gt; [1] &quot;Asia/Taipei&quot; Sys.setenv(TZ = &quot;Asia/Shanghai&quot;) Sys.timezone() #&gt; [1] &quot;Asia/Shanghai&quot; 全局修改，在文件 C:/PROGRA1/R/R-361.0/etc/Rprofile.site 内添加Sys.setenv(TZ=\"Asia/Shanghai\")。 局部修改，就是在本地R项目下，创建 .Rprofile，然后同样添加 Sys.setenv(TZ=\"Asia/Shanghai\")。 3.11 R 包管理 apropos(&#39;package&#39;) #&gt; [1] &quot;$.package_version&quot; &quot;.find.package&quot; #&gt; [3] &quot;.packages&quot; &quot;.packageStartupMessage&quot; #&gt; [5] &quot;.path.package&quot; &quot;as.package_version&quot; #&gt; [7] &quot;aspell_package_C_files&quot; &quot;aspell_package_R_files&quot; #&gt; [9] &quot;aspell_package_Rd_files&quot; &quot;aspell_package_vignettes&quot; #&gt; [11] &quot;available.packages&quot; &quot;CRAN.packages&quot; #&gt; [13] &quot;download.packages&quot; &quot;find.package&quot; #&gt; [15] &quot;findPackageEnv&quot; &quot;format.packageInfo&quot; #&gt; [17] &quot;getClassPackage&quot; &quot;getPackageName&quot; #&gt; [19] &quot;install.packages&quot; &quot;installed.packages&quot; #&gt; [21] &quot;is.package_version&quot; &quot;make.packages.html&quot; #&gt; [23] &quot;methodsPackageMetaName&quot; &quot;new.packages&quot; #&gt; [25] &quot;old.packages&quot; &quot;package.skeleton&quot; #&gt; [27] &quot;package_version&quot; &quot;packageDate&quot; #&gt; [29] &quot;packageDescription&quot; &quot;packageEvent&quot; #&gt; [31] &quot;packageHasNamespace&quot; &quot;packageName&quot; #&gt; [33] &quot;packageNotFoundError&quot; &quot;packageSlot&quot; #&gt; [35] &quot;packageSlot&lt;-&quot; &quot;packageStartupMessage&quot; #&gt; [37] &quot;packageStatus&quot; &quot;packageVersion&quot; #&gt; [39] &quot;path.package&quot; &quot;path_package&quot; #&gt; [41] &quot;print.packageInfo&quot; &quot;promptPackage&quot; #&gt; [43] &quot;remove.packages&quot; &quot;setPackageName&quot; #&gt; [45] &quot;suppressPackageStartupMessages&quot; &quot;update.packages&quot; .packages(T) 已安装的 R 包 .packages(T) %&gt;% length() #&gt; [1] 308 available.packages 查询可用的 R 包 available.packages()[,&quot;Package&quot;] %&gt;% head() #&gt; A3 abbyyR abc abc.data ABC.RAP #&gt; &quot;A3&quot; &quot;abbyyR&quot; &quot;abc&quot; &quot;abc.data&quot; &quot;ABC.RAP&quot; #&gt; ABCanalysis #&gt; &quot;ABCanalysis&quot; 查询 repos 的 R 包 rforge &lt;- available.packages(repos = &quot;https://r-forge.r-project.org/&quot;) cran &lt;- available.packages(repos = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;) setdiff(rforge[, &quot;Package&quot;], cran[, &quot;Package&quot;]) download.packages 下载 R 包 download.packages(&quot;Rbooks&quot;, destdir = &quot;~/&quot;, repos = &quot;https://r-forge.r-project.org/&quot;) install.packages 安装 R 包 install.packages(&quot;rmarkdown&quot;) installed.packages 已安装的 R 包 installed.packages(fields = c(&quot;Package&quot;,&quot;Version&quot;)) %&gt;% head() remove.packages 卸载/删除/移除已安装的R包 remove.packages(&#39;rmarkdown&#39;) update.packages 更新已安装的 R 包 update.packages(ask = FALSE) old.packages 查看过时/可更新的 R 包 old.packages() %&gt;% head() #&gt; Package LibPath Installed Built ReposVer #&gt; abind &quot;abind&quot; &quot;D:/library&quot; &quot;1.4-5&quot; &quot;3.6.0&quot; &quot;1.4-7&quot; #&gt; bit64 &quot;bit64&quot; &quot;D:/library&quot; &quot;0.9-7&quot; &quot;3.6.0&quot; &quot;0.9-8&quot; #&gt; dichromat &quot;dichromat&quot; &quot;D:/library&quot; &quot;2.0-0&quot; &quot;3.6.0&quot; &quot;2.0-1&quot; #&gt; foreach &quot;foreach&quot; &quot;D:/library&quot; &quot;1.4.4&quot; &quot;3.6.0&quot; &quot;1.5.1&quot; #&gt; iterators &quot;iterators&quot; &quot;D:/library&quot; &quot;1.0.10&quot; &quot;3.6.0&quot; &quot;1.0.11&quot; #&gt; maxLik &quot;maxLik&quot; &quot;D:/library&quot; &quot;1.3-6&quot; &quot;3.6.0&quot; &quot;1.3-7&quot; #&gt; Repository #&gt; abind &quot;https://r-forge.r-project.org/src/contrib&quot; #&gt; bit64 &quot;https://r-forge.r-project.org/src/contrib&quot; #&gt; dichromat &quot;https://r-forge.r-project.org/src/contrib&quot; #&gt; foreach &quot;https://r-forge.r-project.org/src/contrib&quot; #&gt; iterators &quot;https://r-forge.r-project.org/src/contrib&quot; #&gt; maxLik &quot;https://r-forge.r-project.org/src/contrib&quot; new.packages 还没有安装的 R 包 new.packages() %&gt;% head() #&gt; [1] &quot;A2&quot; &quot;A3&quot; &quot;a4Core&quot; &quot;a4Reporting&quot; &quot;abbyyR&quot; #&gt; [6] &quot;abc&quot; packageStatus 查看已安装的 R 包状态，可更新、可下载等 packageStatus() #&gt; Number of installed packages: #&gt; #&gt; ok upgrade unavailable #&gt; D:/library 290 11 7 #&gt; C:/Program Files/R/R-3.6.0/library 27 2 0 #&gt; #&gt; Number of available packages (each package counted only once): #&gt; #&gt; installed #&gt; https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/contrib 274 #&gt; https://r-forge.r-project.org/src/contrib 12 #&gt; https://inla.r-inla-download.org/R/stable/src/contrib 0 #&gt; https://nowosad.github.io/drat/src/contrib 1 #&gt; #&gt; not installed #&gt; https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/contrib 13800 #&gt; https://r-forge.r-project.org/src/contrib 1248 #&gt; https://inla.r-inla-download.org/R/stable/src/contrib 1 #&gt; https://nowosad.github.io/drat/src/contrib 0 packageDescription 查询 R 包描述信息 packageDescription(&#39;rmarkdown&#39;) #&gt; Package: rmarkdown #&gt; Type: Package #&gt; Title: Dynamic Documents for R #&gt; Version: 1.13 #&gt; Authors@R: c( person(&quot;JJ&quot;, &quot;Allaire&quot;, role = &quot;aut&quot;, email = #&gt; &quot;jj@rstudio.com&quot;), person(&quot;Yihui&quot;, &quot;Xie&quot;, role = c(&quot;aut&quot;, .... 查询 R 包的依赖关系 # rmarkdown 依赖的 R 包 tools::package_dependencies(&#39;rmarkdown&#39;, recursive = TRUE) #&gt; $rmarkdown #&gt; [1] &quot;tools&quot; &quot;utils&quot; &quot;knitr&quot; &quot;yaml&quot; &quot;htmltools&quot; &quot;evaluate&quot; #&gt; [7] &quot;base64enc&quot; &quot;jsonlite&quot; &quot;mime&quot; &quot;tinytex&quot; &quot;xfun&quot; &quot;methods&quot; #&gt; [13] &quot;stringr&quot; &quot;digest&quot; &quot;Rcpp&quot; &quot;highr&quot; &quot;markdown&quot; &quot;glue&quot; #&gt; [19] &quot;magrittr&quot; &quot;stringi&quot; &quot;stats&quot; # 依赖 rmarkdown 的 R 包 tools::dependsOnPkgs(&#39;rmarkdown&#39;, recursive = TRUE) #&gt; [1] &quot;blogdown&quot; &quot;bookdown&quot; &quot;pagedown&quot; &quot;reprex&quot; &quot;rticles&quot; &quot;tufte&quot; #&gt; [7] &quot;xaringan&quot; &quot;tidyverse&quot; ggplot2 生态，仅列出以 gg 开头的 R 包 pdb &lt;- available.packages() gg &lt;- tools::dependsOnPkgs(&quot;ggplot2&quot;, recursive = FALSE, installed = pdb) grep(&quot;^gg&quot;, gg, value = TRUE) #&gt; [1] &quot;ggallin&quot; &quot;ggalluvial&quot; &quot;ggalt&quot; &quot;gganimate&quot; #&gt; [5] &quot;ggasym&quot; &quot;ggbeeswarm&quot; &quot;ggbuildr&quot; &quot;ggChernoff&quot; #&gt; [9] &quot;ggconf&quot; &quot;ggcorrplot&quot; &quot;ggdag&quot; &quot;ggdark&quot; #&gt; [13] &quot;ggdemetra&quot; &quot;ggdendro&quot; &quot;ggdistribute&quot; &quot;ggdmc&quot; #&gt; [17] &quot;ggedit&quot; &quot;ggenealogy&quot; &quot;ggetho&quot; &quot;ggExtra&quot; #&gt; [21] &quot;ggfan&quot; &quot;ggfittext&quot; &quot;ggfocus&quot; &quot;ggforce&quot; #&gt; [25] &quot;ggformula&quot; &quot;ggfortify&quot; &quot;gggenes&quot; &quot;ggghost&quot; #&gt; [29] &quot;ggguitar&quot; &quot;gghalfnorm&quot; &quot;gghighlight&quot; &quot;ggimage&quot; #&gt; [33] &quot;gginference&quot; &quot;gginnards&quot; &quot;ggiraph&quot; &quot;ggiraphExtra&quot; #&gt; [37] &quot;ggjoy&quot; &quot;gglogo&quot; &quot;ggloop&quot; &quot;gglorenz&quot; #&gt; [41] &quot;ggmap&quot; &quot;ggmcmc&quot; &quot;ggmosaic&quot; &quot;ggmuller&quot; #&gt; [45] &quot;ggnetwork&quot; &quot;ggnewscale&quot; &quot;ggnormalviolin&quot; &quot;ggpage&quot; #&gt; [49] &quot;ggparallel&quot; &quot;ggparliament&quot; &quot;ggperiodic&quot; &quot;ggplotAssist&quot; #&gt; [53] &quot;ggplotgui&quot; &quot;ggplotify&quot; &quot;ggpmisc&quot; &quot;ggPMX&quot; #&gt; [57] &quot;ggpol&quot; &quot;ggpolypath&quot; &quot;ggpubr&quot; &quot;ggpval&quot; #&gt; [61] &quot;ggQC&quot; &quot;ggQQunif&quot; &quot;ggquickeda&quot; &quot;ggquiver&quot; #&gt; [65] &quot;ggRandomForests&quot; &quot;ggraph&quot; &quot;ggraptR&quot; &quot;ggrasp&quot; #&gt; [69] &quot;ggrepel&quot; &quot;ggridges&quot; &quot;ggROC&quot; &quot;ggsci&quot; #&gt; [73] &quot;ggseas&quot; &quot;ggseqlogo&quot; &quot;ggsignif&quot; &quot;ggsn&quot; #&gt; [77] &quot;ggsoccer&quot; &quot;ggsolvencyii&quot; &quot;ggsom&quot; &quot;ggspatial&quot; #&gt; [81] &quot;ggspectra&quot; &quot;ggstance&quot; &quot;ggstatsplot&quot; &quot;ggswissmaps&quot; #&gt; [85] &quot;ggtern&quot; &quot;ggThemeAssist&quot; &quot;ggthemes&quot; &quot;ggTimeSeries&quot; #&gt; [89] &quot;ggupset&quot; &quot;ggvoronoi&quot; &quot;ggwordcloud&quot; &quot;ggplotFL&quot; 重装R包，与 R 版本号保持一致 db &lt;- installed.packages() db &lt;- as.data.frame(db, stringsAsFactors = FALSE) pkgs &lt;- db[db$Built &lt; getRversion(), &quot;Package&quot;] install.packages(pkgs) 3.12 查找函数 lookup R 函数完整定义，包括编译的代码，S3 和 S4 方法。目前 lookup 包处于开发版，我们可以用 remotes::install_github 函数来安装它 # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;jimhester/lookup&quot;) R-level 的源代码都可以直接看 body #&gt; function (fun = sys.function(sys.parent())) #&gt; { #&gt; if (is.character(fun)) #&gt; fun &lt;- get(fun, mode = &quot;function&quot;, envir = parent.frame()) #&gt; .Internal(body(fun)) #&gt; } #&gt; &lt;bytecode: 0x00000000092e8dd0&gt; #&gt; &lt;environment: namespace:base&gt; 此外，lookup 可以定位到 C-level 的源代码，需要联网才能查看，lookup 基于 Winston Chang 在 Github 上维护的 R 源码镜像 lookup(body) base::body [closure] function (fun = sys.function(sys.parent())) { if (is.character(fun)) fun &lt;- get(fun, mode = &quot;function&quot;, envir = parent.frame()) .Internal(body(fun)) } &lt;bytecode: 0x00000000140d6158&gt; &lt;environment: namespace:base&gt; // c source: src/main/builtin.c#L264-L277 SEXP attribute_hidden do_body(SEXP call, SEXP op, SEXP args, SEXP rho) { checkArity(op, args); if (TYPEOF(CAR(args)) == CLOSXP) { SEXP b = BODY_EXPR(CAR(args)); RAISE_NAMED(b, NAMED(CAR(args))); return b; } else { if(!(TYPEOF(CAR(args)) == BUILTINSXP || TYPEOF(CAR(args)) == SPECIALSXP)) warningcall(call, _(&quot;argument is not a function&quot;)); return R_NilValue; } } https://github.com/libarchive/libarchive/wiki/FormatTar↩ 继 Rtools35 之后， RTools40 主要为 R 3.6.0 准备的，包含有 GCC 8 及其它编译R包需要的工具包，详情请看的幻灯片↩ https://github.com/rwinlib/utils↩ "],
["05-data-object.html", "第 4 章 对象在哪里 4.1 向量 4.2 矩阵 4.3 数组 4.4 数据框 4.5 表格 4.6 列表 4.7 时间序列 4.8 空间数据", " 第 4 章 对象在哪里 可用于绘图的数据对象，向量 vector 等，只涉及基础操作和绘图，关键在入门引导式的介绍，点到即止 数据类型：字符、数值：字符数据操作：按数据类型介绍各类数据操作，重复之处如前所述，数据处理的分类：按数据类型来，一共是 table matrix data.frame 和 vector 4.1 向量 数值型、字符型、因子型 4.2 矩阵 4.3 数组 4.4 数据框 4.5 表格 4.6 列表 4.7 时间序列 Jeffrey A. Ryan 开发的 xts 和 quantmod 包，Joshua M. Ulrich 开发的 zoo 是处理时间序列数据的主要工具 Jeffrey A. Ryan 在开设了一门免费课程教大家如何在 R 语言中使用 xts 和 zoo 包操作时间序列数据6 xts (eXtensible Time Series) 扩展的 zoo 对象 xts(x = NULL, order.by = index(x), frequency = NULL, unique = TRUE, tzone = Sys.getenv(&quot;TZ&quot;), ...) library(zoo) library(xts) #&gt; Registered S3 method overwritten by &#39;xts&#39;: #&gt; method from #&gt; as.zoo.xts zoo x = matrix(1:4, ncol = 2,nrow = 2) idx &lt;- as.Date(c(&quot;2018-01-01&quot;, &quot;2019-12-12&quot;)) # xts = matrix + index xts(x, order.by = idx) #&gt; [,1] [,2] #&gt; 2018-01-01 1 3 #&gt; 2019-12-12 2 4 Date，POSIX times，timeDate，chron 等各种各样处理日期数据的对象 4.8 空间数据 sp sf raster 等对象 https://www.datacamp.com/courses/manipulating-time-series-data-in-r-with-xts-zoo↩ "],
["06-data-import-export.html", "第 5 章 数据搬运工 5.1 导入数据文件 5.2 保存输出结果 5.3 保存数据对象 5.4 其它数据格式 5.5 批量导入数据 5.6 批量导出数据 5.7 导入大数据集 5.8 从数据库导入", " 第 5 章 数据搬运工 导入数据与导出数据，各种数据格式，数据库 5.1 导入数据文件 Base R 针对不同的数据格式文件，提供了大量的数据导入和导出函数，不愧是专注数据分析20余年的优秀统计软件。 除了函数 write.ftable 和 read.ftable 来自 stats 包，都来自 base 和 utils 包 # 当前环境的搜索路径 searchpaths() #&gt; [1] &quot;.GlobalEnv&quot; #&gt; [2] &quot;D:/library/RClickhouse&quot; #&gt; [3] &quot;D:/library/DBI&quot; #&gt; [4] &quot;D:/library/openxlsx&quot; #&gt; [5] &quot;D:/library/forcats&quot; #&gt; [6] &quot;D:/library/stringr&quot; #&gt; [7] &quot;D:/library/dplyr&quot; #&gt; [8] &quot;D:/library/purrr&quot; #&gt; [9] &quot;D:/library/readr&quot; #&gt; [10] &quot;D:/library/tidyr&quot; #&gt; [11] &quot;D:/library/tibble&quot; #&gt; [12] &quot;D:/library/ggplot2&quot; #&gt; [13] &quot;D:/library/tidyverse&quot; #&gt; [14] &quot;D:/library/yaml&quot; #&gt; [15] &quot;C:/Program Files/R/R-3.6.0/library/stats&quot; #&gt; [16] &quot;C:/Program Files/R/R-3.6.0/library/graphics&quot; #&gt; [17] &quot;C:/Program Files/R/R-3.6.0/library/grDevices&quot; #&gt; [18] &quot;C:/Program Files/R/R-3.6.0/library/utils&quot; #&gt; [19] &quot;C:/Program Files/R/R-3.6.0/library/datasets&quot; #&gt; [20] &quot;C:/Program Files/R/R-3.6.0/library/methods&quot; #&gt; [21] &quot;Autoloads&quot; #&gt; [22] &quot;C:/PROGRA~1/R/R-36~1.0/library/base&quot; # 返回匹配结果及其所在路径的编号 apropos(&quot;^(read|write)&quot;, where = TRUE, mode = &quot;function&quot;) #&gt; 18 18 22 #&gt; &quot;read.csv&quot; &quot;read.csv2&quot; &quot;read.dcf&quot; #&gt; 18 18 18 #&gt; &quot;read.delim&quot; &quot;read.delim2&quot; &quot;read.DIF&quot; #&gt; 18 15 18 #&gt; &quot;read.fortran&quot; &quot;read.ftable&quot; &quot;read.fwf&quot; #&gt; 18 18 4 #&gt; &quot;read.socket&quot; &quot;read.table&quot; &quot;read.xlsx&quot; #&gt; 9 9 9 #&gt; &quot;read_csv&quot; &quot;read_csv_chunked&quot; &quot;read_csv2&quot; #&gt; 9 9 9 #&gt; &quot;read_csv2_chunked&quot; &quot;read_delim&quot; &quot;read_delim_chunked&quot; #&gt; 9 9 9 #&gt; &quot;read_file&quot; &quot;read_file_raw&quot; &quot;read_fwf&quot; #&gt; 9 9 9 #&gt; &quot;read_lines&quot; &quot;read_lines_chunked&quot; &quot;read_lines_raw&quot; #&gt; 9 9 9 #&gt; &quot;read_lines_raw_chunked&quot; &quot;read_log&quot; &quot;read_rds&quot; #&gt; 9 9 9 #&gt; &quot;read_table&quot; &quot;read_table2&quot; &quot;read_tsv&quot; #&gt; 9 14 22 #&gt; &quot;read_tsv_chunked&quot; &quot;read_yaml&quot; &quot;readBin&quot; #&gt; 22 18 18 #&gt; &quot;readChar&quot; &quot;readCitationFile&quot; &quot;readClipboard&quot; #&gt; 22 22 9 #&gt; &quot;readline&quot; &quot;readLines&quot; &quot;readr_example&quot; #&gt; 22 18 22 #&gt; &quot;readRDS&quot; &quot;readRegistry&quot; &quot;readRenviron&quot; #&gt; 4 22 18 #&gt; &quot;readWorkbook&quot; &quot;write&quot; &quot;write.csv&quot; #&gt; 18 22 15 #&gt; &quot;write.csv2&quot; &quot;write.dcf&quot; &quot;write.ftable&quot; #&gt; 18 18 4 #&gt; &quot;write.socket&quot; &quot;write.table&quot; &quot;write.xlsx&quot; #&gt; 9 9 9 #&gt; &quot;write_csv&quot; &quot;write_csv2&quot; &quot;write_delim&quot; #&gt; 9 9 9 #&gt; &quot;write_excel_csv&quot; &quot;write_excel_csv2&quot; &quot;write_file&quot; #&gt; 9 9 9 #&gt; &quot;write_lines&quot; &quot;write_rds&quot; &quot;write_tsv&quot; #&gt; 14 22 22 #&gt; &quot;write_yaml&quot; &quot;writeBin&quot; &quot;writeChar&quot; #&gt; 18 4 4 #&gt; &quot;writeClipboard&quot; &quot;writeComment&quot; &quot;writeData&quot; #&gt; 4 4 22 #&gt; &quot;writeDataTable&quot; &quot;writeFormula&quot; &quot;writeLines&quot; 5.1.1 scan scan(file = &quot;&quot;, what = double(), nmax = -1, n = -1, sep = &quot;&quot;, quote = if(identical(sep, &quot;\\n&quot;)) &quot;&quot; else &quot;&#39;\\&quot;&quot;, dec = &quot;.&quot;, skip = 0, nlines = 0, na.strings = &quot;NA&quot;, flush = FALSE, fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, multi.line = TRUE, comment.char = &quot;&quot;, allowEscapes = FALSE, fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) 首先让我们用 cat 函数创建一个练习数据集 ex.data cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;) #&gt; TITLE extra line 2 3 5 7 11 13 17 cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;, file = &quot;data/ex.data&quot;, sep = &quot;\\n&quot;) 以此练习数据集，介绍 scan 函数最常用的参数 scan(&quot;data/ex.data&quot;) #&gt; Error in scan(&quot;data/ex.data&quot;): scan() expected &#39;a real&#39;, got &#39;TITLE&#39; 从上面的报错信息，我们发现 scan 函数只能读取同一类型的数据，如布尔型 logical， 整型 integer，数值型 numeric(double)， 复数型 complex，字符型 character，raw 和列表 list。所以我们设置参数 skip = 1 把第一行跳过，就成功读取了数据 scan(&quot;data/ex.data&quot;, skip = 1) #&gt; [1] 2 3 5 7 11 13 17 如果设置参数 quiet = TRUE 就不会报告读取的数据量 scan(&quot;data/ex.data&quot;, skip = 1, quiet = TRUE) #&gt; [1] 2 3 5 7 11 13 17 参数 nlines = 1 表示只读取一行数据 scan(&quot;data/ex.data&quot;, skip = 1, nlines = 1) # only 1 line after the skipped one #&gt; [1] 2 3 5 7 默认参数 flush = TRUE 表示读取最后一个请求的字段后，刷新到行尾，下面对比一下读取的结果 scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;)) # flush is F -&gt; read &quot;7&quot; #&gt; Warning in scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;)): number of items read #&gt; is not a multiple of the number of columns #&gt; [[1]] #&gt; [1] &quot;TITLE&quot; &quot;2&quot; &quot;7&quot; &quot;17&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;extra&quot; &quot;3&quot; &quot;11&quot; &quot;&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;line&quot; &quot;5&quot; &quot;13&quot; &quot;&quot; scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;), flush = TRUE) #&gt; [[1]] #&gt; [1] &quot;TITLE&quot; &quot;2&quot; &quot;11&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;extra&quot; &quot;3&quot; &quot;13&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;line&quot; &quot;5&quot; &quot;17&quot; 临时文件 ex.data 用完了，我们调用 unlink 函数将其删除，以免留下垃圾文件 unlink(&quot;data/ex.data&quot;) # tidy up 5.1.2 read.table read.table(file, header = FALSE, sep = &quot;&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;, colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = &quot;#&quot;, allowEscapes = FALSE, flush = FALSE, stringsAsFactors = default.stringsAsFactors(), fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.delim(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.delim2(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) 变量名是不允许以下划线开头的，同样在数据框里，列名也不推荐使用下划线开头。默认情况下，read.table 都会通过参数 check.names 检查列名的有效性，该参数实际调用了函数 make.names 去检查。如果想尽量保持数据集原来的样子可以设置参数 check.names = FALSE, stringsAsFactors = FALSE。 默认情形下，read.table 还会将字符串转化为因子变量，这是 R 的历史原因，作为一门统计学家的必备语言，在统计模型中，字符常用来描述类别，而类别变量在 R 环境中常用因子类型来表示，而且大量内置的统计模型也是将它们视为因子变量，如 lm 、glm 等 dat1 = read.table(header = TRUE, check.names = TRUE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat1 #&gt; X_a X_b X_c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 dat2 = read.table(header = TRUE, check.names = FALSE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat2 #&gt; _a _b _c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 dat3 = read.table(header = TRUE, check.names = FALSE, stringsAsFactors = FALSE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat3 #&gt; _a _b _c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 5.1.3 readLines readLines(con = stdin(), n = -1L, ok = TRUE, warn = TRUE, encoding = &quot;unknown&quot;, skipNul = FALSE) 让我们折腾一波，读进来又写出去，只有 R 3.5.3 以上才能保持原样的正确输入输出 writeLines(readLines(&quot;latex/TeXLive.pkgs&quot;),&quot;latex/TeXLive.pkgs&quot;) 这次我们创建一个真的临时文件，因为重新启动 R 这个文件和文件夹就没有了，回收掉了 fil &lt;- tempfile(fileext = &quot;.data&quot;) cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;&quot;, &quot;11 13 17&quot;, file = fil, sep = &quot;\\n&quot;) fil #&gt; [1] &quot;C:\\\\Users\\\\xy-huang\\\\AppData\\\\Local\\\\Temp\\\\Rtmp2vvo5F\\\\file1260dd724d4.data&quot; 设置参数 n = -1 表示将文件 fil 的内容从头读到尾 readLines(fil, n = -1) #&gt; [1] &quot;TITLE extra line&quot; &quot;2 3 5 7&quot; &quot;&quot; &quot;11 13 17&quot; 作为拥有良好习惯的 R 用户，这种垃圾文件最好用后即焚 unlink(fil) # tidy up 再举个例子，我们创建一个新的临时文件 fil，文件内容只有 cat(&quot;123\\nabc&quot;) #&gt; 123 #&gt; abc fil &lt;- tempfile(&quot;test&quot;) cat(&quot;123\\nabc&quot;, file = fil, append = TRUE) fil #&gt; [1] &quot;C:\\\\Users\\\\xy-huang\\\\AppData\\\\Local\\\\Temp\\\\Rtmp2vvo5F\\\\test126022ed434b&quot; readLines(fil) #&gt; Warning in readLines(fil): incomplete final line found on &#39;C:\\Users\\xy- #&gt; huang\\AppData\\Local\\Temp\\Rtmp2vvo5F\\test126022ed434b&#39; #&gt; [1] &quot;123&quot; &quot;abc&quot; 这次读取文件的过程给出了警告，原因是 fil 没有以空行结尾，warn = TRUE 表示这种情况要给出警告，如果设置参数 warn = FALSE 就没有警告。我们还是建议大家尽量遵循规范。 再举一个例子，从一个连接读取数据，建立连接的方式有很多，参见 ?file，下面设置参数 blocking con &lt;- file(fil, &quot;r&quot;, blocking = FALSE) readLines(con) #&gt; [1] &quot;123&quot; cat(&quot; def\\n&quot;, file = fil, append = TRUE) readLines(con) #&gt; [1] &quot;abc def&quot; # 关闭连接 close(con) # 清理垃圾文件 unlink(fil) 5.1.4 readRDS 序列化数据操作，Mark Klik 开发的 fst 和 Travers Ching 开发的 qs， Hadley Wickham 开发的 feather 包实现跨语言环境快速的读写数据 表 5.1: fst 序列化数据框对象性能比较 BaseR、 data.table 和 feather7 Method Format Time (ms) Size (MB) Speed (MB/s) N readRDS bin 1577 1000 633 112 saveRDS bin 2042 1000 489 112 fread csv 2925 1038 410 232 fwrite csv 2790 1038 358 241 read_feather bin 3950 813 253 112 write_feather bin 1820 813 549 112 read_fst bin 457 303 2184 282 write_fst bin 314 303 3180 291 目前比较好的是 qs 和 fst 包 5.2 保存输出结果 capture.output(..., file = NULL, append = FALSE, type = c(&quot;output&quot;, &quot;message&quot;), split = FALSE) capture.output 将一段R代码执行结果，保存到文件，参数为表达式。capture.output 和 sink 的关系相当于 with 和 attach 的关系。 glmout &lt;- capture.output(summary(glm(case ~ spontaneous + induced, data = infert, family = binomial() )), file = &quot;data/capture.txt&quot;) capture.output(1 + 1, 2 + 2) #&gt; [1] &quot;[1] 2&quot; &quot;[1] 4&quot; capture.output({ 1 + 1 2 + 2 }) #&gt; [1] &quot;[1] 4&quot; sink 函数将控制台输出结果保存到文件，只将 outer 函数运行的结果保存到 ex-sink.txt 文件，outer 函数计算的是直积，在这里相当于 seq(10) %*% t(seq(10))，而在 R 语言中，更加有效的计算方式是 tcrossprod(seq(10),seq(10)) sink(&quot;data/ex-sink.txt&quot;) i &lt;- 1:10 outer(i, i, &quot;*&quot;) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 #&gt; [2,] 2 4 6 8 10 12 14 16 18 20 #&gt; [3,] 3 6 9 12 15 18 21 24 27 30 #&gt; [4,] 4 8 12 16 20 24 28 32 36 40 #&gt; [5,] 5 10 15 20 25 30 35 40 45 50 #&gt; [6,] 6 12 18 24 30 36 42 48 54 60 #&gt; [7,] 7 14 21 28 35 42 49 56 63 70 #&gt; [8,] 8 16 24 32 40 48 56 64 72 80 #&gt; [9,] 9 18 27 36 45 54 63 72 81 90 #&gt; [10,] 10 20 30 40 50 60 70 80 90 100 sink() 5.3 保存数据对象 load(file, envir = parent.frame(), verbose = FALSE) save(..., list = character(), file = stop(&quot;&#39;file&#39; must be specified&quot;), ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), compression_level, eval.promises = TRUE, precheck = TRUE) save.image(file = &quot;.RData&quot;, version = NULL, ascii = FALSE, compress = !ascii, safe = TRUE) load 和save 函数加载或保存包含工作环境信息的数据对象，save.image 保存当前工作环境到磁盘，即保存工作空间中所有数据对象，数据格式为 .RData，即相当于 save(list = ls(all.names = TRUE), file = &quot;.RData&quot;, envir = .GlobalEnv) dump 保存数据对象 AirPassengers 到文件 AirPassengers.txt，文件内容是 R 命令，可把AirPassengers.txt看作代码文档执行，dput 保存数据对象内容到文件AirPassengers.dat，文件中不包含变量名 AirPassengers。注意到 dump 输入是一个字符串，而 dput 要求输入数据对象的名称，source 函数与 dump 对应，而 dget 与 dput对应。 # 加载数据 data(AirPassengers, package = &quot;datasets&quot;) # 将数据以R代码块的形式保存到文件 dump(&#39;AirPassengers&#39;, file = &#39;data/AirPassengers.txt&#39;) # source(file = &#39;data/AirPassengers.txt&#39;) 接下来，我们读取 AirPassengers.txt 的文件内容，可见它是一段完整的 R 代码，可以直接复制到 R 的控制台中运行，并且得到一个与原始 AirPassengers 变量一样的结果 cat(readLines(&#39;data/AirPassengers.txt&#39;), sep = &quot;\\n&quot;) #&gt; AirPassengers &lt;- #&gt; structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, #&gt; 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, #&gt; 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, #&gt; 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, #&gt; 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, #&gt; 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, #&gt; 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, #&gt; 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, #&gt; 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, #&gt; 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, #&gt; 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, #&gt; 508, 461, 390, 432), .Tsp = c(1949, 1960.91666666667, 12), class = &quot;ts&quot;) dput 函数类似 dump 函数，保存数据对象到磁盘文件 dput(AirPassengers, file = &#39;data/AirPassengers.dat&#39;) # AirPassengers &lt;- dget(file = &#39;data/AirPassengers.dat&#39;) 同样地，现在我们观察 dput 函数保存的文件 AirPassengers.dat 内容，和dump 函数保存的文件 AirPassengers.txt相比，就缺一个赋值变量 cat(readLines(&#39;data/AirPassengers.dat&#39;), sep = &quot;\\n&quot;) #&gt; structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, #&gt; 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, #&gt; 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, #&gt; 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, #&gt; 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, #&gt; 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, #&gt; 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, #&gt; 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, #&gt; 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, #&gt; 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, #&gt; 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, #&gt; 508, 461, 390, 432), .Tsp = c(1949, 1960.91666666667, 12), class = &quot;ts&quot;) 5.4 其它数据格式 jsonlite 读取 *.json 格式的文件，jsonlite::write_json 函数将 R对象保存为 JSON 文件，jsonlite::fromJSON 将 json 字符串或文件转化为 R 对象，jsonlite::toJSON 函数正好与之相反 library(jsonlite) jsonlite::read_json(path = &quot;path/to/filename.json&quot;) yaml 包读取 *.yml 格式文件，返回一个列表，yaml::write_yaml 函数将 R 对象写入 yaml 格式 library(yaml) yaml::read_yaml(file = &#39;_bookdown.yml&#39;) #&gt; $book_filename #&gt; [1] &quot;RGraphics&quot; #&gt; #&gt; $delete_merged_file #&gt; [1] TRUE #&gt; #&gt; $language #&gt; $language$label #&gt; $language$label$fig #&gt; [1] &quot;图 &quot; #&gt; #&gt; $language$label$tab #&gt; [1] &quot;表 &quot; #&gt; #&gt; #&gt; $language$ui #&gt; $language$ui$edit #&gt; [1] &quot;编辑&quot; #&gt; #&gt; $language$ui$chapter_name #&gt; [1] &quot;第 &quot; &quot; 章&quot; #&gt; #&gt; #&gt; #&gt; $output_dir #&gt; [1] &quot;_book&quot; #&gt; #&gt; $new_session #&gt; [1] TRUE #&gt; #&gt; $before_chapter_script #&gt; [1] &quot;_common.R&quot; 表 5.2: 导入来自其它数据分析软件产生的数据集 统计软件 R函数 R包 ERSI ArcGIS read.shapefile shapefiles Matlab readMat R.matlab minitab read.mtp foreign SAS (permanent data) read.ssd foreign SAS (XPORT format) read.xport foreign SPSS read.spss foreign Stata read.dta foreign Systat read.systat foreign Octave read.octave foreign 表 5.3: 导入来自其它格式的数据集 文件格式 R函数 R包 列联表数据 read.ftable stats 二进制数据 readBin base 字符串数据 readChar base 剪贴板数据 readClipboard utils read.dcf 函数读取 Debian 控制格式文件，这种类型的文件以人眼可读的形式在存储数据，如 R 包的 DESCRIPTION 文件或者包含所有 CRAN 上 R 包描述的文件 https://cran.r-project.org/src/contrib/PACKAGES x &lt;- read.dcf(file = system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;), fields = c(&quot;Package&quot;, &quot;Version&quot;, &quot;Title&quot;)) x #&gt; Package Version Title #&gt; [1,] &quot;splines&quot; &quot;3.6.0&quot; &quot;Regression Spline Functions and Classes&quot; 最后要提及拥有瑞士军刀之称的 rio 包，它集合了当前 R 可以读取的所有统计分析软件导出的数据。 5.5 批量导入数据 library(tidyverse) read_list &lt;- function(list_of_datasets, read_func) { read_and_assign &lt;- function(dataset, read_func) { dataset_name &lt;- as.name(dataset) dataset_name &lt;- read_func(dataset) } # invisible is used to suppress the unneeded output output &lt;- invisible( sapply(list_of_datasets, read_and_assign, read_func = read_func, simplify = FALSE, USE.NAMES = TRUE ) ) # Remove the extension at the end of the data set names names_of_datasets &lt;- c(unlist(strsplit(list_of_datasets, &quot;[.]&quot;))[c(T, F)]) names(output) &lt;- names_of_datasets return(output) } 批量导入文件扩展名为 .csv 的数据文件，即逗号分割的文件 data_files &lt;- list.files(path = &quot;path/to/csv/dir&quot;,pattern = &quot;.csv&quot;, full.names = TRUE) print(data_files) 相比于 Base R 提供的 read.csv 函数，使用 readr 包的 read_csv 函数可以更快地读取csv格式文件，特别是在读取GB级数据文件时，效果特别明显。 list_of_data_sets &lt;- read_list(data_files, readr::read_csv) 使用 tibble 包的glimpse函数可以十分方便地对整个数据集有一个大致的了解，展示方式和信息量相当于 str 加 head 函数 tibble::glimpse(list_of_data_sets) 5.6 批量导出数据 假定我们有一个列表，其每个元素都是一个数据框，现在要把每个数据框分别存入 xlsx 表的工作薄中，以 mtcars 数据集为例，将其按分类变量 cyl 分组拆分，获得一个列表 list dat &lt;- split(mtcars, mtcars$cyl) dat #&gt; $`4` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 #&gt; #&gt; $`6` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; Merc 280 19.2 6 168 123 3.92 3.44 18.3 1 0 4 4 #&gt; Merc 280C 17.8 6 168 123 3.92 3.44 18.9 1 0 4 4 #&gt; Ferrari Dino 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 #&gt; #&gt; $`8` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 #&gt; Merc 450SE 16.4 8 276 180 3.07 4.07 17.4 0 0 3 3 #&gt; Merc 450SL 17.3 8 276 180 3.07 3.73 17.6 0 0 3 3 #&gt; Merc 450SLC 15.2 8 276 180 3.07 3.78 18.0 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460 215 3.00 5.42 17.8 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 #&gt; Dodge Challenger 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 #&gt; AMC Javelin 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 #&gt; Camaro Z28 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400 175 3.08 3.85 17.1 0 0 3 2 #&gt; Ford Pantera L 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 #&gt; Maserati Bora 15.0 8 301 335 3.54 3.57 14.6 0 1 5 8 将 xlsx 表格初始化，创建空白的工作薄 ## 加载 openxlsx 包 library(&#39;openxlsx&#39;) ## 创建空白的工作薄 wb &lt;- createWorkbook() 将列表里的每张表分别存入 xlsx 表格的每个 worksheet，worksheet 的名字就是分组变量的名字 Map(function(data, name){ addWorksheet(wb, name) writeData(wb, name, data) }, dat, names(dat)) #&gt; $`4` #&gt; [1] 0 #&gt; #&gt; $`6` #&gt; [1] 0 #&gt; #&gt; $`8` #&gt; [1] 0 最后保存数据到磁盘，见图 5.1 saveWorkbook(wb, file = &quot;data/matcars.xlsx&quot;, overwrite = TRUE) #&gt; Note: zip::zip() is deprecated, please use zip::zipr() instead knitr::include_graphics(path = &#39;figures/batch-export-xlsx.png&#39;) 图 5.1: 批量导出数据 处理 Excel 2003 (XLS) 和 Excel 2007 (XLSX) 文件还可以使用 WriteXLS 包，不过它依赖于 Perl，另一个 R 包 xlsx 与之功能类似，依赖 Java 环境。 Jennifer Bryan 和 Hadley Wickham 开发的 readxl 包和 Jeroen Ooms 开发的 writexl 包专门处理 xlsx 格式并且无任何系统依赖 5.7 导入大数据集 在不使用数据库的情况下，从命令行导入大数据集，如几百 M 或几个 G 的 csv 文件 https://stackoverflow.com/questions/1727772/ 5.8 从数据库导入 Hands-On Programming with R 数据读写章节8 以及 R, Databases, and Docker 将大量的 txt 文本存进 MySQL 数据库中，通过操作数据库来聚合文本，极大降低内存消耗9，而 ODBC 与 DBI 包是其它数据库接口的基础，knitr 提供了一个支持 SQL 代码的引擎，它便是基于 DBI，因此可以在 R Markdown 文档中直接使用 SQL 代码块10。这里制作一个归纳表格，左边数据库右边对应其 R 接口，两边都包含链接，如表 5.4 所示 表 5.4: 数据库接口 数据库 官网 R接口 开发仓 MySQL https://www.mysql.com/ RMySQL https://github.com/r-dbi/RMySQL SQLite https://www.sqlite.org RSQLite https://github.com/r-dbi/RSQLite PostgreSQL https://www.postgresql.org/ RPostgres https://github.com/r-dbi/RPostgres MariaDB https://mariadb.org/ RMariaDB https://github.com/r-dbi/RMariaDB 5.8.1 RSQLite db &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) DBI::dbWriteTable(db, &quot;mtcars&quot;, mtcars, overwrite=TRUE) subjects = 6 max.print=10 控制显示的行数 SELECT * FROM mtcars where gear IN (3, 4) and cyl &gt;= ?subjects 表 5.5: My Caption mpg cyl disp hp drat wt qsec vs am gear carb 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 19.2 6 168 123 3.92 3.44 18.3 1 0 4 4 17.8 6 168 123 3.92 3.44 18.9 1 0 4 4 16.4 8 276 180 3.07 4.07 17.4 0 0 3 3 17.3 8 276 180 3.07 3.73 17.6 0 0 3 3 output.var=\"mtcars34\" 将查询的结果保存到变量 mtcars34，此时不再输出打印到控制台，此外，还支持 SQL 语句中包含变量 subjects SELECT * FROM mtcars where gear IN (3, 4) and cyl &gt;= ?subjects 我们再来查看 mtcars34 变量的内容 head(mtcars34) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; 2 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; 3 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; 4 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 5 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; 6 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 5.8.2 PostgreSQL odbc 可以支持很多数据库，下面以连接 PostgreSQL 数据库为例介绍其过程 首先在某台机器上，拉取 PostgreSQL 的 Docker 镜像 docker pull postgres 在 Docker 上运行 PostgreSQL，主机端口号 8181 映射给数据库 PostgreSQL 的默认端口号 5432（或其它你的 DBA 分配给你的端口） docker run --name psql -d -p 8181:5432 -e ROOT=TRUE \\ -e USER=xiangyun -e PASSWORD=cloud postgres 在主机 Ubuntu 上配置 sudo apt-get install unixodbc unixodbc-dev odbc-postgresql 端口 5432 是分配给 PostgreSQL 的默认端口，host 可以是云端的地址，如 你的亚马逊账户下的 PostgreSQL 数据库地址 &lt;ec2-54-83-201-96.compute-1.amazonaws.com&gt;，也可以是本地局域网IP地址，如&lt;192.168.1.200&gt;。通过参数 dbname 连接到指定的 PostgreSQL 数据库，如 Heroku，这里作为演示就以默认的数据库 postgres 为例 library(DBI) con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;DATABASE_NAME&quot;, host = &quot;HOST&quot;, port = 8181, user = &quot;USERNAME&quot;, password = &quot;PASSWORD&quot; ) 列出数据库中的所有表 dbListTables(con) #&gt; [1] &quot;mtcars&quot; 第一次启动从 Docker Hub 上下载的镜像，默认的数据库是 postgres 里面没有任何表，所以将 R 环境中的 mtcars 数据集写入 postgres 数据库 DBI::dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite=TRUE) 现在可以看到数据表 mtcars 的各个字段 dbListFields(con, &quot;mtcars&quot;) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; 最后执行一条 SQL 语句 res &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) # 发送 SQL 语句 dbFetch(res) # 获取查询结果 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; 3 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; 4 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; 5 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; 6 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; 7 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; 8 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; 9 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; 10 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; 11 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 dbClearResult(res) # 清理查询通道 或者一条命令搞定 DBI::dbGetQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; 3 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; 4 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; 5 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; 6 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; 7 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; 8 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; 9 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; 10 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; 11 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 最后用完数据库查询要记得关闭连接 dbDisconnect(conn = con) 5.8.3 ClickHouse 对系统的要求是 System requirements: Linux, x86_64 with SSE 4.2. sudo apt-get install dirmngr # optional # 导入 key sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv E0C56BD4 # optional # 添加源 echo &quot;deb http://repo.yandex.ru/clickhouse/deb/stable/ main/&quot; | sudo tee /etc/apt/sources.list.d/clickhouse.list sudo apt-get update # 安装客户端 sudo apt-get install -y clickhouse-server clickhouse-client # 启动服务 sudo service clickhouse-server start # 进入客户端 clickhouse-client ClickHouse 中文用户手册 和新浪高鹏在北京 ClickHouse社区分享会 上给的报告 MySQL DBA解锁数据分析的新姿势-ClickHouse 开源社区对 ClickHouse 提供了很多语言的支持，比如 R 语言接口有 RClickhouse 和 clickhouse-r，其它接口请看 官方文档链接 由于 clickhouse-r 还在开发中，从未提交到 CRAN，提供的功能也相对有限，这里我们推荐使用 RClickhouse，首先安装 RClickhouse # 安装 CRAN 版本 install.packages(&quot;RClickhouse&quot;) # 安装Github上的开发版 devtools::install_github(&quot;IMSMWU/RClickhouse&quot;) 建立数据库的连接，离不开 dbConnect 函数，它提供的 config_paths 参数用来指定配置文件 RClickhouse.yaml 的路径，在该文件中指定一系列的参数值 host, port, db, user, password, compression host: example-db.com port: 1111 如果没有手动配置，会使用默认的参数配置 host=\"localhost\", port = 9000, db = \"default\", user = \"default\", password = \"\", compression = \"lz4\"。现在，我们考虑更加实用的场景，服务器上安装了 Docker，ClickHouse 部署在Docker集群上，下面介绍如何从本机连接上集群。 首先在某台机器上，拉取 ClickHouse 的 Docker 镜像 docker pull yandex/clickhouse-server 从 Yandex 官网打包的 Dockerfile 来看，其默认暴露了 9000、 8123 和 9009 三个端口，所以我在运行 ClickHouse 容器的时候，需要选择其中一个端口映射给主机端口，这里我选择 8282，值得注意的是，我主机的8787端口已经分配给了 RStudio，所以不要再把该主机端口映射给 9000 docker run --name ck -d -p 8282:9000 -e ROOT=TRUE \\ -e USER=xiangyun -e PASSWORD=cloud yandex/clickhouse-server 最后是建立连接，需要远端 Docker 容器内 Clickhouse 的 IP 地址，分配给它的主机端口，用来访问数据库，数据库的用户账户和具体的数据库名称，默认账户和密码以及数据库都是 default，下面展示连接远程 ClickHouse 数据库 library(DBI) library(RClickhouse) con &lt;- DBI::dbConnect(RClickhouse::clickhouse(), host = &quot;192.168.99.100&quot;, port = 8282, db = &quot;default&quot;, user = &quot;default&quot;, password = &quot;default&quot;, compression = &quot;lz4&quot; ) 连接远程数据库的方式，实现本地数据分析环境和数据库环境分离，分别管理和使用 下面是连接本地 ClickHouse 数据库，数据库和数据分析环境都在本地，我们使用默认的9000端口和默认default数据库，而默认的账户名在安装 ClickHouse 时指定为 cloud，因此连接参数设置如下 library(DBI) library(RClickhouse) # con &lt;- DBI::dbConnect(RClickhouse::clickhouse(), config_paths = &quot;~/.R/RClickhouse.yaml&quot;) con &lt;- DBI::dbConnect(RClickhouse::clickhouse(), host = &quot;localhost&quot;, port = 9000, db = &quot;default&quot;, user = &quot;default&quot;, password = &quot;cloud&quot;, compression = &quot;lz4&quot; ) RClickHouse 包提供部分 dplyr 式的数据操作，使用比较方便，这里便使用它了，往 ClickHouse 中写入数据 DBI::dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite=TRUE) 查看数据库中的 mtcars 表 # 列出 ClickHouse 中存放的表 dbListTables(con) #&gt; [1] &quot;mtcars&quot; # 列出表 mtcars 中的所有字段 dbListFields(con, &quot;mtcars&quot;) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; #&gt; [7] &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; &quot;carb&quot; &quot;row_names&quot; RClickHouse 包支持的聚合操作（其实是 dplyr）和 Base R 提供的聚合操作对比，测试一下正确与否 library(tidyverse) # 按变量 cyl 分组对 mpg 求和 tbl(con, &quot;mtcars&quot;) %&gt;% group_by(cyl) %&gt;% summarise(smpg=sum(mpg, na.rm = TRUE)) # SQL 总是要移除缺失值 #&gt; Warning: Translator is missing window variants of the following aggregate functions: #&gt; * %||% #&gt; Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, noBreaks. = #&gt; FALSE, : column uptime converted from UInt32 to Numeric #&gt; # Source: lazy query [?? x 2] #&gt; # Database: clickhouse 19.5.2.6 [default@192.168.99.100:8282/default; uptime: #&gt; # 0 days ] #&gt; cyl smpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 293. #&gt; 2 8 211. #&gt; 3 6 138. # 等价于 aggregate(mpg ~ cyl, data = mtcars, sum) #&gt; cyl mpg #&gt; 1 4 293 #&gt; 2 6 138 #&gt; 3 8 211 # 先筛选出 cyl = 8 并且 vs = 0 的数据，然后按 am 分组，最后对 qsec 求平均值 tbl(con, &quot;mtcars&quot;) %&gt;% filter(cyl == 8, vs == 0) %&gt;% group_by(am) %&gt;% summarise(mean(qsec, na.rm = TRUE)) #&gt; Warning: Translator is missing window variants of the following aggregate functions: #&gt; * %||% #&gt; Warning: Translator is missing window variants of the following aggregate functions: #&gt; * %||% #&gt; Warning: Translator is missing window variants of the following aggregate functions: #&gt; * %||% #&gt; Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, noBreaks. = #&gt; FALSE, : column uptime converted from UInt32 to Numeric #&gt; # Source: lazy query [?? x 2] #&gt; # Database: clickhouse 19.5.2.6 [default@192.168.99.100:8282/default; uptime: #&gt; # 0 days ] #&gt; am `mean(qsec, na.rm = TRUE)` #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 17.1 #&gt; 2 1 14.6 # 等价于 aggregate(qsec ~ am, data = mtcars, mean, subset = cyl == 8 &amp; vs == 0) #&gt; am qsec #&gt; 1 0 17.1 #&gt; 2 1 14.6 aggregate 聚合函数默认对缺失值的处理是忽略， sum 和 mean 函数的参数 na.rm=TRUE 实际由聚合函数 aggregate 的参数 na.action 传递，它的默认值是 na.omit ，就是将缺失值移除后返回。值得注意的是 na.omit 是一个缺失值处理的函数，所以如果对缺失值有特殊要求，比如插补，可以自己写函数传递给 na.action 参数 你当然可以继续使用 SQL 语句做查询，而不使用 dplyr 提供的现代化的管道操作语法 # 传递 SQL 查询语句 DBI::dbGetQuery(con, &quot;SELECT vs, COUNT(*) AS n_vc, AVG(qsec) AS avg_qsec FROM mtcars GROUP BY vs&quot;) #&gt; Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, noBreaks. = #&gt; FALSE, : column n_vc converted from UInt64 to Numeric #&gt; vs n_vc avg_qsec #&gt; 1 0 18 16.7 #&gt; 2 1 14 19.3 如果数据集比较小，可以将 ClickHouse 的整张表读进内存，但是对于大数据集，只有使用远程服务器才可以获得更好的性能 # 读取数据库中的整张表 copy_mtcars &lt;- dbReadTable(con, &quot;mtcars&quot;) tibble::glimpse(copy_mtcars) #&gt; Observations: 32 #&gt; Variables: 12 #&gt; $ mpg &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19... #&gt; $ cyl &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4,... #&gt; $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, ... #&gt; $ hp &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180,... #&gt; $ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.... #&gt; $ wt &lt;dbl&gt; 2.62, 2.88, 2.32, 3.21, 3.44, 3.46, 3.57, 3.19, 3.15, 3.... #&gt; $ qsec &lt;dbl&gt; 16.5, 17.0, 18.6, 19.4, 17.0, 20.2, 15.8, 20.0, 22.9, 18... #&gt; $ vs &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1,... #&gt; $ am &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,... #&gt; $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4,... #&gt; $ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2,... #&gt; $ row_names &lt;chr&gt; &quot;Mazda RX4&quot;, &quot;Mazda RX4 Wag&quot;, &quot;Datsun 710&quot;, &quot;Hornet 4 Dr... 还有 RClickhouse 使用 SQL 查询的时候，同样支持 ClickHouse 的内置函数，如 multiIf # 查看 ClickHouse 中所有的数据库名称 DBI::dbGetQuery(con, &quot;SHOW DATABASES&quot;) #&gt; name #&gt; 1 default #&gt; 2 system # 查看所有存储的表 DBI::dbGetQuery(con, &quot;SHOW TABLES&quot;) #&gt; name #&gt; 1 mtcars # 获取 ClickHouse 中 mtcars 表的变量名和类型描述 DBI::dbGetQuery(con, &quot;DESCRIBE TABLE mtcars&quot;) #&gt; name type default_type default_expression comment codec_expression #&gt; 1 mpg Float64 #&gt; 2 cyl Float64 #&gt; 3 disp Float64 #&gt; 4 hp Float64 #&gt; 5 drat Float64 #&gt; 6 wt Float64 #&gt; 7 qsec Float64 #&gt; 8 vs Float64 #&gt; 9 am Float64 #&gt; 10 gear Float64 #&gt; 11 carb Float64 #&gt; 12 row_names String # Compact CASE - WHEN - THEN conditionals DBI::dbGetQuery(con, &quot; SELECT multiIf(am=1, &#39;automatic&#39;, &#39;manual&#39;) AS transmission, multiIf(vs=1, &#39;straight&#39;, &#39;V-shaped&#39;) AS engine FROM mtcars &quot;) #&gt; transmission engine #&gt; 1 automatic V-shaped #&gt; 2 automatic V-shaped #&gt; 3 automatic straight #&gt; 4 manual straight #&gt; 5 manual V-shaped #&gt; 6 manual straight #&gt; 7 manual V-shaped #&gt; 8 manual straight #&gt; 9 manual straight #&gt; 10 manual straight #&gt; 11 manual straight #&gt; 12 manual V-shaped #&gt; 13 manual V-shaped #&gt; 14 manual V-shaped #&gt; 15 manual V-shaped #&gt; 16 manual V-shaped #&gt; 17 manual V-shaped #&gt; 18 automatic straight #&gt; 19 automatic straight #&gt; 20 automatic straight #&gt; 21 manual straight #&gt; 22 manual V-shaped #&gt; 23 manual V-shaped #&gt; 24 manual V-shaped #&gt; 25 manual V-shaped #&gt; 26 automatic straight #&gt; 27 automatic V-shaped #&gt; 28 automatic straight #&gt; 29 automatic V-shaped #&gt; 30 automatic V-shaped #&gt; 31 automatic V-shaped #&gt; 32 automatic straight dbDisconnect(conn = con) 这是一个存放在 Github 上的包，随着 ClikHouse 在大厂的流行，此包也受到越来越多的关注 与数据仓库如何连接，如何查询数据，背后的接口 DBI 如何使用，实例化一个新的接口，如 clickhouse2r ClickHouse 独辟蹊径，基于 C++ 的实现，数据查询速度超级快，官网介绍碾压大量传统数据库。还有不少接口，其中还有 R 的 clickhouse-r # 安装clickhouse接口 devtools::install_github(&quot;hannesmuehleisen/clickhouse-r&quot;) # 调用接口 library(DBI) con &lt;- dbConnect(clickhouse::clickhouse(), host = &quot;localhost&quot;, port = 8123L, user = &quot;default&quot;, password = &quot;&quot; ) dbWriteTable(con, &quot;mtcars&quot;, mtcars) dbListTables(con) dbGetQuery(con, &quot;SELECT COUNT(*) FROM mtcars&quot;) d &lt;- dbReadTable(con, &quot;mtcars&quot;) dbDisconnect(con) 发现它和 knitr 里的 SQL 钩子，都用 DBI包 knitr::include_graphics(path = &quot;figures/clickhouse.png&quot;) 图 5.2: ClickHouse 与 R 学习博文 利用 JDBC 驱动连接 R 和 Hive 和 clickhouse-jdbc 试试 [RJDBC] 包远程连接 ClickHouse 仓库 5.8.4 MySQL MySQL 是一个很常见，应用也很广泛的数据库，数据分析的常见环境是在一个R Notebook 里，我们可以在正文之前先设定数据库连接信息 ```{r setup} library(DBI) # 指定数据库连接信息 db &lt;- dbConnect(RMySQL::MySQL(), dbname = &#39;dbtest&#39;, username = &#39;user_test&#39;, password = &#39;password&#39;, host = &#39;10.10.101.10&#39;, port = 3306 ) # 创建默认连接 knitr::opts_chunk$set(connection = &#39;db&#39;) # 设置字符编码，以免中文查询乱码 DBI::dbSendQuery(db, &#39;SET NAMES utf8&#39;) # 设置日期变量，以运用在SQL中 idate &lt;- &#39;2019-05-03&#39; ``` SQL 代码块中使用 R 环境中的变量，并将查询结果输出为R环境中的数据框 ```{sql, output.var=&#39;data_output&#39;} SELECT * FROM user_table where date_format(created_date,&#39;%Y-%m-%d&#39;)&gt;=?idate ``` 以上代码会将 SQL 的运行结果存在 data_output 这是数据库中，idate 取之前设置的日期2019-05-03，user_table 是 MySQL 数据库中的表名，created_date 是创建user_table时，指定的日期名。 如果 SQL 比较长，为了代码美观，把带有变量的 SQL 保存为demo.sql脚本，只需要在 SQL 的 chunk 中直接读取 SQL 文件11。 ```{sql, code=readLines(&#39;demo.sql&#39;), output.var=&#39;data_output&#39;} ``` 如果我们需要每天或者按照指定的日期重复地运行这个 R Markdown 文件，可以在 YAML 部分引入参数12 --- params: date: &quot;2019-05-03&quot; # 参数化日期 --- ```{r setup, include=FALSE} idate = params$date # 将参数化日期传递给 idate 变量 ``` 我们将这个 Rmd 文件命名为 MyDocument.Rmd，运行这个文件可以从 R 控制台执行或在 RStudio 点击 knit。 rmarkdown::render(&quot;MyDocument.Rmd&quot;, params = list( date = &quot;2019-05-03&quot; )) 如果在文档的 YAML 位置已经指定日期，这里可以不指定。注意在这里设置日期会覆盖 YAML 处指定的参数值，这样做的好处是可以批量化操作。 5.8.5 Spark 当数据分析报告遇上 Spark 时，就需要 SparkR、 sparklyr、 arrow 或 rsparking 接口了， Javier Luraschi 写了一本书 The R in Spark: Learning Apache Spark with R 详细介绍了相关扩展和应用 首先安装 sparklyr 包，RStudio 公司 Javier Lurasch 开发了 sparklyr 包，作为 Spark 与 R 语言之间的接口，安装完 sparklyr 包，还是需要 Spark 和 Hadoop 环境 install.packages(&#39;sparklyr&#39;) library(sparklyr) spark_install() # Installing Spark 2.4.0 for Hadoop 2.7 or later. # Downloading from: # - &#39;https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz&#39; # Installing to: # - &#39;~/spark/spark-2.4.0-bin-hadoop2.7&#39; # trying URL &#39;https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz&#39; # Content type &#39;application/x-gzip&#39; length 227893062 bytes (217.3 MB) # ================================================== # downloaded 217.3 MB # # Installation complete. 既然 sparklyr 已经安装了 Spark 和 Hadoop 环境，安装 SparkR 后，只需配置好路径，就可以加载 SparkR 包 install.packages(&#39;SparkR&#39;) if (nchar(Sys.getenv(&quot;SPARK_HOME&quot;)) &lt; 1) { Sys.setenv(SPARK_HOME = &quot;~/spark/spark-2.4.0-bin-hadoop2.7&quot;) } library(SparkR, lib.loc = c(file.path(Sys.getenv(&quot;SPARK_HOME&quot;), &quot;R&quot;, &quot;lib&quot;))) sparkR.session(master = &quot;local[*]&quot;, sparkConfig = list(spark.driver.memory = &quot;2g&quot;)) rscala 架起了 R 和 Scala 两门语言之间交流的桥梁，使得彼此之间可以互相调用 是否存在这样的可能， Spark 提供了大量的 MLib 库的调用接口，R 的功能支持是最少的，Java/Scala 是原生的，那么要么自己开发新的功能整合到 SparkR 中，要么借助 rscala 将 scala 接口代码封装进来 https://www.fstpackage.org/↩ https://rstudio-education.github.io/hopr/dataio.html↩ https://brucezhaor.github.io/blog/2016/08/04/batch-process-txt-to-mysql↩ https://bookdown.org/yihui/rmarkdown/language-engines.html#sql [rstudio-spark]: https://spark.rstudio.com/↩ https://d.cosx.org/d/419974↩ https://bookdown.org/yihui/rmarkdown/params-knit.html↩ "],
["07-data-rectangling.html", "第 6 章 数据异形者", " 第 6 章 数据异形者 来自其它格式的数据形式，如 JSON、XML、YAML 需要转化清理成 R 中数据框的形式 data.frame Data Rectangling with jq Mongolite User Manual introduction to using MongoDB with the mongolite client in R "],
["08-data-manipulation.html", "第 7 章 数据操作手 7.1 查看数据 7.2 数据变形 7.3 数据转换 7.4 提取子集 7.5 按列排序 7.6 数据拆分 7.7 数据合并 7.8 数据去重 7.9 数据聚合 7.10 表格统计 7.11 索引访问 7.12 多维数组 7.13 其它操作", " 第 7 章 数据操作手 参考 Data Manipulation With R (Spector 2008) 重新捋一遍本章 主要介绍 Base R 提供的数据操作，关于采用 Base R 还是 tidyverse 做数据操作的 讨论 什么是 Base R? Base R 指的是 R 语言/软件的核心组件，由 R Core Team 维护 Pkgs &lt;- sapply(list.files(R.home(&quot;library&quot;)), function(x) packageDescription(pkg = x, fields = &quot;Priority&quot;)) names(Pkgs[Pkgs == &quot;base&quot; &amp; !is.na(Pkgs)]) #&gt; [1] &quot;base&quot; &quot;compiler&quot; &quot;datasets&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;grid&quot; #&gt; [7] &quot;methods&quot; &quot;parallel&quot; &quot;splines&quot; &quot;stats&quot; &quot;stats4&quot; &quot;tcltk&quot; #&gt; [13] &quot;tools&quot; &quot;utils&quot; names(Pkgs[Pkgs == &quot;recommended&quot; &amp; !is.na(Pkgs)]) #&gt; [1] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; &quot;codetools&quot; &quot;foreign&quot; #&gt; [6] &quot;KernSmooth&quot; &quot;lattice&quot; &quot;MASS&quot; &quot;Matrix&quot; &quot;mgcv&quot; #&gt; [11] &quot;nlme&quot; &quot;nnet&quot; &quot;rpart&quot; &quot;spatial&quot; &quot;survival&quot; 数据变形，分组统计聚合等，用以作为模型的输入，绘图的对象，操作的数据对象是数据框(data.frame)类型的，而且如果没有特别说明，文中出现的数据集都是 Base R 内置的，第三方 R 包或者来源于网上的数据集都会加以说明。 7.1 查看数据 查看属性 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1.. 查看部分数据集 head(iris, 5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa tail(iris, 5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica 查看文件前（后）5行 head -n 5 clientip.csv tail -n 5 clientip.csv 对象的类型，存储方式 class(iris) #&gt; [1] &quot;data.frame&quot; mode(iris) #&gt; [1] &quot;list&quot; typeof(iris) #&gt; [1] &quot;list&quot; 查看对象在R环境中所占空间的大小 object.size(iris) #&gt; 7256 bytes object.size(letters) #&gt; 1712 bytes object.size(ls) #&gt; 89904 bytes format(object.size(library), units = &quot;auto&quot;) #&gt; [1] &quot;1.8 Mb&quot; 7.2 数据变形 重复测量数据的变形 Reshape Grouped Data，数据框宽格式 wide 变长格式 long reshape 还支持正则表达式 str(Indometh) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 66 obs. of 3 variables: #&gt; $ Subject: Ord.factor w/ 6 levels &quot;1&quot;&lt;&quot;4&quot;&lt;&quot;2&quot;&lt;&quot;5&quot;&lt;..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ time : num 0.25 0.5 0.75 1 1.25 2 3 4 5 6 ... #&gt; $ conc : num 1.5 0.94 0.78 0.48 0.37 0.19 0.12 0.11 0.08 0.07 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language conc ~ time | Subject #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Time since drug administration&quot; #&gt; ..$ y: chr &quot;Indomethacin concentration&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(hr)&quot; #&gt; ..$ y: chr &quot;(mcg/ml)&quot; summary(Indometh) #&gt; Subject time conc #&gt; 1:11 Min. :0.25 Min. :0.050 #&gt; 4:11 1st Qu.:0.75 1st Qu.:0.110 #&gt; 2:11 Median :2.00 Median :0.340 #&gt; 5:11 Mean :2.89 Mean :0.592 #&gt; 6:11 3rd Qu.:5.00 3rd Qu.:0.832 #&gt; 3:11 Max. :8.00 Max. :2.720 wide &lt;- reshape(Indometh, v.names = &quot;conc&quot;, idvar = &quot;Subject&quot;, timevar = &quot;time&quot;, direction = &quot;wide&quot; ) wide[, 1:6] #&gt; Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25 #&gt; 1 1 1.50 0.94 0.78 0.48 0.37 #&gt; 12 2 2.03 1.63 0.71 0.70 0.64 #&gt; 23 3 2.72 1.49 1.16 0.80 0.80 #&gt; 34 4 1.85 1.39 1.02 0.89 0.59 #&gt; 45 5 2.05 1.04 0.81 0.39 0.30 #&gt; 56 6 2.31 1.44 1.03 0.84 0.64 长 long 变 wide 宽格式 data(gambia, package = &quot;geoR&quot;) # Building a &quot;village-level&quot; data frame ind &lt;- paste(&quot;x&quot;, gambia[, 1], &quot;y&quot;, gambia[, 2], sep = &quot;&quot;) village &lt;- gambia[!duplicated(ind), c(1:2, 7:8)] village$prev &lt;- as.vector(tapply(gambia$pos, ind, mean)) head(village) 7.3 数据转换 transform 对数据框中的某些列做计算，取对数，将计算的结果单存一列加到数据框中 transform(iris, scale.sl = (max(Sepal.Length) - Sepal.Length) / (max(Sepal.Length) - min(Sepal.Length))) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species scale.sl #&gt; 1 5.1 3.5 1.4 0.2 setosa 0.7778 #&gt; 2 4.9 3.0 1.4 0.2 setosa 0.8333 #&gt; 3 4.7 3.2 1.3 0.2 setosa 0.8889 #&gt; 4 4.6 3.1 1.5 0.2 setosa 0.9167 #&gt; 5 5.0 3.6 1.4 0.2 setosa 0.8056 #&gt; 6 5.4 3.9 1.7 0.4 setosa 0.6944 #&gt; 7 4.6 3.4 1.4 0.3 setosa 0.9167 #&gt; 8 5.0 3.4 1.5 0.2 setosa 0.8056 #&gt; 9 4.4 2.9 1.4 0.2 setosa 0.9722 #&gt; 10 4.9 3.1 1.5 0.1 setosa 0.8333 #&gt; 11 5.4 3.7 1.5 0.2 setosa 0.6944 #&gt; 12 4.8 3.4 1.6 0.2 setosa 0.8611 #&gt; 13 4.8 3.0 1.4 0.1 setosa 0.8611 #&gt; 14 4.3 3.0 1.1 0.1 setosa 1.0000 #&gt; 15 5.8 4.0 1.2 0.2 setosa 0.5833 #&gt; 16 5.7 4.4 1.5 0.4 setosa 0.6111 #&gt; 17 5.4 3.9 1.3 0.4 setosa 0.6944 #&gt; 18 5.1 3.5 1.4 0.3 setosa 0.7778 #&gt; 19 5.7 3.8 1.7 0.3 setosa 0.6111 #&gt; 20 5.1 3.8 1.5 0.3 setosa 0.7778 #&gt; 21 5.4 3.4 1.7 0.2 setosa 0.6944 #&gt; 22 5.1 3.7 1.5 0.4 setosa 0.7778 #&gt; 23 4.6 3.6 1.0 0.2 setosa 0.9167 #&gt; 24 5.1 3.3 1.7 0.5 setosa 0.7778 #&gt; 25 4.8 3.4 1.9 0.2 setosa 0.8611 #&gt; 26 5.0 3.0 1.6 0.2 setosa 0.8056 #&gt; 27 5.0 3.4 1.6 0.4 setosa 0.8056 #&gt; 28 5.2 3.5 1.5 0.2 setosa 0.7500 #&gt; 29 5.2 3.4 1.4 0.2 setosa 0.7500 #&gt; 30 4.7 3.2 1.6 0.2 setosa 0.8889 #&gt; 31 4.8 3.1 1.6 0.2 setosa 0.8611 #&gt; 32 5.4 3.4 1.5 0.4 setosa 0.6944 #&gt; 33 5.2 4.1 1.5 0.1 setosa 0.7500 #&gt; 34 5.5 4.2 1.4 0.2 setosa 0.6667 #&gt; 35 4.9 3.1 1.5 0.2 setosa 0.8333 #&gt; 36 5.0 3.2 1.2 0.2 setosa 0.8056 #&gt; 37 5.5 3.5 1.3 0.2 setosa 0.6667 #&gt; 38 4.9 3.6 1.4 0.1 setosa 0.8333 #&gt; 39 4.4 3.0 1.3 0.2 setosa 0.9722 #&gt; 40 5.1 3.4 1.5 0.2 setosa 0.7778 #&gt; 41 5.0 3.5 1.3 0.3 setosa 0.8056 #&gt; 42 4.5 2.3 1.3 0.3 setosa 0.9444 #&gt; 43 4.4 3.2 1.3 0.2 setosa 0.9722 #&gt; 44 5.0 3.5 1.6 0.6 setosa 0.8056 #&gt; 45 5.1 3.8 1.9 0.4 setosa 0.7778 #&gt; 46 4.8 3.0 1.4 0.3 setosa 0.8611 #&gt; 47 5.1 3.8 1.6 0.2 setosa 0.7778 #&gt; 48 4.6 3.2 1.4 0.2 setosa 0.9167 #&gt; 49 5.3 3.7 1.5 0.2 setosa 0.7222 #&gt; 50 5.0 3.3 1.4 0.2 setosa 0.8056 #&gt; 51 7.0 3.2 4.7 1.4 versicolor 0.2500 #&gt; 52 6.4 3.2 4.5 1.5 versicolor 0.4167 #&gt; 53 6.9 3.1 4.9 1.5 versicolor 0.2778 #&gt; 54 5.5 2.3 4.0 1.3 versicolor 0.6667 #&gt; 55 6.5 2.8 4.6 1.5 versicolor 0.3889 #&gt; 56 5.7 2.8 4.5 1.3 versicolor 0.6111 #&gt; 57 6.3 3.3 4.7 1.6 versicolor 0.4444 #&gt; 58 4.9 2.4 3.3 1.0 versicolor 0.8333 #&gt; 59 6.6 2.9 4.6 1.3 versicolor 0.3611 #&gt; 60 5.2 2.7 3.9 1.4 versicolor 0.7500 #&gt; 61 5.0 2.0 3.5 1.0 versicolor 0.8056 #&gt; 62 5.9 3.0 4.2 1.5 versicolor 0.5556 #&gt; 63 6.0 2.2 4.0 1.0 versicolor 0.5278 #&gt; 64 6.1 2.9 4.7 1.4 versicolor 0.5000 #&gt; 65 5.6 2.9 3.6 1.3 versicolor 0.6389 #&gt; 66 6.7 3.1 4.4 1.4 versicolor 0.3333 #&gt; 67 5.6 3.0 4.5 1.5 versicolor 0.6389 #&gt; 68 5.8 2.7 4.1 1.0 versicolor 0.5833 #&gt; 69 6.2 2.2 4.5 1.5 versicolor 0.4722 #&gt; 70 5.6 2.5 3.9 1.1 versicolor 0.6389 #&gt; 71 5.9 3.2 4.8 1.8 versicolor 0.5556 #&gt; 72 6.1 2.8 4.0 1.3 versicolor 0.5000 #&gt; 73 6.3 2.5 4.9 1.5 versicolor 0.4444 #&gt; 74 6.1 2.8 4.7 1.2 versicolor 0.5000 #&gt; 75 6.4 2.9 4.3 1.3 versicolor 0.4167 #&gt; 76 6.6 3.0 4.4 1.4 versicolor 0.3611 #&gt; 77 6.8 2.8 4.8 1.4 versicolor 0.3056 #&gt; 78 6.7 3.0 5.0 1.7 versicolor 0.3333 #&gt; 79 6.0 2.9 4.5 1.5 versicolor 0.5278 #&gt; 80 5.7 2.6 3.5 1.0 versicolor 0.6111 #&gt; 81 5.5 2.4 3.8 1.1 versicolor 0.6667 #&gt; 82 5.5 2.4 3.7 1.0 versicolor 0.6667 #&gt; 83 5.8 2.7 3.9 1.2 versicolor 0.5833 #&gt; 84 6.0 2.7 5.1 1.6 versicolor 0.5278 #&gt; 85 5.4 3.0 4.5 1.5 versicolor 0.6944 #&gt; 86 6.0 3.4 4.5 1.6 versicolor 0.5278 #&gt; 87 6.7 3.1 4.7 1.5 versicolor 0.3333 #&gt; 88 6.3 2.3 4.4 1.3 versicolor 0.4444 #&gt; 89 5.6 3.0 4.1 1.3 versicolor 0.6389 #&gt; 90 5.5 2.5 4.0 1.3 versicolor 0.6667 #&gt; 91 5.5 2.6 4.4 1.2 versicolor 0.6667 #&gt; 92 6.1 3.0 4.6 1.4 versicolor 0.5000 #&gt; 93 5.8 2.6 4.0 1.2 versicolor 0.5833 #&gt; 94 5.0 2.3 3.3 1.0 versicolor 0.8056 #&gt; 95 5.6 2.7 4.2 1.3 versicolor 0.6389 #&gt; 96 5.7 3.0 4.2 1.2 versicolor 0.6111 #&gt; 97 5.7 2.9 4.2 1.3 versicolor 0.6111 #&gt; 98 6.2 2.9 4.3 1.3 versicolor 0.4722 #&gt; 99 5.1 2.5 3.0 1.1 versicolor 0.7778 #&gt; 100 5.7 2.8 4.1 1.3 versicolor 0.6111 #&gt; 101 6.3 3.3 6.0 2.5 virginica 0.4444 #&gt; 102 5.8 2.7 5.1 1.9 virginica 0.5833 #&gt; 103 7.1 3.0 5.9 2.1 virginica 0.2222 #&gt; 104 6.3 2.9 5.6 1.8 virginica 0.4444 #&gt; 105 6.5 3.0 5.8 2.2 virginica 0.3889 #&gt; 106 7.6 3.0 6.6 2.1 virginica 0.0833 #&gt; 107 4.9 2.5 4.5 1.7 virginica 0.8333 #&gt; 108 7.3 2.9 6.3 1.8 virginica 0.1667 #&gt; 109 6.7 2.5 5.8 1.8 virginica 0.3333 #&gt; 110 7.2 3.6 6.1 2.5 virginica 0.1944 #&gt; 111 6.5 3.2 5.1 2.0 virginica 0.3889 #&gt; 112 6.4 2.7 5.3 1.9 virginica 0.4167 #&gt; 113 6.8 3.0 5.5 2.1 virginica 0.3056 #&gt; 114 5.7 2.5 5.0 2.0 virginica 0.6111 #&gt; 115 5.8 2.8 5.1 2.4 virginica 0.5833 #&gt; 116 6.4 3.2 5.3 2.3 virginica 0.4167 #&gt; 117 6.5 3.0 5.5 1.8 virginica 0.3889 #&gt; 118 7.7 3.8 6.7 2.2 virginica 0.0556 #&gt; 119 7.7 2.6 6.9 2.3 virginica 0.0556 #&gt; 120 6.0 2.2 5.0 1.5 virginica 0.5278 #&gt; 121 6.9 3.2 5.7 2.3 virginica 0.2778 #&gt; 122 5.6 2.8 4.9 2.0 virginica 0.6389 #&gt; 123 7.7 2.8 6.7 2.0 virginica 0.0556 #&gt; 124 6.3 2.7 4.9 1.8 virginica 0.4444 #&gt; 125 6.7 3.3 5.7 2.1 virginica 0.3333 #&gt; 126 7.2 3.2 6.0 1.8 virginica 0.1944 #&gt; 127 6.2 2.8 4.8 1.8 virginica 0.4722 #&gt; 128 6.1 3.0 4.9 1.8 virginica 0.5000 #&gt; 129 6.4 2.8 5.6 2.1 virginica 0.4167 #&gt; 130 7.2 3.0 5.8 1.6 virginica 0.1944 #&gt; 131 7.4 2.8 6.1 1.9 virginica 0.1389 #&gt; 132 7.9 3.8 6.4 2.0 virginica 0.0000 #&gt; 133 6.4 2.8 5.6 2.2 virginica 0.4167 #&gt; 134 6.3 2.8 5.1 1.5 virginica 0.4444 #&gt; 135 6.1 2.6 5.6 1.4 virginica 0.5000 #&gt; 136 7.7 3.0 6.1 2.3 virginica 0.0556 #&gt; 137 6.3 3.4 5.6 2.4 virginica 0.4444 #&gt; 138 6.4 3.1 5.5 1.8 virginica 0.4167 #&gt; 139 6.0 3.0 4.8 1.8 virginica 0.5278 #&gt; 140 6.9 3.1 5.4 2.1 virginica 0.2778 #&gt; 141 6.7 3.1 5.6 2.4 virginica 0.3333 #&gt; 142 6.9 3.1 5.1 2.3 virginica 0.2778 #&gt; 143 5.8 2.7 5.1 1.9 virginica 0.5833 #&gt; 144 6.8 3.2 5.9 2.3 virginica 0.3056 #&gt; 145 6.7 3.3 5.7 2.5 virginica 0.3333 #&gt; 146 6.7 3.0 5.2 2.3 virginica 0.3333 #&gt; 147 6.3 2.5 5.0 1.9 virginica 0.4444 #&gt; 148 6.5 3.0 5.2 2.0 virginica 0.3889 #&gt; 149 6.2 3.4 5.4 2.3 virginica 0.4722 #&gt; 150 5.9 3.0 5.1 1.8 virginica 0.5556 验证一下 scale.sl 变量的第一个值 (max(iris$Sepal.Length) - 5.1) / (max(iris$Sepal.Length) - min(iris$Sepal.Length)) #&gt; [1] 0.778 Warning: This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting arithmetic functions, and in particular the non-standard evaluation of argument transform can have unanticipated consequences. 7.4 提取子集 subset(x, subset, select, drop = FALSE, ...) 参数 subset代表行操作，select 代表列操作，函数 subset 从数据框中提取部分数据 subset(iris, Species == &quot;virginica&quot;) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 102 5.8 2.7 5.1 1.9 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 107 4.9 2.5 4.5 1.7 virginica #&gt; 108 7.3 2.9 6.3 1.8 virginica #&gt; 109 6.7 2.5 5.8 1.8 virginica #&gt; 110 7.2 3.6 6.1 2.5 virginica #&gt; 111 6.5 3.2 5.1 2.0 virginica #&gt; 112 6.4 2.7 5.3 1.9 virginica #&gt; 113 6.8 3.0 5.5 2.1 virginica #&gt; 114 5.7 2.5 5.0 2.0 virginica #&gt; 115 5.8 2.8 5.1 2.4 virginica #&gt; 116 6.4 3.2 5.3 2.3 virginica #&gt; 117 6.5 3.0 5.5 1.8 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 120 6.0 2.2 5.0 1.5 virginica #&gt; 121 6.9 3.2 5.7 2.3 virginica #&gt; 122 5.6 2.8 4.9 2.0 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 124 6.3 2.7 4.9 1.8 virginica #&gt; 125 6.7 3.3 5.7 2.1 virginica #&gt; 126 7.2 3.2 6.0 1.8 virginica #&gt; 127 6.2 2.8 4.8 1.8 virginica #&gt; 128 6.1 3.0 4.9 1.8 virginica #&gt; 129 6.4 2.8 5.6 2.1 virginica #&gt; 130 7.2 3.0 5.8 1.6 virginica #&gt; 131 7.4 2.8 6.1 1.9 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 133 6.4 2.8 5.6 2.2 virginica #&gt; 134 6.3 2.8 5.1 1.5 virginica #&gt; 135 6.1 2.6 5.6 1.4 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica #&gt; 137 6.3 3.4 5.6 2.4 virginica #&gt; 138 6.4 3.1 5.5 1.8 virginica #&gt; 139 6.0 3.0 4.8 1.8 virginica #&gt; 140 6.9 3.1 5.4 2.1 virginica #&gt; 141 6.7 3.1 5.6 2.4 virginica #&gt; 142 6.9 3.1 5.1 2.3 virginica #&gt; 143 5.8 2.7 5.1 1.9 virginica #&gt; 144 6.8 3.2 5.9 2.3 virginica #&gt; 145 6.7 3.3 5.7 2.5 virginica #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica # summary(iris$Sepal.Length) mean(iris$Sepal.Length) # 且的逻辑 # subset(iris, Species == &quot;virginica&quot; &amp; Sepal.Length &gt; 5.84333) subset(iris, Species == &quot;virginica&quot; &amp; Sepal.Length &gt; mean(Sepal.Length)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 108 7.3 2.9 6.3 1.8 virginica #&gt; 109 6.7 2.5 5.8 1.8 virginica #&gt; 110 7.2 3.6 6.1 2.5 virginica #&gt; 111 6.5 3.2 5.1 2.0 virginica #&gt; 112 6.4 2.7 5.3 1.9 virginica #&gt; 113 6.8 3.0 5.5 2.1 virginica #&gt; 116 6.4 3.2 5.3 2.3 virginica #&gt; 117 6.5 3.0 5.5 1.8 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 120 6.0 2.2 5.0 1.5 virginica #&gt; 121 6.9 3.2 5.7 2.3 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 124 6.3 2.7 4.9 1.8 virginica #&gt; 125 6.7 3.3 5.7 2.1 virginica #&gt; 126 7.2 3.2 6.0 1.8 virginica #&gt; 127 6.2 2.8 4.8 1.8 virginica #&gt; 128 6.1 3.0 4.9 1.8 virginica #&gt; 129 6.4 2.8 5.6 2.1 virginica #&gt; 130 7.2 3.0 5.8 1.6 virginica #&gt; 131 7.4 2.8 6.1 1.9 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 133 6.4 2.8 5.6 2.2 virginica #&gt; 134 6.3 2.8 5.1 1.5 virginica #&gt; 135 6.1 2.6 5.6 1.4 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica #&gt; 137 6.3 3.4 5.6 2.4 virginica #&gt; 138 6.4 3.1 5.5 1.8 virginica #&gt; 139 6.0 3.0 4.8 1.8 virginica #&gt; 140 6.9 3.1 5.4 2.1 virginica #&gt; 141 6.7 3.1 5.6 2.4 virginica #&gt; 142 6.9 3.1 5.1 2.3 virginica #&gt; 144 6.8 3.2 5.9 2.3 virginica #&gt; 145 6.7 3.3 5.7 2.5 virginica #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica # 在行的子集范围内 subset(iris, Species %in% c(&quot;virginica&quot;, &quot;versicolor&quot;) &amp; Sepal.Length &gt; mean(Sepal.Length)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 51 7.0 3.2 4.7 1.4 versicolor #&gt; 52 6.4 3.2 4.5 1.5 versicolor #&gt; 53 6.9 3.1 4.9 1.5 versicolor #&gt; 55 6.5 2.8 4.6 1.5 versicolor #&gt; 57 6.3 3.3 4.7 1.6 versicolor #&gt; 59 6.6 2.9 4.6 1.3 versicolor #&gt; 62 5.9 3.0 4.2 1.5 versicolor #&gt; 63 6.0 2.2 4.0 1.0 versicolor #&gt; 64 6.1 2.9 4.7 1.4 versicolor #&gt; 66 6.7 3.1 4.4 1.4 versicolor #&gt; 69 6.2 2.2 4.5 1.5 versicolor #&gt; 71 5.9 3.2 4.8 1.8 versicolor #&gt; 72 6.1 2.8 4.0 1.3 versicolor #&gt; 73 6.3 2.5 4.9 1.5 versicolor #&gt; 74 6.1 2.8 4.7 1.2 versicolor #&gt; 75 6.4 2.9 4.3 1.3 versicolor #&gt; 76 6.6 3.0 4.4 1.4 versicolor #&gt; 77 6.8 2.8 4.8 1.4 versicolor #&gt; 78 6.7 3.0 5.0 1.7 versicolor #&gt; 79 6.0 2.9 4.5 1.5 versicolor #&gt; 84 6.0 2.7 5.1 1.6 versicolor #&gt; 86 6.0 3.4 4.5 1.6 versicolor #&gt; 87 6.7 3.1 4.7 1.5 versicolor #&gt; 88 6.3 2.3 4.4 1.3 versicolor #&gt; 92 6.1 3.0 4.6 1.4 versicolor #&gt; 98 6.2 2.9 4.3 1.3 versicolor #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 108 7.3 2.9 6.3 1.8 virginica #&gt; 109 6.7 2.5 5.8 1.8 virginica #&gt; 110 7.2 3.6 6.1 2.5 virginica #&gt; 111 6.5 3.2 5.1 2.0 virginica #&gt; 112 6.4 2.7 5.3 1.9 virginica #&gt; 113 6.8 3.0 5.5 2.1 virginica #&gt; 116 6.4 3.2 5.3 2.3 virginica #&gt; 117 6.5 3.0 5.5 1.8 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 120 6.0 2.2 5.0 1.5 virginica #&gt; 121 6.9 3.2 5.7 2.3 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 124 6.3 2.7 4.9 1.8 virginica #&gt; 125 6.7 3.3 5.7 2.1 virginica #&gt; 126 7.2 3.2 6.0 1.8 virginica #&gt; 127 6.2 2.8 4.8 1.8 virginica #&gt; 128 6.1 3.0 4.9 1.8 virginica #&gt; 129 6.4 2.8 5.6 2.1 virginica #&gt; 130 7.2 3.0 5.8 1.6 virginica #&gt; 131 7.4 2.8 6.1 1.9 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 133 6.4 2.8 5.6 2.2 virginica #&gt; 134 6.3 2.8 5.1 1.5 virginica #&gt; 135 6.1 2.6 5.6 1.4 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica #&gt; 137 6.3 3.4 5.6 2.4 virginica #&gt; 138 6.4 3.1 5.5 1.8 virginica #&gt; 139 6.0 3.0 4.8 1.8 virginica #&gt; 140 6.9 3.1 5.4 2.1 virginica #&gt; 141 6.7 3.1 5.6 2.4 virginica #&gt; 142 6.9 3.1 5.1 2.3 virginica #&gt; 144 6.8 3.2 5.9 2.3 virginica #&gt; 145 6.7 3.3 5.7 2.5 virginica #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica # 在列的子集内 先选中列 subset(iris, Sepal.Length &gt; mean(Sepal.Length), select = c(&quot;Sepal.Length&quot;, &quot;Species&quot;) ) #&gt; Sepal.Length Species #&gt; 51 7.0 versicolor #&gt; 52 6.4 versicolor #&gt; 53 6.9 versicolor #&gt; 55 6.5 versicolor #&gt; 57 6.3 versicolor #&gt; 59 6.6 versicolor #&gt; 62 5.9 versicolor #&gt; 63 6.0 versicolor #&gt; 64 6.1 versicolor #&gt; 66 6.7 versicolor #&gt; 69 6.2 versicolor #&gt; 71 5.9 versicolor #&gt; 72 6.1 versicolor #&gt; 73 6.3 versicolor #&gt; 74 6.1 versicolor #&gt; 75 6.4 versicolor #&gt; 76 6.6 versicolor #&gt; 77 6.8 versicolor #&gt; 78 6.7 versicolor #&gt; 79 6.0 versicolor #&gt; 84 6.0 versicolor #&gt; 86 6.0 versicolor #&gt; 87 6.7 versicolor #&gt; 88 6.3 versicolor #&gt; 92 6.1 versicolor #&gt; 98 6.2 versicolor #&gt; 101 6.3 virginica #&gt; 103 7.1 virginica #&gt; 104 6.3 virginica #&gt; 105 6.5 virginica #&gt; 106 7.6 virginica #&gt; 108 7.3 virginica #&gt; 109 6.7 virginica #&gt; 110 7.2 virginica #&gt; 111 6.5 virginica #&gt; 112 6.4 virginica #&gt; 113 6.8 virginica #&gt; 116 6.4 virginica #&gt; 117 6.5 virginica #&gt; 118 7.7 virginica #&gt; 119 7.7 virginica #&gt; 120 6.0 virginica #&gt; 121 6.9 virginica #&gt; 123 7.7 virginica #&gt; 124 6.3 virginica #&gt; 125 6.7 virginica #&gt; 126 7.2 virginica #&gt; 127 6.2 virginica #&gt; 128 6.1 virginica #&gt; 129 6.4 virginica #&gt; 130 7.2 virginica #&gt; 131 7.4 virginica #&gt; 132 7.9 virginica #&gt; 133 6.4 virginica #&gt; 134 6.3 virginica #&gt; 135 6.1 virginica #&gt; 136 7.7 virginica #&gt; 137 6.3 virginica #&gt; 138 6.4 virginica #&gt; 139 6.0 virginica #&gt; 140 6.9 virginica #&gt; 141 6.7 virginica #&gt; 142 6.9 virginica #&gt; 144 6.8 virginica #&gt; 145 6.7 virginica #&gt; 146 6.7 virginica #&gt; 147 6.3 virginica #&gt; 148 6.5 virginica #&gt; 149 6.2 virginica #&gt; 150 5.9 virginica 高级操作：加入正则表达式筛选 ## sometimes requiring a logical &#39;subset&#39; argument is a nuisance nm &lt;- rownames(state.x77) start_with_M &lt;- nm %in% grep(&quot;^M&quot;, nm, value = TRUE) subset(state.x77, start_with_M, Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.4 2.7 #&gt; Maryland 0.9 70.2 8.5 #&gt; Massachusetts 1.1 71.8 3.3 #&gt; Michigan 0.9 70.6 11.1 #&gt; Minnesota 0.6 73.0 2.3 #&gt; Mississippi 2.4 68.1 12.5 #&gt; Missouri 0.8 70.7 9.3 #&gt; Montana 0.6 70.6 5.0 # 简化 # subset(state.x77, subset = grepl(&quot;^M&quot;, rownames(state.x77)), select = Illiteracy:Murder) # 继续简化 subset(state.x77, grepl(&quot;^M&quot;, rownames(state.x77)), Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.4 2.7 #&gt; Maryland 0.9 70.2 8.5 #&gt; Massachusetts 1.1 71.8 3.3 #&gt; Michigan 0.9 70.6 11.1 #&gt; Minnesota 0.6 73.0 2.3 #&gt; Mississippi 2.4 68.1 12.5 #&gt; Missouri 0.8 70.7 9.3 #&gt; Montana 0.6 70.6 5.0 警告：这是一个为了交互使用打造的便捷函数。对于编程，最好使用标准的子集函数，如 [，特别地，参数 subset 的非标准计算(non-standard evaluation)13 可能带来意想不到的后果。 使用索引 [ iris[iris$Species == &quot;virginica&quot;, ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 102 5.8 2.7 5.1 1.9 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 107 4.9 2.5 4.5 1.7 virginica #&gt; 108 7.3 2.9 6.3 1.8 virginica #&gt; 109 6.7 2.5 5.8 1.8 virginica #&gt; 110 7.2 3.6 6.1 2.5 virginica #&gt; 111 6.5 3.2 5.1 2.0 virginica #&gt; 112 6.4 2.7 5.3 1.9 virginica #&gt; 113 6.8 3.0 5.5 2.1 virginica #&gt; 114 5.7 2.5 5.0 2.0 virginica #&gt; 115 5.8 2.8 5.1 2.4 virginica #&gt; 116 6.4 3.2 5.3 2.3 virginica #&gt; 117 6.5 3.0 5.5 1.8 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 120 6.0 2.2 5.0 1.5 virginica #&gt; 121 6.9 3.2 5.7 2.3 virginica #&gt; 122 5.6 2.8 4.9 2.0 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 124 6.3 2.7 4.9 1.8 virginica #&gt; 125 6.7 3.3 5.7 2.1 virginica #&gt; 126 7.2 3.2 6.0 1.8 virginica #&gt; 127 6.2 2.8 4.8 1.8 virginica #&gt; 128 6.1 3.0 4.9 1.8 virginica #&gt; 129 6.4 2.8 5.6 2.1 virginica #&gt; 130 7.2 3.0 5.8 1.6 virginica #&gt; 131 7.4 2.8 6.1 1.9 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 133 6.4 2.8 5.6 2.2 virginica #&gt; 134 6.3 2.8 5.1 1.5 virginica #&gt; 135 6.1 2.6 5.6 1.4 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica #&gt; 137 6.3 3.4 5.6 2.4 virginica #&gt; 138 6.4 3.1 5.5 1.8 virginica #&gt; 139 6.0 3.0 4.8 1.8 virginica #&gt; 140 6.9 3.1 5.4 2.1 virginica #&gt; 141 6.7 3.1 5.6 2.4 virginica #&gt; 142 6.9 3.1 5.1 2.3 virginica #&gt; 143 5.8 2.7 5.1 1.9 virginica #&gt; 144 6.8 3.2 5.9 2.3 virginica #&gt; 145 6.7 3.3 5.7 2.5 virginica #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica iris[iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; mean(iris$Sepal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica #&gt; 108 7.3 2.9 6.3 1.8 virginica #&gt; 109 6.7 2.5 5.8 1.8 virginica #&gt; 110 7.2 3.6 6.1 2.5 virginica #&gt; 111 6.5 3.2 5.1 2.0 virginica #&gt; 112 6.4 2.7 5.3 1.9 virginica #&gt; 113 6.8 3.0 5.5 2.1 virginica #&gt; 116 6.4 3.2 5.3 2.3 virginica #&gt; 117 6.5 3.0 5.5 1.8 virginica #&gt; 118 7.7 3.8 6.7 2.2 virginica #&gt; 119 7.7 2.6 6.9 2.3 virginica #&gt; 120 6.0 2.2 5.0 1.5 virginica #&gt; 121 6.9 3.2 5.7 2.3 virginica #&gt; 123 7.7 2.8 6.7 2.0 virginica #&gt; 124 6.3 2.7 4.9 1.8 virginica #&gt; 125 6.7 3.3 5.7 2.1 virginica #&gt; 126 7.2 3.2 6.0 1.8 virginica #&gt; 127 6.2 2.8 4.8 1.8 virginica #&gt; 128 6.1 3.0 4.9 1.8 virginica #&gt; 129 6.4 2.8 5.6 2.1 virginica #&gt; 130 7.2 3.0 5.8 1.6 virginica #&gt; 131 7.4 2.8 6.1 1.9 virginica #&gt; 132 7.9 3.8 6.4 2.0 virginica #&gt; 133 6.4 2.8 5.6 2.2 virginica #&gt; 134 6.3 2.8 5.1 1.5 virginica #&gt; 135 6.1 2.6 5.6 1.4 virginica #&gt; 136 7.7 3.0 6.1 2.3 virginica #&gt; 137 6.3 3.4 5.6 2.4 virginica #&gt; 138 6.4 3.1 5.5 1.8 virginica #&gt; 139 6.0 3.0 4.8 1.8 virginica #&gt; 140 6.9 3.1 5.4 2.1 virginica #&gt; 141 6.7 3.1 5.6 2.4 virginica #&gt; 142 6.9 3.1 5.1 2.3 virginica #&gt; 144 6.8 3.2 5.9 2.3 virginica #&gt; 145 6.7 3.3 5.7 2.5 virginica #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica iris[ iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; mean(iris$Sepal.Length), c(&quot;Sepal.Length&quot;, &quot;Species&quot;) ] #&gt; Sepal.Length Species #&gt; 101 6.3 virginica #&gt; 103 7.1 virginica #&gt; 104 6.3 virginica #&gt; 105 6.5 virginica #&gt; 106 7.6 virginica #&gt; 108 7.3 virginica #&gt; 109 6.7 virginica #&gt; 110 7.2 virginica #&gt; 111 6.5 virginica #&gt; 112 6.4 virginica #&gt; 113 6.8 virginica #&gt; 116 6.4 virginica #&gt; 117 6.5 virginica #&gt; 118 7.7 virginica #&gt; 119 7.7 virginica #&gt; 120 6.0 virginica #&gt; 121 6.9 virginica #&gt; 123 7.7 virginica #&gt; 124 6.3 virginica #&gt; 125 6.7 virginica #&gt; 126 7.2 virginica #&gt; 127 6.2 virginica #&gt; 128 6.1 virginica #&gt; 129 6.4 virginica #&gt; 130 7.2 virginica #&gt; 131 7.4 virginica #&gt; 132 7.9 virginica #&gt; 133 6.4 virginica #&gt; 134 6.3 virginica #&gt; 135 6.1 virginica #&gt; 136 7.7 virginica #&gt; 137 6.3 virginica #&gt; 138 6.4 virginica #&gt; 139 6.0 virginica #&gt; 140 6.9 virginica #&gt; 141 6.7 virginica #&gt; 142 6.9 virginica #&gt; 144 6.8 virginica #&gt; 145 6.7 virginica #&gt; 146 6.7 virginica #&gt; 147 6.3 virginica #&gt; 148 6.5 virginica #&gt; 149 6.2 virginica #&gt; 150 5.9 virginica 7.5 按列排序 在数据框内，根据(order)某一列或几列对行进行排序(sort)，根据鸢尾花(iris)的类别(Species)对萼片(sepal)的长度进行排序，其余的列随之变化 # 对萼片的长度排序 iris[order(iris$Species, iris$Sepal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 39 4.4 3.0 1.3 0.2 setosa #&gt; 43 4.4 3.2 1.3 0.2 setosa #&gt; 42 4.5 2.3 1.3 0.3 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 7 4.6 3.4 1.4 0.3 setosa #&gt; 23 4.6 3.6 1.0 0.2 setosa #&gt; 48 4.6 3.2 1.4 0.2 setosa .... # 对花瓣的长度排序 iris[order(iris$Species, iris$Petal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 23 4.6 3.6 1.0 0.2 setosa #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 15 5.8 4.0 1.2 0.2 setosa #&gt; 36 5.0 3.2 1.2 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 17 5.4 3.9 1.3 0.4 setosa #&gt; 37 5.5 3.5 1.3 0.2 setosa #&gt; 39 4.4 3.0 1.3 0.2 setosa #&gt; 41 5.0 3.5 1.3 0.3 setosa .... # 先对花瓣的宽度排序，再对花瓣的长度排序 iris[order(iris$Petal.Width, iris$Petal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 13 4.8 3.0 1.4 0.1 setosa #&gt; 38 4.9 3.6 1.4 0.1 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; 33 5.2 4.1 1.5 0.1 setosa #&gt; 23 4.6 3.6 1.0 0.2 setosa #&gt; 15 5.8 4.0 1.2 0.2 setosa #&gt; 36 5.0 3.2 1.2 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa .... sort/ordered 排序， 默认是升序 dd &lt;- data.frame( b = factor(c(&quot;Hi&quot;, &quot;Med&quot;, &quot;Hi&quot;, &quot;Low&quot;), levels = c(&quot;Low&quot;, &quot;Med&quot;, &quot;Hi&quot;), ordered = TRUE ), x = c(&quot;A&quot;, &quot;D&quot;, &quot;A&quot;, &quot;C&quot;), y = c(8, 3, 9, 9), z = c(1, 1, 1, 2) ) str(dd) #&gt; &#39;data.frame&#39;: 4 obs. of 4 variables: #&gt; $ b: Ord.factor w/ 3 levels &quot;Low&quot;&lt;&quot;Med&quot;&lt;&quot;Hi&quot;: 3 2 3 1 #&gt; $ x: chr &quot;A&quot; &quot;D&quot; &quot;A&quot; &quot;C&quot; #&gt; $ y: num 8 3 9 9 #&gt; $ z: num 1 1 1 2 dd[order(-dd[,4], dd[,1]), ] #&gt; b x y z #&gt; 4 Low C 9 2 #&gt; 2 Med D 3 1 #&gt; 1 Hi A 8 1 #&gt; 3 Hi A 9 1 根据变量 z dd[order(dd$z, dd$b), ] #&gt; b x y z #&gt; 2 Med D 3 1 #&gt; 1 Hi A 8 1 #&gt; 3 Hi A 9 1 #&gt; 4 Low C 9 2 7.6 数据拆分 数据拆分通常是按找某一个分类变量分组，分完组就是计算，计算完就把结果按照原来的分组方式合并 ## Notice that assignment form is not used since a variable is being added g &lt;- airquality$Month l &lt;- split(airquality, g) # 分组 l &lt;- lapply(l, transform, Oz.Z = scale(Ozone)) # 计算：按月对 Ozone 标准化 aq2 &lt;- unsplit(l, g) # 合并 head(aq2) #&gt; Ozone Solar.R Wind Temp Month Day Oz.Z #&gt; 1 41 190 7.4 67 5 1 0.782 #&gt; 2 36 118 8.0 72 5 2 0.557 #&gt; 3 12 149 12.6 74 5 3 -0.523 #&gt; 4 18 313 11.5 62 5 4 -0.253 #&gt; 5 NA NA 14.3 56 5 5 NA #&gt; 6 28 NA 14.9 66 5 6 0.197 tapply 自带分组的功能，按月份 Month 对 Ozone 中心标准化，其返回一个列表 with(airquality, tapply(Ozone, Month, scale)) #&gt; $`5` #&gt; [,1] #&gt; [1,] 0.7822 #&gt; [2,] 0.5573 #&gt; [3,] -0.5226 #&gt; [4,] -0.2527 #&gt; [5,] NA #&gt; [6,] 0.1973 #&gt; [7,] -0.0277 #&gt; [8,] -0.2077 .... 上面的过程等价于 do.call(&quot;rbind&quot;, lapply(split(airquality, airquality$Month), transform, Oz.Z = scale(Ozone))) #&gt; Ozone Solar.R Wind Temp Month Day Oz.Z #&gt; 5.1 41 190 7.4 67 5 1 0.78223 #&gt; 5.2 36 118 8.0 72 5 2 0.55725 #&gt; 5.3 12 149 12.6 74 5 3 -0.52264 #&gt; 5.4 18 313 11.5 62 5 4 -0.25267 #&gt; 5.5 NA NA 14.3 56 5 5 NA #&gt; 5.6 28 NA 14.9 66 5 6 0.19729 #&gt; 5.7 23 299 8.6 65 5 7 -0.02769 #&gt; 5.8 19 99 13.8 59 5 8 -0.20767 #&gt; 5.9 8 19 20.1 61 5 9 -0.70262 .... 由于上面对 Ozone 正态标准化，所以标准化后的 Oz.z 再按月分组计算方差自然每个月都是 1，而均值都是 0。 with(aq2, tapply(Oz.Z, Month, sd, na.rm = TRUE)) #&gt; 5 6 7 8 9 #&gt; 1 1 1 1 1 with(aq2, tapply(Oz.Z, Month, mean, na.rm = TRUE)) #&gt; 5 6 7 8 9 #&gt; -4.24e-17 1.05e-16 5.84e-17 5.90e-17 2.57e-17 循着这个思路，我们可以用 tapply 实现分组计算，上面函数 sd 和 mean 完全可以用自定义的更加复杂的函数替代 cut 函数可以将连续型变量划分为分类变量 set.seed(2019) Z &lt;- stats::rnorm(10) cut(Z, breaks = -6:6) #&gt; [1] (0,1] (-1,0] (-2,-1] (0,1] (-2,-1] (0,1] (-1,0] (0,1] (-2,-1] #&gt; [10] (-1,0] #&gt; 12 Levels: (-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1] (-1,0] (0,1] ... (5,6] # labels = FALSE 返回每个数所落的区间位置 cut(Z, breaks = -6:6, labels = FALSE) #&gt; [1] 7 6 5 7 5 7 6 7 5 6 我们还可以指定参数 dig.lab 设置分组的精度，ordered 将分组变量看作是有序的，breaks 传递单个数时，表示分组数，而不是断点 cut(Z, breaks = 3, dig.lab = 4, ordered = TRUE) #&gt; [1] (0.06396,0.9186] (-0.7881,0.06396] (-1.643,-0.7881] (0.06396,0.9186] #&gt; [5] (-1.643,-0.7881] (0.06396,0.9186] (-0.7881,0.06396] (0.06396,0.9186] #&gt; [9] (-1.643,-0.7881] (-0.7881,0.06396] #&gt; Levels: (-1.643,-0.7881] &lt; (-0.7881,0.06396] &lt; (0.06396,0.9186] 此时，统计每组的频数，如图 7.1 # 条形图 plot(cut(Z, breaks = -6:6)) # 直方图 hist(Z, breaks = -6:6) 图 7.1: 连续型变量分组统计 在指定分组数的情况下，我们还想获取分组的断点 labs &lt;- levels(cut(Z, 3)) labs #&gt; [1] &quot;(-1.64,-0.788]&quot; &quot;(-0.788,0.064]&quot; &quot;(0.064,0.919]&quot; 用正则表达式抽取断点 cbind( lower = as.numeric(sub(&quot;\\\\((.+),.*&quot;, &quot;\\\\1&quot;, labs)), upper = as.numeric(sub(&quot;[^,]*,([^]]*)\\\\]&quot;, &quot;\\\\1&quot;, labs)) ) #&gt; lower upper #&gt; [1,] -1.640 -0.788 #&gt; [2,] -0.788 0.064 #&gt; [3,] 0.064 0.919 更多相关函数可以参考 findInterval 和 embed t(combn(8, 4, tabulate, nbins = 8)) 7.7 数据合并 merge 合并两个数据框 authors &lt;- data.frame( ## I(*) : use character columns of names to get sensible sort order surname = I(c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;)), nationality = c(&quot;US&quot;, &quot;Australia&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;), deceased = c(&quot;yes&quot;, rep(&quot;no&quot;, 4)) ) authorN &lt;- within(authors, { name &lt;- surname rm(surname) }) books &lt;- data.frame( name = I(c( &quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;, &quot;R Core&quot; )), title = c( &quot;Exploratory Data Analysis&quot;, &quot;Modern Applied Statistics ...&quot;, &quot;LISP-STAT&quot;, &quot;Spatial Statistics&quot;, &quot;Stochastic Simulation&quot;, &quot;Interactive Data Analysis&quot;, &quot;An Introduction to R&quot; ), other.author = c( NA, &quot;Ripley&quot;, NA, NA, NA, NA, &quot;Venables &amp; Smith&quot; ) ) authors #&gt; surname nationality deceased #&gt; 1 Tukey US yes #&gt; 2 Venables Australia no #&gt; 3 Tierney US no #&gt; 4 Ripley UK no #&gt; 5 McNeil Australia no authorN #&gt; nationality deceased name #&gt; 1 US yes Tukey #&gt; 2 Australia no Venables #&gt; 3 US no Tierney #&gt; 4 UK no Ripley #&gt; 5 Australia no McNeil books #&gt; name title other.author #&gt; 1 Tukey Exploratory Data Analysis &lt;NA&gt; #&gt; 2 Venables Modern Applied Statistics ... Ripley #&gt; 3 Tierney LISP-STAT &lt;NA&gt; #&gt; 4 Ripley Spatial Statistics &lt;NA&gt; #&gt; 5 Ripley Stochastic Simulation &lt;NA&gt; #&gt; 6 McNeil Interactive Data Analysis &lt;NA&gt; #&gt; 7 R Core An Introduction to R Venables &amp; Smith 默认找到同名的列，然后是同名的行合并，多余的没有匹配到的就丢掉 merge(authorN, books) #&gt; name nationality deceased title other.author #&gt; 1 McNeil Australia no Interactive Data Analysis &lt;NA&gt; #&gt; 2 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 3 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 4 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 5 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 6 Venables Australia no Modern Applied Statistics ... Ripley 还可以指定合并的列，先按照 surname 合并，留下 surname merge(authors, books, by.x = &quot;surname&quot;, by.y = &quot;name&quot;) #&gt; surname nationality deceased title other.author #&gt; 1 McNeil Australia no Interactive Data Analysis &lt;NA&gt; #&gt; 2 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 3 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 4 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 5 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 6 Venables Australia no Modern Applied Statistics ... Ripley 留下的是 name merge(books, authors, by.x = &quot;name&quot;, by.y = &quot;surname&quot;) #&gt; name title other.author nationality deceased #&gt; 1 McNeil Interactive Data Analysis &lt;NA&gt; Australia no #&gt; 2 Ripley Spatial Statistics &lt;NA&gt; UK no #&gt; 3 Ripley Stochastic Simulation &lt;NA&gt; UK no #&gt; 4 Tierney LISP-STAT &lt;NA&gt; US no #&gt; 5 Tukey Exploratory Data Analysis &lt;NA&gt; US yes #&gt; 6 Venables Modern Applied Statistics ... Ripley Australia no 为了比较清楚地观察几种合并的区别，这里提供对应的动画展示 https://github.com/gadenbuie/tidyexplain cbind rbind left join right join 7.8 数据去重 单个数值型向量去重，此时和 unique 函数作用一样 (x &lt;- c(9:20, 1:5, 3:7, 0:8)) #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 3 4 5 6 7 0 1 2 #&gt; [26] 3 4 5 6 7 8 ## extract unique elements x[!duplicated(x)] #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 0 8 unique(x) #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 0 8 数据框类型数据中，去除重复的行，这个重复可以是多个变量对应的向量 set.seed(123) df &lt;- data.frame( x = sample(0:1, 10, replace = T), y = sample(0:1, 10, replace = T), z = 1:10 ) df #&gt; x y z #&gt; 1 0 1 1 #&gt; 2 0 1 2 #&gt; 3 0 1 3 #&gt; 4 1 0 4 #&gt; 5 0 1 5 #&gt; 6 1 0 6 #&gt; 7 1 1 7 #&gt; 8 1 0 8 #&gt; 9 0 0 9 #&gt; 10 0 0 10 df[!duplicated(df[, 1:2]), ] #&gt; x y z #&gt; 1 0 1 1 #&gt; 4 1 0 4 #&gt; 7 1 1 7 #&gt; 9 0 0 9 数据去重在 dplyr 中的实现14。 library(dplyr) df %&gt;% group_by(x, y) %&gt;% filter(row_number(z) == 1) #&gt; # A tibble: 4 x 3 #&gt; # Groups: x, y [4] #&gt; x y z #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 0 1 1 #&gt; 2 1 0 4 #&gt; 3 1 1 7 #&gt; 4 0 0 9 7.9 数据聚合 主要是分组统计 apropos(&quot;apply&quot;) #&gt; [1] &quot;apply&quot; &quot;dendrapply&quot; &quot;eapply&quot; &quot;kernapply&quot; &quot;lapply&quot; #&gt; [6] &quot;mapply&quot; &quot;rapply&quot; &quot;sapply&quot; &quot;tapply&quot; &quot;vapply&quot; # 分组求和 colSums colMeans max unique(iris$Species) #&gt; [1] setosa versicolor virginica #&gt; Levels: setosa versicolor virginica # 分类求和 # colSums(iris[iris$Species == &quot;setosa&quot;, -5]) # colSums(iris[iris$Species == &quot;virginica&quot;, -5]) colSums(iris[iris$Species == &quot;versicolor&quot;, -5]) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 296.8 138.5 213.0 66.3 # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, sum) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, mean) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, min) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, max) apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, quantile) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 0% 4.3 2.30 1.00 0.1 #&gt; 25% 4.8 3.20 1.40 0.2 #&gt; 50% 5.0 3.40 1.50 0.2 #&gt; 75% 5.2 3.68 1.58 0.3 #&gt; 100% 5.8 4.40 1.90 0.6 aggregate: Compute Summary Statistics of Data Subsets # 按分类变量 Species 分组求和 # aggregate(subset(iris, select = -Species), by = list(iris[, &quot;Species&quot;]), FUN = sum) aggregate(iris[, -5], list(iris[, 5]), sum) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 250 171 73.1 12.3 #&gt; 2 versicolor 297 138 213.0 66.3 #&gt; 3 virginica 329 149 277.6 101.3 # 先确定位置，假设有很多分类变量 ind &lt;- which(&quot;Species&quot; == colnames(iris)) # 分组统计 aggregate(iris[, -ind], list(iris[, ind]), sum) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 250 171 73.1 12.3 #&gt; 2 versicolor 297 138 213.0 66.3 #&gt; 3 virginica 329 149 277.6 101.3 按照 Species 划分的类别，分组计算，使用公式表示形式，右边一定是分类变量，否则会报错误或者警告，输出奇怪的结果，请读者尝试运行aggregate(Species ~ Sepal.Length, data = iris, mean)。公式法表示分组计算，~ 左手边可以做加 + 减 - 乘 * 除 / 取余 %% 等数学运算。下面以数据集 iris 为例，只对 Sepal.Length 按 Species 分组计算 aggregate(Sepal.Length ~ Species, data = iris, mean) #&gt; Species Sepal.Length #&gt; 1 setosa 5.01 #&gt; 2 versicolor 5.94 #&gt; 3 virginica 6.59 与上述分组统计结果一样的命令，在大数据集上， 与 aggregate 相比，tapply 要快很多，by 是 tapply 的包裹，处理速度差不多。读者可以构造伪随机数据集验证。 # tapply(iris$Sepal.Length, list(iris$Species), mean) with(iris, tapply(Sepal.Length, Species, mean)) #&gt; setosa versicolor virginica #&gt; 5.01 5.94 6.59 by(iris$Sepal.Length, iris$Species, mean) #&gt; iris$Species: setosa #&gt; [1] 5.01 #&gt; ----------------------------------------------------------- #&gt; iris$Species: versicolor #&gt; [1] 5.94 #&gt; ----------------------------------------------------------- #&gt; iris$Species: virginica #&gt; [1] 6.59 对所有变量按 Species 分组计算 aggregate(. ~ Species, data = iris, mean) #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.01 3.43 1.46 0.246 #&gt; 2 versicolor 5.94 2.77 4.26 1.326 #&gt; 3 virginica 6.59 2.97 5.55 2.026 对变量 Sepal.Length 和 Sepal.Width 求和后，按 Species 分组计算 aggregate(Sepal.Length + Sepal.Width ~ Species, data = iris, mean) #&gt; Species Sepal.Length + Sepal.Width #&gt; 1 setosa 8.43 #&gt; 2 versicolor 8.71 #&gt; 3 virginica 9.56 对多个分类变量做分组计算，在数据集 ChickWeight 中 Chick和Diet都是数字编码的分类变量，其中 Chick 是有序的因子变量，Diet 是无序的因子变量，而 Time 是数值型的变量，表示小鸡出生的天数。 # 查看数据 str(ChickWeight) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 578 obs. of 4 variables: #&gt; $ weight: num 42 51 59 64 76 93 106 125 149 171 ... #&gt; $ Time : num 0 2 4 6 8 10 12 14 16 18 ... #&gt; $ Chick : Ord.factor w/ 50 levels &quot;18&quot;&lt;&quot;16&quot;&lt;&quot;15&quot;&lt;..: 15 15 15 15 15 15 15 15.. #&gt; $ Diet : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language weight ~ Time | Chick #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Diet #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Time&quot; #&gt; ..$ y: chr &quot;Body weight&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(days)&quot; #&gt; ..$ y: chr &quot;(gm)&quot; 查看数据集ChickWeight的前几行 # head(ChickWeight) ChickWeight #&gt; Grouped Data: weight ~ Time | Chick #&gt; weight Time Chick Diet #&gt; 1 42 0 1 1 #&gt; 2 51 2 1 1 #&gt; 3 59 4 1 1 #&gt; 4 64 6 1 1 .... 对于数据集ChickWeight中的有序变量Chick，aggregate 会按照既定顺序返回分组计算的结果 aggregate(weight ~ Chick, data = ChickWeight, mean) #&gt; Chick weight #&gt; 1 18 37.0 #&gt; 2 16 49.7 #&gt; 3 15 60.1 #&gt; 4 13 67.8 #&gt; 5 9 81.2 .... aggregate(weight ~ Diet, data = ChickWeight, mean) #&gt; Diet weight #&gt; 1 1 103 #&gt; 2 2 123 #&gt; 3 3 143 #&gt; 4 4 135 分类变量没有用数字编码，以 CO2 数据集为例，该数据集描述草植对二氧化碳的吸收情况，Plant 是具有12个水平的有序的因子变量，Type表示植物的源头分别是魁北克(Quebec)和密西西比(Mississippi)，Treatment表示冷却(chilled)和不冷却(nonchilled)两种处理方式，conc表示周围环境中二氧化碳的浓度，uptake表示植物吸收二氧化碳的速率。 # 查看数据集 head(CO2) #&gt; Grouped Data: uptake ~ conc | Plant #&gt; Plant Type Treatment conc uptake #&gt; 1 Qn1 Quebec nonchilled 95 16.0 #&gt; 2 Qn1 Quebec nonchilled 175 30.4 #&gt; 3 Qn1 Quebec nonchilled 250 34.8 #&gt; 4 Qn1 Quebec nonchilled 350 37.2 #&gt; 5 Qn1 Quebec nonchilled 500 35.3 #&gt; 6 Qn1 Quebec nonchilled 675 39.2 str(CO2) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 84 obs. of 5 variables: #&gt; $ Plant : Ord.factor w/ 12 levels &quot;Qn1&quot;&lt;&quot;Qn2&quot;&lt;&quot;Qn3&quot;&lt;..: 1 1 1 1 1 1 1 2 2.. #&gt; $ Type : Factor w/ 2 levels &quot;Quebec&quot;,&quot;Mississippi&quot;: 1 1 1 1 1 1 1 1 1 1 .. #&gt; $ Treatment: Factor w/ 2 levels &quot;nonchilled&quot;,&quot;chilled&quot;: 1 1 1 1 1 1 1 1 1 1 .. #&gt; $ conc : num 95 175 250 350 500 675 1000 95 175 250 ... #&gt; $ uptake : num 16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language uptake ~ conc | Plant #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Treatment * Type #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Ambient carbon dioxide concentration&quot; #&gt; ..$ y: chr &quot;CO2 uptake rate&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(uL/L)&quot; #&gt; ..$ y: chr &quot;(umol/m^2 s)&quot; 对单个变量分组统计 aggregate(uptake ~ Plant, data = CO2, mean) #&gt; Plant uptake #&gt; 1 Qn1 33.2 #&gt; 2 Qn2 35.2 #&gt; 3 Qn3 37.6 #&gt; 4 Qc1 30.0 #&gt; 5 Qc3 32.6 #&gt; 6 Qc2 32.7 #&gt; 7 Mn3 24.1 #&gt; 8 Mn2 27.3 #&gt; 9 Mn1 26.4 #&gt; 10 Mc2 12.1 #&gt; 11 Mc3 17.3 #&gt; 12 Mc1 18.0 aggregate(uptake ~ Type, data = CO2, mean) #&gt; Type uptake #&gt; 1 Quebec 33.5 #&gt; 2 Mississippi 20.9 aggregate(uptake ~ Treatment, data = CO2, mean) #&gt; Treatment uptake #&gt; 1 nonchilled 30.6 #&gt; 2 chilled 23.8 对多个变量分组统计，查看二氧化碳吸收速率uptake随类型Type和处理方式Treatment aggregate(uptake ~ Type + Treatment, data = CO2, mean) #&gt; Type Treatment uptake #&gt; 1 Quebec nonchilled 35.3 #&gt; 2 Mississippi nonchilled 26.0 #&gt; 3 Quebec chilled 31.8 #&gt; 4 Mississippi chilled 15.8 tapply(CO2$uptake, list(CO2$Type, CO2$Treatment), mean) #&gt; nonchilled chilled #&gt; Quebec 35.3 31.8 #&gt; Mississippi 26.0 15.8 by(CO2$uptake, list(CO2$Type, CO2$Treatment), mean) #&gt; : Quebec #&gt; : nonchilled #&gt; [1] 35.3 #&gt; ----------------------------------------------------------- #&gt; : Mississippi #&gt; : nonchilled #&gt; [1] 26 #&gt; ----------------------------------------------------------- #&gt; : Quebec #&gt; : chilled #&gt; [1] 31.8 #&gt; ----------------------------------------------------------- #&gt; : Mississippi #&gt; : chilled #&gt; [1] 15.8 在这个例子中 tapply 和 by 的输出结果的表示形式不一样，aggregate 返回一个 data.frame 数据框，tapply 返回一个表格 table，by 返回特殊的数据类型 by。 Function by is an object-oriented wrapper for tapply applied to data frames. # 分组求和 # by(iris[, 1], INDICES = list(iris$Species), FUN = sum) # by(iris[, 2], INDICES = list(iris$Species), FUN = sum) by(iris[, 3], INDICES = list(iris$Species), FUN = sum) #&gt; : setosa #&gt; [1] 73.1 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; [1] 213 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; [1] 278 by(iris[1:3], INDICES = list(iris$Species), FUN = sum) #&gt; : setosa #&gt; [1] 495 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; [1] 648 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; [1] 756 by(iris[1:3], INDICES = list(iris$Species), FUN = summary) #&gt; : setosa #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.30 Min. :2.30 Min. :1.00 #&gt; 1st Qu.:4.80 1st Qu.:3.20 1st Qu.:1.40 #&gt; Median :5.00 Median :3.40 Median :1.50 #&gt; Mean :5.01 Mean :3.43 Mean :1.46 #&gt; 3rd Qu.:5.20 3rd Qu.:3.67 3rd Qu.:1.57 #&gt; Max. :5.80 Max. :4.40 Max. :1.90 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.90 Min. :2.00 Min. :3.00 #&gt; 1st Qu.:5.60 1st Qu.:2.52 1st Qu.:4.00 #&gt; Median :5.90 Median :2.80 Median :4.35 #&gt; Mean :5.94 Mean :2.77 Mean :4.26 #&gt; 3rd Qu.:6.30 3rd Qu.:3.00 3rd Qu.:4.60 #&gt; Max. :7.00 Max. :3.40 Max. :5.10 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.90 Min. :2.20 Min. :4.50 #&gt; 1st Qu.:6.22 1st Qu.:2.80 1st Qu.:5.10 #&gt; Median :6.50 Median :3.00 Median :5.55 #&gt; Mean :6.59 Mean :2.97 Mean :5.55 #&gt; 3rd Qu.:6.90 3rd Qu.:3.17 3rd Qu.:5.88 #&gt; Max. :7.90 Max. :3.80 Max. :6.90 by(iris, INDICES = list(iris$Species), FUN = summary) #&gt; : setosa #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; Min. :4.30 Min. :2.30 Min. :1.00 Min. :0.100 setosa :50 #&gt; 1st Qu.:4.80 1st Qu.:3.20 1st Qu.:1.40 1st Qu.:0.200 versicolor: 0 #&gt; Median :5.00 Median :3.40 Median :1.50 Median :0.200 virginica : 0 #&gt; Mean :5.01 Mean :3.43 Mean :1.46 Mean :0.246 #&gt; 3rd Qu.:5.20 3rd Qu.:3.67 3rd Qu.:1.57 3rd Qu.:0.300 #&gt; Max. :5.80 Max. :4.40 Max. :1.90 Max. :0.600 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; Min. :4.90 Min. :2.00 Min. :3.00 Min. :1.00 setosa : 0 #&gt; 1st Qu.:5.60 1st Qu.:2.52 1st Qu.:4.00 1st Qu.:1.20 versicolor:50 #&gt; Median :5.90 Median :2.80 Median :4.35 Median :1.30 virginica : 0 #&gt; Mean :5.94 Mean :2.77 Mean :4.26 Mean :1.33 #&gt; 3rd Qu.:6.30 3rd Qu.:3.00 3rd Qu.:4.60 3rd Qu.:1.50 #&gt; Max. :7.00 Max. :3.40 Max. :5.10 Max. :1.80 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; Min. :4.90 Min. :2.20 Min. :4.50 Min. :1.40 setosa : 0 #&gt; 1st Qu.:6.22 1st Qu.:2.80 1st Qu.:5.10 1st Qu.:1.80 versicolor: 0 #&gt; Median :6.50 Median :3.00 Median :5.55 Median :2.00 virginica :50 #&gt; Mean :6.59 Mean :2.97 Mean :5.55 Mean :2.03 #&gt; 3rd Qu.:6.90 3rd Qu.:3.17 3rd Qu.:5.88 3rd Qu.:2.30 #&gt; Max. :7.90 Max. :3.80 Max. :6.90 Max. :2.50 Group Averages Over Level Combinations of Factors 分组平均 str(warpbreaks) #&gt; &#39;data.frame&#39;: 54 obs. of 3 variables: #&gt; $ breaks : num 26 30 54 25 70 52 51 26 67 18 ... #&gt; $ wool : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tension: Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;H&quot;: 1 1 1 1 1 1 1 1 1 2 ... ave(warpbreaks$breaks, warpbreaks$wool) #&gt; [1] 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 #&gt; [16] 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 31.0 25.3 25.3 25.3 #&gt; [31] 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 #&gt; [46] 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 25.3 warpbreaks %&gt;% head(5) #&gt; breaks wool tension #&gt; 1 26 A L #&gt; 2 30 A L #&gt; 3 54 A L #&gt; 4 25 A L #&gt; 5 70 A L with(warpbreaks, ave(breaks, tension, FUN = function(x) mean(x, trim = 0.1))) #&gt; [1] 35.7 35.7 35.7 35.7 35.7 35.7 35.7 35.7 35.7 26.3 26.3 26.3 26.3 26.3 26.3 #&gt; [16] 26.3 26.3 26.3 21.1 21.1 21.1 21.1 21.1 21.1 21.1 21.1 21.1 35.7 35.7 35.7 #&gt; [31] 35.7 35.7 35.7 35.7 35.7 35.7 26.3 26.3 26.3 26.3 26.3 26.3 26.3 26.3 26.3 #&gt; [46] 21.1 21.1 21.1 21.1 21.1 21.1 21.1 21.1 21.1 # 分组求和 with(warpbreaks, ave(breaks, tension, FUN = function(x) sum(x))) #&gt; [1] 655 655 655 655 655 655 655 655 655 475 475 475 475 475 475 475 475 475 #&gt; [19] 390 390 390 390 390 390 390 390 390 655 655 655 655 655 655 655 655 655 #&gt; [37] 475 475 475 475 475 475 475 475 475 390 390 390 390 390 390 390 390 390 # 分组求和 with(iris, ave(Sepal.Length, Species, FUN = function(x) sum(x))) #&gt; [1] 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 #&gt; [19] 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 250 #&gt; [37] 250 250 250 250 250 250 250 250 250 250 250 250 250 250 297 297 297 297 #&gt; [55] 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 #&gt; [73] 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 297 #&gt; [91] 297 297 297 297 297 297 297 297 297 297 329 329 329 329 329 329 329 329 #&gt; [109] 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 #&gt; [127] 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 329 #&gt; [145] 329 329 329 329 329 329 7.10 表格统计 介绍操作表格的 table, addmargins, prop.table, xtabs, margin.table, ftabe 等函数 table 多个分类变量分组计数统计 介绍 warpbreaks 和 airquality 纽约空气质量监测数据集 二维的数据框 UCBAdmissions 1973 年加州大学伯克利分校的院系录取数据集 3维的列联表 Titanic 4维的列联表数据 泰坦尼克号幸存者数据集 with(warpbreaks, table(wool, tension)) #&gt; tension #&gt; wool L M H #&gt; A 9 9 9 #&gt; B 9 9 9 以 iris 数据集为例，table 的第一个参数是自己制造的第二个分类变量，原始分类变量是 Species with(iris, table(Sepal.check = Sepal.Length &gt; 7, Species)) #&gt; Species #&gt; Sepal.check setosa versicolor virginica #&gt; FALSE 50 50 38 #&gt; TRUE 0 0 12 with(iris, table(Sepal.check = Sepal.Length &gt; mean(Sepal.Length), Species)) #&gt; Species #&gt; Sepal.check setosa versicolor virginica #&gt; FALSE 50 24 6 #&gt; TRUE 0 26 44 以 airquality 数据集为例，看看月份中臭氧含量比较高的几天 aiq.tab &lt;- with(airquality, table(Oz.high = Ozone &gt; 80, Month)) aiq.tab #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 25 9 20 19 27 #&gt; TRUE 1 0 6 7 2 对表格按行和列求和，即求表格的边际，查看总体情况 addmargins(aiq.tab, 1:2) #&gt; Month #&gt; Oz.high 5 6 7 8 9 Sum #&gt; FALSE 25 9 20 19 27 100 #&gt; TRUE 1 0 6 7 2 16 #&gt; Sum 26 9 26 26 29 116 臭氧含量超 80 的天数在每个月的占比，addmargins 的第二个参数 1 表示对列求和 aiq.prop &lt;- prop.table(aiq.tab, 2) aiq.prop #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 0.9615 1.0000 0.7692 0.7308 0.9310 #&gt; TRUE 0.0385 0.0000 0.2308 0.2692 0.0690 aiq.marprop &lt;- addmargins(aiq.prop, 1) aiq.marprop #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 0.9615 1.0000 0.7692 0.7308 0.9310 #&gt; TRUE 0.0385 0.0000 0.2308 0.2692 0.0690 #&gt; Sum 1.0000 1.0000 1.0000 1.0000 1.0000 转换成百分比，将小数四舍五入转化为百分数，保留两位小数点 round(100 * aiq.marprop, 2) #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 96.15 100.00 76.92 73.08 93.10 #&gt; TRUE 3.85 0.00 23.08 26.92 6.90 #&gt; Sum 100.00 100.00 100.00 100.00 100.00 pairs(airquality, panel = panel.smooth, main = &quot;airquality data&quot;) 以 UCBAdmissions 数据集为例，使用 xtabs 函数把数据组织成列联表，先查看数据的内容 UCBAdmissions #&gt; , , Dept = A #&gt; #&gt; Gender #&gt; Admit Male Female #&gt; Admitted 512 89 #&gt; Rejected 313 19 .... UCBA2DF &lt;- as.data.frame(UCBAdmissions) UCBA2DF #&gt; Admit Gender Dept Freq #&gt; 1 Admitted Male A 512 #&gt; 2 Rejected Male A 313 #&gt; 3 Admitted Female A 89 #&gt; 4 Rejected Female A 19 #&gt; 5 Admitted Male B 353 .... 接着将 UCBA2DF 数据集转化为表格的形式 UCBA2DF.tab &lt;- xtabs(Freq ~ Gender + Admit + Dept, data = UCBA2DF) ftable(UCBA2DF.tab) #&gt; Dept A B C D E F #&gt; Gender Admit #&gt; Male Admitted 512 353 120 138 53 22 #&gt; Rejected 313 207 205 279 138 351 #&gt; Female Admitted 89 17 202 131 94 24 #&gt; Rejected 19 8 391 244 299 317 将录取性别和院系进行对比 prop.table(margin.table(UCBA2DF.tab, c(1, 3)), 1) #&gt; Dept #&gt; Gender A B C D E F #&gt; Male 0.3066 0.2081 0.1208 0.1550 0.0710 0.1386 #&gt; Female 0.0589 0.0136 0.3232 0.2044 0.2142 0.1858 男生倾向于申请院系 A 和 B，女生倾向于申请院系 C 到 F，院系 A 和 B 是最容易录取的。 7.11 索引访问 which 与引用 [ 性能比较，在区间 \\([0,1]\\) 上生成 10 万个服从均匀分布的随机数，随机抽取其中\\(\\frac{1}{4}\\)。 n &lt;- 100000 x &lt;- runif(n) i &lt;- logical(n) i[sample(n, n / 4)] &lt;- TRUE microbenchmark::microbenchmark(x[i], x[which(i)], times = 1000) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; x[i] 303 321 379 330 348 4193 1000 #&gt; x[which(i)] 369 391 452 401 419 4108 1000 7.12 多维数组 多维数组的行列是怎么定义的 ?array 轴的概念，画个图表示数组 array(1:27, c(3, 3, 3)) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 10 13 16 #&gt; [2,] 11 14 17 #&gt; [3,] 12 15 18 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 19 22 25 #&gt; [2,] 20 23 26 #&gt; [3,] 21 24 27 垂直于Z轴的平面去截三维立方体，3 代表 z 轴，得到三个截面（二维矩阵） asplit(array(1:27, c(3, 3, 3)), 3) #&gt; [[1]] #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 #&gt; #&gt; [[2]] #&gt; [,1] [,2] [,3] #&gt; [1,] 10 13 16 #&gt; [2,] 11 14 17 #&gt; [3,] 12 15 18 #&gt; #&gt; [[3]] #&gt; [,1] [,2] [,3] #&gt; [1,] 19 22 25 #&gt; [2,] 20 23 26 #&gt; [3,] 21 24 27 对每个二维矩阵按列求和 lapply(asplit(array(1:27, c(3, 3, 3)), 3), apply, 2, sum) #&gt; [[1]] #&gt; [1] 6 15 24 #&gt; #&gt; [[2]] #&gt; [1] 33 42 51 #&gt; #&gt; [[3]] #&gt; [1] 60 69 78 asplit 和 lapply 组合处理多维数组的计算问题，多维数组15 7.13 其它操作 成对的数据操作有 list 与 unlist、stack 与 unstack、class 与 unclass、attach 与 detach 以及 with 和 within，它们在数据操作过程中有时会起到一定的补充作用。 7.13.1 列表属性 # 创建列表 list(...) pairlist(...) # 转化列表 as.list(x, ...) ## S3 method for class &#39;environment&#39; as.list(x, all.names = FALSE, sorted = FALSE, ...) as.pairlist(x) # 检查列表 is.list(x) is.pairlist(x) alist(...) list 函数用来构造、转化和检查 R 列表对象。下面创建一个临时列表对象 tmp ，它包含两个元素 A 和 B，两个元素都是向量，前者是数值型，后者是字符型 (tmp &lt;- list(A = c(1, 2, 3), B = c(&quot;a&quot;, &quot;b&quot;))) #&gt; $A #&gt; [1] 1 2 3 #&gt; #&gt; $B #&gt; [1] &quot;a&quot; &quot;b&quot; unlist(x, recursive = TRUE, use.names = TRUE) unlist 函数将给定的列表对象 x 简化为原子向量 (atomic vector)，我们发现简化之后变成一个字符型向量 unlist(tmp) #&gt; A1 A2 A3 B1 B2 #&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; unlist(tmp, use.names = FALSE) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; 7.13.2 堆叠向量 stack(x, ...) ## Default S3 method: stack(x, drop = FALSE, ...) ## S3 method for class &#39;data.frame&#39; stack(x, select, drop = FALSE, ...) unstack(x, ...) ## Default S3 method: unstack(x, form, ...) ## S3 method for class &#39;data.frame&#39; unstack(x, form, ...) stack 与 unstack 将多个向量堆在一起组成一个向量 # 查看数据集 PlantGrowth class(PlantGrowth) #&gt; [1] &quot;data.frame&quot; head(PlantGrowth) #&gt; weight group #&gt; 1 4.17 ctrl #&gt; 2 5.58 ctrl #&gt; 3 5.18 ctrl #&gt; 4 6.11 ctrl #&gt; 5 4.50 ctrl #&gt; 6 4.61 ctrl # 检查默认的公式 formula(PlantGrowth) #&gt; weight ~ group # 根据公式解除堆叠 # 下面等价于 unstack(PlantGrowth, form = weight ~ group) (pg &lt;- unstack(PlantGrowth)) #&gt; ctrl trt1 trt2 #&gt; 1 4.17 4.81 6.31 #&gt; 2 5.58 4.17 5.12 #&gt; 3 5.18 4.41 5.54 #&gt; 4 6.11 3.59 5.50 #&gt; 5 4.50 5.87 5.37 #&gt; 6 4.61 3.83 5.29 #&gt; 7 5.17 6.03 4.92 #&gt; 8 4.53 4.89 6.15 #&gt; 9 5.33 4.32 5.80 #&gt; 10 5.14 4.69 5.26 现在再将变量 pg 堆叠起来，还可以指定要堆叠的列 stack(pg) #&gt; values ind #&gt; 1 4.17 ctrl #&gt; 2 5.58 ctrl #&gt; 3 5.18 ctrl #&gt; 4 6.11 ctrl #&gt; 5 4.50 ctrl #&gt; 6 4.61 ctrl #&gt; 7 5.17 ctrl #&gt; 8 4.53 ctrl #&gt; 9 5.33 ctrl #&gt; 10 5.14 ctrl #&gt; 11 4.81 trt1 #&gt; 12 4.17 trt1 #&gt; 13 4.41 trt1 #&gt; 14 3.59 trt1 #&gt; 15 5.87 trt1 #&gt; 16 3.83 trt1 #&gt; 17 6.03 trt1 #&gt; 18 4.89 trt1 #&gt; 19 4.32 trt1 #&gt; 20 4.69 trt1 #&gt; 21 6.31 trt2 #&gt; 22 5.12 trt2 #&gt; 23 5.54 trt2 #&gt; 24 5.50 trt2 #&gt; 25 5.37 trt2 #&gt; 26 5.29 trt2 #&gt; 27 4.92 trt2 #&gt; 28 6.15 trt2 #&gt; 29 5.80 trt2 #&gt; 30 5.26 trt2 stack(pg, select = -ctrl) #&gt; values ind #&gt; 1 4.81 trt1 #&gt; 2 4.17 trt1 #&gt; 3 4.41 trt1 #&gt; 4 3.59 trt1 #&gt; 5 5.87 trt1 #&gt; 6 3.83 trt1 #&gt; 7 6.03 trt1 #&gt; 8 4.89 trt1 #&gt; 9 4.32 trt1 #&gt; 10 4.69 trt1 #&gt; 11 6.31 trt2 #&gt; 12 5.12 trt2 #&gt; 13 5.54 trt2 #&gt; 14 5.50 trt2 #&gt; 15 5.37 trt2 #&gt; 16 5.29 trt2 #&gt; 17 4.92 trt2 #&gt; 18 6.15 trt2 #&gt; 19 5.80 trt2 #&gt; 20 5.26 trt2 形式上和 reshape 有一些相似之处，数据框可以由长变宽或由宽变长 7.13.3 属性转化 class(x) class(x) &lt;- value unclass(x) inherits(x, what, which = FALSE) oldClass(x) oldClass(x) &lt;- value class 和 unclass 函数用来查看、设置类属性和取消类属性，常用于面向对象的编程设计中 class(iris) #&gt; [1] &quot;data.frame&quot; class(iris$Species) #&gt; [1] &quot;factor&quot; unclass(iris$Species) #&gt; [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 #&gt; [112] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #&gt; [149] 3 3 #&gt; attr(,&quot;levels&quot;) .... 7.13.4 绑定环境 attach(what, pos = 2L, name = deparse(substitute(what), backtick = FALSE), warn.conflicts = TRUE ) detach(name, pos = 2L, unload = FALSE, character.only = FALSE, force = FALSE ) attach 和 detach 是否绑定数据框的列名，不推荐操作，推荐使用 with attach(iris) head(Species) #&gt; [1] setosa setosa setosa setosa setosa setosa #&gt; Levels: setosa versicolor virginica detach(iris) 7.13.5 数据环境 with(data, expr, ...) within(data, expr, ...) ## S3 method for class &#39;list&#39; within(data, expr, keepAttrs = TRUE, ...) data 参数 data 用来构造表达式计算的环境。其默认值可以是一个环境，列表，数据框。在 within 函数中 data 参数只能是列表或数据框。 expr 参数 expr 包含要计算的表达式。在 within 中通常包含一个复合表达式，比如 { a &lt;- somefun() b &lt;- otherfun() ... rm(unused1, temp) } with 和 within 计算一组表达式，计算的环境是由数据构造的，后者可以修改原始的数据 with(mtcars, mpg[cyl == 8 &amp; disp &gt; 350]) #&gt; [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8 和下面计算的结果一样，但是更加简洁漂亮 mtcars$mpg[mtcars$cyl == 8 &amp; mtcars$disp &gt; 350] #&gt; [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8 within 函数可以修改原数据环境中的多个变量，比如删除、修改和添加等 # 原数据集 airquality head(airquality) #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 aq &lt;- within(airquality, { lOzone &lt;- log(Ozone) # 取对数 Month &lt;- factor(month.abb[Month]) # 字符串型转因子型 cTemp &lt;- round((Temp - 32) * 5 / 9, 1) # 从华氏温度到摄氏温度转化 S.cT &lt;- Solar.R / cTemp # 使用新创建的变量 rm(Day, Temp) }) # 修改后的数据集 head(aq) #&gt; Ozone Solar.R Wind Month S.cT cTemp lOzone #&gt; 1 41 190 7.4 May 9.79 19.4 3.71 #&gt; 2 36 118 8.0 May 5.32 22.2 3.58 #&gt; 3 12 149 12.6 May 6.39 23.3 2.48 #&gt; 4 18 313 11.5 May 18.74 16.7 2.89 #&gt; 5 NA NA 14.3 May NA 13.3 NA #&gt; 6 28 NA 14.9 May NA 18.9 3.33 下面再举一个复杂的绘图例子，这个例子来自 boxplot 函数 with(ToothGrowth, { boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2, subset = (supp == &quot;VC&quot;), col = &quot;#4285f4&quot;, main = &quot;Guinea Pigs&#39; Tooth Growth&quot;, xlab = &quot;Vitamin C dose mg&quot;, ylab = &quot;tooth length&quot;, ylim = c(0, 35) ) boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2, subset = supp == &quot;OJ&quot;, col = &quot;#EA4335&quot; ) legend(2, 9, c(&quot;Ascorbic acid&quot;, &quot;Orange juice&quot;), fill = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;) ) }) 将 boxplot 函数的 subset 参数单独提出来，调用数据子集选择函数 subset ，这里 with 中只包含一个表达式，所以也可以不用大括号 with( subset(ToothGrowth, supp == &quot;VC&quot;), boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2, col = &quot;#4285f4&quot;, main = &quot;Guinea Pigs&#39; Tooth Growth&quot;, xlab = &quot;Vitamin C dose mg&quot;, ylab = &quot;tooth length&quot;, ylim = c(0, 35) ) ) with( subset(ToothGrowth, supp == &quot;OJ&quot;), boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2, col = &quot;#EA4335&quot; ) ) legend(2, 9, c(&quot;Ascorbic acid&quot;, &quot;Orange juice&quot;), fill = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;) ) 参考文献 "],
["09-vector-manipulation.html", "第 8 章 向量化操作 8.1 常用操作 8.2 高频问题 8.3 并行计算 8.4 管道操作", " 第 8 章 向量化操作 常用操作和高频问题需要合并进之前的 data-manipulation，本章只介绍向量化计算 更加高级的数据变形操作，特别是数据类型的一致性，方便后续的可视化和建模，引入 tidyverse，数据处理或者叫特征工程 Base R vs data.table vs dplyr 它们各有优点，所以都加以介绍 参考 Jozef Hajnala 博文。 关于 tidyverse 提供的数据操作移动到 Base R 对应的章节，本章主要讲并行或分布式数据操作工具，如 SparkR sparklyr 针对大数据集上的操 Malcolm Barrett 以幻灯片的形式呈现 dplyr 和 purrr 的基础用法 Charlotte Wickham 的课程 A introduction to purrr purrr-tutorial 关于引用 quotation 函数式编程 Functional Programming Languages 用于数据处理，向量化运算、并行运算和分布式运算 future 在 R 语言中提供统一的并行和分布式处理框架 future.apply 可以替代 base R 提供的 apply 族函数 future.batchtools 使用 batchtools 实现并行和分布式处理 batchtools Map 函数的并行实现，用于高性能计算系统和分布式处理，可以单机多核并行也可以多机并行，还提供了一种抽象的机制去定义大规模计算机实验。 multidplyr 是 dplyr 的后端，多核环境下实现数据分块，提高并行处理性能 disk.frame 是基于磁盘的超出内存容量的快速并行数据操作框架 parallelMap R package to interface some popular parallelization back-ends with a unified interface big.data.table 基于 data.table 的分布式并行计算 rpivotTable 动态数据透视表 fuzzyjoin Join tables together on inexact matching dtplyr dtplyr is the data.table backend for dplyr. It provides S3 methods for data.table objects so that dplyr works the way you expect. bplyr basic dplyr and tidyr functionality without the tidyverse dependencies fastmap 实现键值存储，提供新的数据结构 Roaring bitmaps Bitsets, also called bitmaps, are commonly used as fast data structures. library(tidyverse) 数据操作的语法 第一代 Base R 数据操作已在第 7 章详细介绍 第二代 reshape （退休）使用函数 melt 和 cast 重构(restructure)和聚合(aggregate)数据 reshape2 （退休）是 reshape 的继任者，功能和 reshape 类似，提供两个函数 melt 和 cast 聚合数据，因此不再介绍 reshape，而鉴于 reshape2 还在活跃使用中，故而以它为例介绍 melt 和 cast 函数 plyr （退休）统一拆分(split)，计算(apply)，合并(combine)的数据处理流，由 dplyr（用于data.frame） 和 purrr （用于 list）继任 第三代 dplyr 操作数据的语法及其扩展 sparklyr 给 dplyr 提供 Spark 接口支持 dbplyr 给 dplyr 提供 DBI 数据库接口支持 dtplyr 给 dplyr 提供 data.table 支持 tidyr 提供 spread 和 gather 两个函数清洗数据 Garrett Grolemund 在 RStudio 主要从事教育教学，参考 Materials for the Tidyverse Train-the-trainer workshop 和 The Tidyverse Cookbook Dirk Eddelbuettel 的 Getting Started in R – Tinyverse Edition 8.1 常用操作 dplyr 由 Hadley Wickham 主要由开发和维护，是Rstudio公司开源的用于数据处理的一大利器，该包号称“数据操作的语法”，与 ggplot2 对应，也就是说数据处理那一套已经建立完整的和SQL一样的功能。它们都遵循同样的处理逻辑，只不过一个用SQL写，一个用R语言写，处理效率差不多，R语言写的 SQL 会被翻译为 SQL 语句，再传至数据库查询，当然它也支持内存内的数据操作。目前 dplyr 以 dbplyr 为后端支持的数据库有：MySQL、PostgreSQL，SQLite等，完整的支持列表请看 这里，连接特定数据库，都是基于 DBI，DBI 即 Database Interface， 是使用C/C++开发的底层数据库接口，是一个统一的关系型数据库连接框架，需要根据不同的具体的数据库进行实例化，才可使用。 dplyr 常用的函数是6个： arrange 排序 filter 过滤 select 选择 mutate 变换 summarise 汇总 group_by 分组 以 GGplot2 自带的钻石数据集diamonds为例介绍 8.1.1 查看 除了直接打印数据集的前几行，tibble 包还提供 glimpse 函数查看数据集，而 Base R 默认查看方式是调用 str 函数 diamonds #&gt; # A tibble: 53,940 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 #&gt; 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 #&gt; 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 #&gt; 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 #&gt; 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 #&gt; 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 #&gt; # ... with 5.393e+04 more rows glimpse(diamonds) #&gt; Observations: 53,940 #&gt; Variables: 10 #&gt; $ carat &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23... #&gt; $ cut &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good,... #&gt; $ color &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J... #&gt; $ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, V... #&gt; $ depth &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4... #&gt; $ table &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62... #&gt; $ price &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340... #&gt; $ x &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00... #&gt; $ y &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05... #&gt; $ z &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39... 表 8.1: dplyr 定义的数据对象类型 类型 含义 int 整型 integer dbl （单）双精度浮点类型 chr 字符（串）类型 dttm data-time 类型 lgl 布尔类型 fctr 因子类型 factor date 日期类型 表 8.1 中 dttm 和 date 类型代指 lubridate 包指定的日期对象 POSIXct、 POSIXlt、 Date、 chron、 yearmon、 yearqtr、 zoo、 zooreg、 timeDate、 xts、 its、 ti、 jul、 timeSeries 和 fts。 8.1.2 筛选 8.1.3 排序 8.1.4 聚合 8.1.5 合并 8.1.6 重塑 8.1.7 变换 8.2 高频问题 常用的数据操作包含 创建空的数据框或者说初始化一个数据框， 按指定的列对数据框排序， 选择特定的一些列，复杂情况是可能需要正则表达式从列名或者值中筛选 合并两个数据框，分为 (inner outer left right) 四种情况 8.2.1 初始化数据框 创建空的数据框，就是不包含任何行、记录16 empty_df &lt;- data.frame( Doubles = double(), Ints = integer(), Factors = factor(), Logicals = logical(), Characters = character(), stringsAsFactors = FALSE ) str(empty_df) #&gt; &#39;data.frame&#39;: 0 obs. of 5 variables: #&gt; $ Doubles : num #&gt; $ Ints : int #&gt; $ Factors : Factor w/ 0 levels: #&gt; $ Logicals : logi #&gt; $ Characters: chr 如果数据框 df 包含数据，现在要依据它创建一个空的数据框 empty_df = df[FALSE,] 还可以使用 structure 构造一个数据框，并且我们发现它的效率更高 s &lt;- function() structure(list( Date = as.Date(character()), File = character(), User = character() ), class = &quot;data.frame&quot; ) d &lt;- function() data.frame( Date = as.Date(character()), File = character(), User = character(), stringsAsFactors = FALSE ) microbenchmark::microbenchmark(s(), d()) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; s() 25.5 29.8 71.8 36.9 39 2969 100 #&gt; d() 244.3 250.2 287.0 255.0 263 2640 100 8.2.2 移除缺失记录 只要行中包含缺失值，我们就把这样的行移除出去 airquality[complete.cases(airquality), ] #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 7 23 299 8.6 65 5 7 #&gt; 8 19 99 13.8 59 5 8 #&gt; 9 8 19 20.1 61 5 9 #&gt; 12 16 256 9.7 69 5 12 #&gt; 13 11 290 9.2 66 5 13 .... 8.2.3 数据类型转化 str(PlantGrowth) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... bob &lt;- PlantGrowth i &lt;- sapply(bob, is.factor) bob[i] &lt;- lapply(bob[i], as.character) str(bob) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : chr &quot;ctrl&quot; &quot;ctrl&quot; &quot;ctrl&quot; &quot;ctrl&quot; ... 8.2.4 跨列分组求和 输入是一个数据框 data.frame，按照其中某一变量分组，然后计算任意数量的变量的行和和列和。 空气质量数据集 airquality 按月份 Month 分组，然后求取满足条件的列的和 Reduce(rbind, lapply(unique(airquality$Month), function(gv) { subdta &lt;- subset(airquality, subset = Month == gv) data.frame( Colsum = as.numeric( colSums(subdta[, grepl(&quot;[mM]&quot;, names(airquality))], na.rm = TRUE) ), Month = gv ) })) #&gt; Colsum Month #&gt; 1 2032 5 #&gt; 2 155 5 #&gt; 3 2373 6 #&gt; 4 180 6 #&gt; 5 2601 7 #&gt; 6 217 7 #&gt; 7 2603 8 #&gt; 8 248 8 #&gt; 9 2307 9 #&gt; 10 270 9 什么是函数式编程，R 语言环境下的函数式编程是如何操作的 8.3 并行计算 8.3.1 apply apply 家族和 do.call 8.3.2 MapReduce 高阶函数，简单来说，就是参数为函数，返回值也是函数。Base R 提供了 Reduce 、Filter 、Find 、Map 、Negate 和 Position 等常用函数，此外还有 *apply 族，我们把它放在第8小节向量化计算中介绍。 与 purrr::map 比较 在 R 语言里玩转apply， Map() 和 Reduce()17，下面分别以提取合并多张 XLSX 表格18，分组计算19 和子集操作20 为例，从函数式编程到 MapReduce21，制作数据透视表22，用于数据处理的函数式编程和单元测试 Functional programming and unit testing for data munging with R 特别是第三章 https://b-rodrigues.github.io/fput/，然后是函数式编程与数据建模 Modeling data with functional programming in R23 add &lt;- function(x) Reduce(&quot;+&quot;, x) add(list(1, 2, 3)) #&gt; [1] 6 add_accuml &lt;- function(x) Reduce(&quot;+&quot;, x, accumulate = TRUE) add_accuml(list(1, 2, 3)) #&gt; [1] 1 3 6 8.3.3 parallel 并行计算小抄 将共享内存的 R 包整理在一起 library(parallel) 8.3.4 Rmpi Rmpi 由卡尔顿大学的 Hao Yu 开发和维护 首先安装 openmpi-devel 开发环境（以 Fedora 30 为例） yum install -y openmpi-devel echo &quot;export ORTED=/usr/lib64/openmpi/bin&quot; &gt;&gt; ~/.bashrc # 或者 echo &quot;PATH=/usr/lib64/openmpi/bin:$PATH; export PATH&quot; | tee -a ~/.bashrc source ~/.bashrc 然后进入 R 安装 R 包 Rmpi install.packages(&#39;Rmpi&#39;) 使用 Rmpi 包生成两组服从均匀分布的随机数 # 加载 R 包 library(Rmpi) # 检测可用的逻辑 CPU 核心数 parallel::detectCores() # 虚拟机分配四个逻辑CPU核 # 1个 master 2个 worker 主机 cloud mpi.spawn.Rslaves(nslaves=2) # 2 slaves are spawned successfully. 0 failed. # master (rank 0, comm 1) of size 3 is running on: cloud # slave1 (rank 1, comm 1) of size 3 is running on: cloud # slave2 (rank 2, comm 1) of size 3 is running on: cloud 调用 mpi.apply 函数 set.seed(1234) mpi.apply(c(10, 20), runif) [[1]] [1] 0.33684269 0.84638494 0.82776590 0.23707947 0.07593769 0.27981368 [7] 0.45307675 0.02878214 0.32807421 0.92854275 [[2]] [1] 0.63474442 0.04025071 0.01996498 0.01922093 0.41258827 0.84150414 [7] 0.74705002 0.07635368 0.32807392 0.94570363 0.89187667 0.67069020 [13] 0.92996997 0.22486589 0.22118236 0.15807970 0.65619450 0.16473730 [19] 0.85833484 0.11416449 用完要关闭 mpi.close.Rslaves() pbdMPI 包处于活跃维护状态，是 pbdR 项目 的核心组件，能够以分布式计算的方式轻松处理 TB 级数据24 Rhpc 包同样基于 MPI 方式，但是集 Rmpi 和 snow 两个包的优点于一身，在保持 apply 编程风格的同时，能够提供更好的高性能计算环境，支持长向量，能够处理一些大数据。 8.3.5 gpuR Charles Determan 开发的 gpuR (Rupp et al., n.d.) 基于 OpenCL 加速，目前处于活跃维护状态。而 Charles Determan 开发的另一个 gpuRcuda 包是基于 CUDA 加速 赵鹏 的博客 ParallelR 关注基于 CUDA 的 GPU 加速 此外还有 gputools 8.4 管道操作 我要查看是否需要新添加一个 R 包依赖，假设该 R 包是 reticulate 没有出现在 DESCRIPTION 文件中，但是可能已经被其中某（个）些 R 包依赖了 &quot;reticulate&quot; %in% sort(unique(unlist(tools::package_dependencies(desc::desc_get_deps()$package, recursive = TRUE)))) #&gt; [1] FALSE 安装 pkg 的依赖 pkg &lt;- c( &quot;bookdown&quot;, &quot;e1071&quot;, &quot;formatR&quot;, &quot;lme4&quot;, &quot;mvtnorm&quot;, &quot;prettydoc&quot;, &quot;psych&quot;, &quot;reticulate&quot;, &quot;rstan&quot;, &quot;rstanarm&quot;, &quot;rticles&quot;, &quot;svglite&quot;, &quot;TMB&quot;, &quot;glmmTMB&quot; ) # 获取 pkg 的所有依赖 dep_pkg &lt;- tools::package_dependencies(pkg, recursive = TRUE) # 将列表 list 合并为向量 vector merge_pkg &lt;- Reduce(&quot;c&quot;, dep_pkg, accumulate = FALSE) # 所有未安装的 R 包 miss_pkg &lt;- setdiff(unique(merge_pkg), unique(.packages(TRUE))) # 除了 pkg 外，未安装的 R 包，安装 pkg 的依赖 sort(setdiff(miss_pkg, pkg)) #&gt; character(0) 转化为管道操作，增加可读性，25 再举一个关于数据模拟的例子 模拟 0-1 序列， set.seed(2019) binom_sample &lt;- function(n) { sum(sample(x = c(0,1), size = n, prob = c(0.8, 0.2), replace = TRUE))/n } # 频率估计概率 one_prob &lt;- sapply(10^(seq(8)), binom_sample) # 估计的误差 one_abs &lt;- abs(one_prob - 0.2) 似然估计 参考文献 "],
["10-data-cleaning-with-string.html", "第 9 章 字符串操作 9.1 字符数统计 9.2 字符串翻译 9.3 字符串连接 9.4 字符串拆分 9.5 字符串匹配 9.6 字符串查询 9.7 字符串替换 9.8 字符串提取 9.9 其它字符串操作", " 第 9 章 字符串操作 字符和字符串类型的数据值得单独拿出来讲，不仅因为内容多，而且比较难，应用范围最广，特别是面对文本类型的数据时，几乎是避不开的！R 的前身是 S，S 的前身是一些 Fortran 和 C 子程序，最早在贝尔实验室是用于文本分析领域，因此在 R 基础包中提供了丰富的字符串处理函数，你可以在R控制台中执行如下一行命令查看 help.search(keyword = &quot;character&quot;, package = &quot;base&quot;) 本章主要介绍 R 内置的字符串操作函数 9.1 字符数统计 nchar 函数统计字符串向量中每个元素的字符个数，注意与函数length 的差别，它统计向量中元素的个数，即向量的长度。 nchar(c(&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;)) #&gt; [1] 5 5 1 R.version.string #&gt; [1] &quot;R version 3.6.0 (2019-04-26)&quot; nchar(R.version.string) #&gt; [1] 28 deparse(base::mean) #&gt; [1] &quot;function (x, ...) &quot; &quot;UseMethod(\\&quot;mean\\&quot;)&quot; nchar(deparse(base::mean)) #&gt; [1] 18 17 一些特殊的情况 nchar(&quot;&quot;) #&gt; [1] 0 nchar(NULL) #&gt; integer(0) nchar(0) #&gt; [1] 1 pi #&gt; [1] 3.14 nchar(pi) #&gt; [1] 16 exp(1) #&gt; [1] 2.72 nchar(exp(1)) #&gt; [1] 16 nchar(NA) #&gt; [1] NA 9.2 字符串翻译 tolower 将字符串或字符串向量中含有的大写字母全都转化为小写， toupper 函数正好与之相反. tolower(c(&quot;HELLO&quot;, &quot;Hello, R&quot;, &quot;hello&quot;)) #&gt; [1] &quot;hello&quot; &quot;hello, r&quot; &quot;hello&quot; toupper(c(&quot;HELLO&quot;, &quot;Hello, R&quot;, &quot;hello&quot;)) #&gt; [1] &quot;HELLO&quot; &quot;HELLO, R&quot; &quot;HELLO&quot; 9.3 字符串连接 paste 函数设置参数 sep 作为连接符，设置参数 collapse 可以将字符串拼接后连成一个字符串 paste(&quot;A&quot;, &quot;B&quot;, sep = &quot;&quot;) #&gt; [1] &quot;AB&quot; paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, sep = &quot;-&quot;) #&gt; [1] &quot;A-1&quot; &quot;B-2&quot; &quot;C-3&quot; paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, sep = &quot;-&quot;, collapse = &quot;;&quot;) #&gt; [1] &quot;A-1;B-2;C-3&quot; paste0 相当于 sep 设为空，没有连接符 paste0(&quot;A&quot;, &quot;B&quot;) #&gt; [1] &quot;AB&quot; paste0(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3) #&gt; [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; paste0(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, collapse = &quot;;&quot;) #&gt; [1] &quot;A1;B2;C3&quot; 9.4 字符串拆分 strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE) strsplit 函数用于字符串拆分，参数 x 是被拆分的字符串向量，其每个元素都会被拆分，而参数 split 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。 参数 fixed 默认设置 fixed = FALSE 表示正则表达式匹配，而 fixed = TRUE 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。 当启用 perl = TRUE 时，由 PCRE_use_JIT 控制细节。perl 参数的设置与 Perl 软件版本有关，如果正则表达式很长，除了正确设置正则表达式，使用 perl = TRUE 可以提高运算速度 参数 useBytes 设置是否按照逐个字节地进行匹配，默认设置为 FALSE，即按照字符而不是字节进行匹配 x &lt;- c(as = &quot;asfef&quot;, qu = &quot;qwerty&quot;, &quot;yuiop[&quot;, &quot;b&quot;, &quot;stuff.blah.yech&quot;) # 按字母 e 拆分字符串向量 x strsplit(x, &quot;e&quot;) #&gt; $as #&gt; [1] &quot;asf&quot; &quot;f&quot; #&gt; #&gt; $qu #&gt; [1] &quot;qw&quot; &quot;rty&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;yuiop[&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;b&quot; #&gt; #&gt; [[5]] #&gt; [1] &quot;stuff.blah.y&quot; &quot;ch&quot; 参数 split 支持通过正则表达式的方式指明拆分位置 # 默认将点号 . 看作一个正则表达式，它是一个元字符，匹配任意字符 strsplit(&quot;a.b.c&quot;, &quot;.&quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; # 这才是按点号拆分 strsplit(&quot;a.b.c&quot;, &quot;.&quot;, fixed = TRUE) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 或者 strsplit(&quot;a.b.c&quot;, &quot;[.]&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 或者转义点号，去掉元字符的特殊意义 strsplit(&quot;a.b.c&quot;, &quot;\\\\.&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 这里介绍一个将字符串逆序的函数 str_rev str_rev &lt;- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = &quot;&quot;) str_rev(c(&quot;abc&quot;, &quot;Statistics&quot;)) #&gt; [1] &quot;cba&quot; &quot;scitsitatS&quot; 为了加深理解，再举几个例子 # 最后一个空字符没有产生 strsplit(paste(c(&quot;&quot;, &quot;a&quot;, &quot;&quot;), collapse=&quot;#&quot;), split=&quot;#&quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; &quot;a&quot; # 空字符只有有定义的时候才会产生 strsplit(&quot;&quot;, &quot; &quot;) #&gt; [[1]] #&gt; character(0) strsplit(&quot; &quot;, &quot; &quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; 9.5 字符串匹配 agrep 和 agrepl 函数做近似（模糊）匹配 (Approximate Matching or Fuzzy Matching) ，对于匹配，考虑到参数 pattern 在参数 x 中匹配时，允许参数值x存在最小可能的插入、删除和替换，这种修改叫做Levenshtein 编辑距离，max.distance 控制其细节 agrep(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, value = FALSE, fixed = TRUE, useBytes = FALSE) agrepl(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = TRUE, useBytes = FALSE) agrep 函数返回 pattern 在 x 中匹配到的一个位置向量，agrepl 返回一个逻辑向量，这一点类似 grep 和 grepl 这对函数，下面举例子说明 agrep(&quot;lasy&quot;, &quot;1 lazy 2&quot;) #&gt; [1] 1 # sub = 0 表示匹配时不考虑替换 agrep(&quot;lasy&quot;, c(&quot; 1 lazy 2&quot;, &quot;1 lasy 2&quot;), max = list(sub = 0)) #&gt; [1] 2 # 默认设置下，匹配时区分大小写 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2) #&gt; [1] 1 # 返回匹配到值，而不是位置下标，类似 grep(..., value = TRUE) 的返回值 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, value = TRUE) #&gt; [1] &quot;1 lazy&quot; # 不区分大小写 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, ignore.case = TRUE) #&gt; [1] 1 3 startsWith(x, prefix) endsWith(x, suffix) startsWith 和 endsWith 函数用来匹配字符串的前缀和后缀，返回值是一个逻辑向量，参数 prefix 和 suffix 不要包含特殊的正则表达式字符，如点号.，举例子 # 字符串向量 search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; #&gt; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; #&gt; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; # 匹配以 package: 开头的字符串 startsWith(search(), &quot;package:&quot;) #&gt; [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE # 或者 grepl(&quot;^package:&quot;, search()) #&gt; [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE 当前目录下，列出扩展名为 .Rmd 的文件 # list.files(path = &quot;.&quot;, pattern = &quot;\\\\.Rmd$&quot;) # 而不是 endsWith(list.files(), &quot;\\\\.Rmd&quot;) endsWith(list.files(), &quot;.Rmd&quot;) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [13] TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE #&gt; [25] FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE #&gt; [37] FALSE FALSE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE #&gt; [49] TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE #&gt; [61] FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [73] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # 或者 grepl(&quot;\\\\.Rmd$&quot;, list.files()) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [13] TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE #&gt; [25] FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE #&gt; [37] FALSE FALSE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE #&gt; [49] TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE #&gt; [61] FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [73] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 部分匹配(Partial String Matching) match(x, table, nomatch = NA_integer_, incomparables = NULL) x %in% table charmatch(x, table, nomatch = NA_integer_) pmatch(x, table, nomatch = NA_integer_, duplicates.ok = FALSE) 这几个 match 函数的返回值都是一个向量，每个元素是参数x在参数table中第一次匹配到的位置，charmatch 与 pmatch(x, table, nomatch = NA_integer_, duplicates.ok = TRUE) 类似，所以 pmatch 在默认 duplicates.ok = FALSE 的情况下，若x在第二个参数table中有多次匹配就会返回 NA，因此，实际上 pmatch 只允许在第二个参数中匹配一次 match(&quot;xx&quot;, c(&quot;abc&quot;, &quot;xx&quot;, &quot;xxx&quot;, &quot;xx&quot;)) #&gt; [1] 2 1:10 %in% c(1,3,5,9) #&gt; [1] TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE # charmatch 就比较奇怪，规则太多 charmatch(&quot;&quot;, &quot;&quot;) # returns 1 #&gt; [1] 1 # 多个精确匹配到，或者多个部分匹配到，则返回 0 charmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;quantile&quot;)) # returns 0 #&gt; [1] 0 # med 只在table参数值的第二个位置部分匹配到，所以返回2 charmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;quantile&quot;)) # returns 2 #&gt; [1] 2 charmatch(&quot;xx&quot;, &quot;xx&quot;) #&gt; [1] 1 charmatch(&quot;xx&quot;, &quot;xxa&quot;) #&gt; [1] 1 charmatch(&quot;xx&quot;, &quot;axx&quot;) #&gt; [1] NA # 注意比较与 charmatch 的不同 pmatch(&quot;&quot;, &quot;&quot;) # returns NA #&gt; [1] NA pmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns NA #&gt; [1] NA pmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns 2 #&gt; [1] 2 9.6 字符串查询 grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE ) grepl(pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) grep 和 grepl 是一对字符串查询函数，查看字符串向量 x 中是否包含正则表达式 pattern 描述的内容 ignore.case: TRUE 表示忽略大小写，FALSE 表示匹配的时候区分大小写 fixed = TRUE 表示启用 literal regular expression 字面正则表达式，默认情况下fixed = FALSE grep 函数返回匹配到的字符串向量x的元素的下标，如果 value=TRUE 则返回下标对应的值 grepl 函数返回一个逻辑向量，检查字符串向量x中的每个元素是否匹配到，匹配到返回 TRUE，没有匹配到返回 FALSE # 返回下标位置 grep(&quot;[a-z]&quot;, letters) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #&gt; [26] 26 # 返回查询到的值 grep(&quot;[a-z]&quot;, letters, value = TRUE) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; #&gt; [19] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 继续举例子 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) #&gt; [1] 1 2 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;) #&gt; [1] 2 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;, value = TRUE) #&gt; [1] &quot;apple&quot; &quot;banana&quot; grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;, value = TRUE) #&gt; [1] &quot;banana&quot; 关于 grepl 函数的使用例子 grepl(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) #&gt; [1] TRUE TRUE grepl(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;) #&gt; [1] FALSE TRUE R 语言是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式 在 R 里面分别表示 a\\\\b 和 a\\b writeLines(c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;)) #&gt; a\\\\b #&gt; a\\b 下面在 R 里面分别匹配字符串 a\\\\b 和 a\\b 中的 \\\\ 和 \\ # 匹配字符串中的一个反斜杠 grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\&quot;, value = TRUE, fixed = TRUE) #&gt; [1] &quot;a\\\\\\\\b&quot; &quot;a\\\\b&quot; grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\&quot;, value = TRUE, fixed = FALSE) #&gt; [1] &quot;a\\\\\\\\b&quot; &quot;a\\\\b&quot; # 匹配字符串中的两个反斜杠 grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\&quot;, value = TRUE, fixed = TRUE) #&gt; [1] &quot;a\\\\\\\\b&quot; grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\\\\\\\\\&quot;, value = TRUE, fixed = FALSE) #&gt; [1] &quot;a\\\\\\\\b&quot; # 匹配字符串中的两个反斜杠 \\\\ grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\\\\\\\\\&quot;, fixed = FALSE) #&gt; [1] TRUE grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\\\\\\\\\&quot;, fixed = TRUE) #&gt; [1] FALSE grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\&quot;, fixed = TRUE) #&gt; [1] TRUE regexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) regexec(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) 当启用 perl=TRUE 时， 函数 regexpr 和 gregexpr 支持 Python 环境下的命名捕获(named captures)，但是不支持长向量的输入。如果一个分组被命名了，如 (?&lt;first&gt;[A-Z][a-z]+) 那么匹配到的位置按命名返回。函数 sub 不支持命名反向引用 (Named backreferences) 函数 regmatches 用来提取函数regexpr, gregexpr 和 regexec 匹配到的子字符串 useBytes = FALSE 匹配位置和长度默认是按照字符级别来的，如果 useBytes = TRUE 则是按照逐个字节的匹配结果 如果使用到了 命名捕获 则会返回更多的属性 “capture.start”，“capture.length” 和 “capture.names”，分别表示捕获的起始位置、捕获的长度和捕获的命名。 regexpr 函数返回一个整型向量，第一次匹配的初始位置，-1 表示没有匹配到，返回的属性 match.length 表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，-1 表示没有匹配到 text &lt;- c(&quot;Hellow, Adam!&quot;, &quot;Hi, Adam!&quot;, &quot;How are you, Adam.&quot;) regexpr(&quot;Adam&quot;, text) #&gt; [1] 9 5 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 4 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE txt &lt;- c( &quot;The&quot;, &quot;licenses&quot;, &quot;for&quot;, &quot;most&quot;, &quot;software&quot;, &quot;are&quot;, &quot;designed&quot;, &quot;to&quot;, &quot;take&quot;, &quot;away&quot;, &quot;your&quot;, &quot;freedom&quot;, &quot;to&quot;, &quot;share&quot;, &quot;and&quot;, &quot;change&quot;, &quot;it.&quot;, &quot;&quot;, &quot;By&quot;, &quot;contrast,&quot;, &quot;the&quot;, &quot;GNU&quot;, &quot;General&quot;, &quot;Public&quot;, &quot;License&quot;, &quot;is&quot;, &quot;intended&quot;, &quot;to&quot;, &quot;guarantee&quot;, &quot;your&quot;, &quot;freedom&quot;, &quot;to&quot;, &quot;share&quot;, &quot;and&quot;, &quot;change&quot;, &quot;free&quot;, &quot;software&quot;, &quot;--&quot;, &quot;to&quot;, &quot;make&quot;, &quot;sure&quot;, &quot;the&quot;, &quot;software&quot;, &quot;is&quot;, &quot;free&quot;, &quot;for&quot;, &quot;all&quot;, &quot;its&quot;, &quot;users&quot; ) # gregexpr(&quot;en&quot;, txt) regexpr(&quot;en&quot;, txt) #&gt; [1] -1 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 -1 4 #&gt; [26] -1 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 -1 2 #&gt; [26] -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE gregexpr 函数返回一个列表，返回列表的长度与字符串向量的长度一样，列表中每个元素的形式与 regexpr 的返回值一样, except that the starting positions of every (disjoint) match are given. gregexpr(&quot;Adam&quot;, text) #&gt; [[1]] #&gt; [1] 9 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexec 函数返回一个列表，类似函数gregexpr的返回结果，长度与字符串向量的长度一样，如果没有匹配到就返回 -1，匹配到了就返回一个匹配的初值位置的整型序列，所有子字符串与括号分组的正则表达式的子表达式对应，属性 “match.length” 是一个表示匹配的长度的向量，如果是 -1 表示没有匹配到。位置、长度和属性的解释与 regexpr 一致 regexec(&quot;Adam&quot;, text) #&gt; [[1]] #&gt; [1] 9 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 由于资源限制（特别是 PCRE）导致的匹配失败，会视为没有匹配，通常伴随一个警告 下面这个将链接分解的例子由 Luke Tierney 提供26 x &lt;- &quot;http://stat.umn.edu:80/xyz&quot; m &lt;- regexec(&quot;^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)&quot;, x) m #&gt; [[1]] #&gt; [1] 1 1 1 8 20 21 23 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 26 7 4 12 3 2 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 这里 x 是一个字符串，所以函数 regexec 返回的列表长度为1，正则表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 括号分组匹配到了7次，第一次匹配整个字符串，所以起始位置是1，而匹配长度是26，即整个字符串的长度，读者可以调用函数 nchar(x) 算一下，如果你愿意手动数一下也可以哈！余下不一一介绍，可以根据返回结果和图9.1一起看，最后还可以调用regmatches函数抽取匹配到的结果 regmatches(x, m) #&gt; [[1]] #&gt; [1] &quot;http://stat.umn.edu:80/xyz&quot; &quot;http://&quot; #&gt; [3] &quot;http&quot; &quot;stat.umn.edu&quot; #&gt; [5] &quot;:80&quot; &quot;80&quot; #&gt; [7] &quot;/xyz&quot; 我们可以在 https://regex101.com/ 上测试表达式，如图9.1所示，表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 包含7个组，每个组的匹配结果见图的右下角，这样我们不难理解，函数 regmatches 返回的第列表中，第3个位置是传输协议 protocol http ，第4个位置是主机 host stat.umn.edu， 第6个位置是端口 port 80 ，第7个位置是路径 path /xyz，所以函数 regmatches 的作用就是根据函数 regexec 匹配的结果抽取子字符串。 knitr::include_graphics(path = &quot;figures/regexp.png&quot;) 图 9.1: 正则表达式匹配结果 进一步，我们可以用 regmatches 函数抽取 URL 的部分内容，如前面提到的传输协议，主机等 URL_parts &lt;- function(x) { m &lt;- regexec(&quot;^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)&quot;, x) parts &lt;- do.call( rbind, lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)) # 3,4,6,7是索引位置 ) colnames(parts) &lt;- c(&quot;protocol&quot;, &quot;host&quot;, &quot;port&quot;, &quot;path&quot;) parts } URL_parts(x) #&gt; protocol host port path #&gt; [1,] &quot;http&quot; &quot;stat.umn.edu&quot; &quot;80&quot; &quot;/xyz&quot; 目前还没有 gregexec 函数，但是可以模拟一个，首先用 gregexpr 函数返回匹配的位置，regmatches 抽取相应的值，然后用 regexec 作用到每一个提取的值，做再一次匹配和值的抽取，实现了全部的匹配。另一个例子 ## There is no gregexec() yet, but one can emulate it by running ## regexec() on the regmatches obtained via gregexpr(). E.g.: pattern &lt;- &quot;([[:alpha:]]+)([[:digit:]]+)&quot; s &lt;- &quot;Test: A1 BC23 DEF456&quot; gregexpr(pattern, s) #&gt; [[1]] #&gt; [1] 7 10 15 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 2 4 6 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regmatches(s, gregexpr(pattern, s)) #&gt; [[1]] #&gt; [1] &quot;A1&quot; &quot;BC23&quot; &quot;DEF456&quot; lapply( regmatches(s, gregexpr(pattern, s)), function(e) regmatches(e, regexec(pattern, e)) ) #&gt; [[1]] #&gt; [[1]][[1]] #&gt; [1] &quot;A1&quot; &quot;A&quot; &quot;1&quot; #&gt; #&gt; [[1]][[2]] #&gt; [1] &quot;BC23&quot; &quot;BC&quot; &quot;23&quot; #&gt; #&gt; [[1]][[3]] #&gt; [1] &quot;DEF456&quot; &quot;DEF&quot; &quot;456&quot; 9.7 字符串替换 chartr 支持正则表达式的替换，chartr 是对应字符的替换操作 x &lt;- &quot;MiXeD cAsE 123&quot; # 将字符 iXs 替换为 why chartr(&quot;iXs&quot;, &quot;why&quot;, x) #&gt; [1] &quot;MwheD cAyE 123&quot; # 将字符串 a-cX 中的字符挨个对应地替换为 D-Fw chartr(&quot;a-cX&quot;, &quot;D-Fw&quot;, x) #&gt; [1] &quot;MiweD FAsE 123&quot; 两个 *sub 函数的区别：sub 替换第一次匹配到的结果，gsub 替换所有匹配的结果 sub(&quot; .*&quot;, &quot;&quot;, extSoftVersion()[&quot;PCRE&quot;]) #&gt; PCRE #&gt; &quot;8.42&quot; 参数 replacement 的值是正则表达式，其包含反向引用的用法， \\\\1 即引用表达式 ([ab]) gsub(pattern = &quot;([ab])&quot;, replacement = &quot;\\\\1_\\\\1_&quot;, x = &quot;abc and ABC&quot;) #&gt; [1] &quot;a_a_b_b_c a_a_nd ABC&quot; 9.8 字符串提取 substr(x, start, stop) substring(text, first, last = 1000000L) substr 和 substring 函数通过位置进行字符串的拆分和提取，它们本身不使用正则表达式，结合其他正则表达式函数regexpr, gregexpr 和 regexec，可以很方便地从大量文本中提取所需的信息。作用类似之前提到的 regmatches 函数 参数设置基本相同 x/text 是要拆分的字符串向量 start/first 截取的起始位置向量 stop/last 截取的终止位置向量 返回值有差别 substr 返回的字串个数等于第一个参数 x 的长度 substring 返回字串个数等于三个参数中最长向量长度，短向量循环使用。 x &lt;- &quot;123456789&quot; substr(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; substring(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;45&quot; &quot;2345678&quot; substr(&quot;abcdef&quot;, 2, 4) #&gt; [1] &quot;bcd&quot; substring(&quot;abcdef&quot;, 1:6, 1:6) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; 因为 x 的向量长度为1，所以 substr 获得的结果只有1个字串，即第2和第3个参数向量只用了第一个组合：起始位置2，终止位置4。而 substring 的语句三个参数中最长的向量为 c(4,5,8)，执行时按短向量循环使用的规则第一个参数事实上就是c(x,x,x)，第二个参数就成了c(2,4,2)，最终截取的字串起始位置组合为：2-4, 4-5和2-8。 x &lt;- c(&quot;123456789&quot;, &quot;abcdefghijklmnopq&quot;) substr(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;de&quot; substring(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;de&quot; &quot;2345678&quot; 9.9 其它字符串操作 9.9.1 strwrap strwrap(x, width = 0.9 * getOption(&quot;width&quot;), indent = 0, exdent = 0, prefix = &quot;&quot;, simplify = TRUE, initial = prefix) 该函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串。 # 读取一段文本 x &lt;- paste(readLines(file.path(R.home(&quot;doc&quot;), &quot;THANKS&quot;)), collapse = &quot;\\n&quot;) ## 将文本拆分为段落，且移除前三段 x &lt;- unlist(strsplit(x, &quot;\\n[ \\t\\n]*\\n&quot;))[-(1:3)] # 每一段换两行 x &lt;- paste(x, collapse = &quot;\\n\\n&quot;) # 每一行的宽度设定为60个字符 writeLines(strwrap(x, width = 60)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. #&gt; W. Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. #&gt; Evans, David M. Gay, H. Frick, G. W. Hill, Richard H. #&gt; Jones, Eric Grosse, Shelby Haberman, Bruno Haible, John #&gt; Hartigan, Andrew Harvey, Trevor Hastie, Min Long Lam, #&gt; George Marsaglia, K. J. Martin, Gordon Matzigkeit, C. R. #&gt; Mckenzie, Jean McRae, Cyrus Mehta, Fionn Murtagh, John C. #&gt; Nash, Finbarr O&#39;Sullivan, R. E. Odeh, William Patefield, #&gt; Nitin Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, #&gt; Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo #&gt; Wang, M. A. Wong, and the Free Software Foundation (for #&gt; autoconf code and utilities). See also files under #&gt; src/extras. #&gt; #&gt; Many more, too numerous to mention here, have contributed #&gt; by sending bug reports and suggesting various improvements. #&gt; #&gt; Simon Davies whilst at the University of Auckland wrote the #&gt; original version of glm(). #&gt; #&gt; Julian Harris and Wing Kwong (Tiki) Wan whilst at the #&gt; University of Auckland assisted Ross Ihaka with the #&gt; original Macintosh port. #&gt; #&gt; R was inspired by the S environment which has been #&gt; principally developed by John Chambers, with substantial #&gt; input from Douglas Bates, Rick Becker, Bill Cleveland, #&gt; Trevor Hastie, Daryl Pregibon and Allan Wilks. #&gt; #&gt; A special debt is owed to John Chambers who has graciously #&gt; contributed advice and encouragement in the early days of R #&gt; and later became a member of the core team. #&gt; #&gt; The R Foundation may decide to give out #&gt; &lt;first.lastname&gt;@R-project.org email addresses to #&gt; contributors to the R Project (even without making them #&gt; members of the R Foundation) when in the view of the R #&gt; Foundation this would help advance the R project. #&gt; #&gt; The R Core Group, Roger Bivand, Jennifer Bryan, Di Cook, #&gt; Dirk Eddelbuettel, John Fox, Bettina Gr眉n, Frank Harrell, #&gt; Torsten Hothorn, Stefano Iacus, Julie Josse, #&gt; Balasubramanian Narasimhan, Marc Schwartz, Heather Turner, #&gt; Bill Venables, Hadley Wickham and Achim Zeileis are the #&gt; ordinary members of the R Foundation. In addition, David #&gt; Meyer and Simon Wood are also e-addressable by #&gt; &lt;Firstname&gt;.&lt;Lastname&gt;@R-project.org. # 每一段的段首缩进5个字符 writeLines(strwrap(x, width = 60, indent = 5)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin #&gt; Buhr, Michael A. Covington, Bill Cleveland, Robert #&gt; Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, Paul #&gt; Eggert, J. O. Evans, David M. Gay, H. Frick, G. W. Hill, #&gt; Richard H. Jones, Eric Grosse, Shelby Haberman, Bruno #&gt; Haible, John Hartigan, Andrew Harvey, Trevor Hastie, Min #&gt; Long Lam, George Marsaglia, K. J. Martin, Gordon #&gt; Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus Mehta, Fionn #&gt; Murtagh, John C. Nash, Finbarr O&#39;Sullivan, R. E. Odeh, #&gt; William Patefield, Nitin Patel, Alan Richardson, D. E. #&gt; Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, #&gt; Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul, #&gt; Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan #&gt; Tsang, Berwin Turlach, Gary V. Vaughan, Michael Wichura, #&gt; Jingbo Wang, M. A. Wong, and the Free Software Foundation #&gt; (for autoconf code and utilities). See also files under #&gt; src/extras. #&gt; #&gt; Many more, too numerous to mention here, have #&gt; contributed by sending bug reports and suggesting various #&gt; improvements. #&gt; #&gt; Simon Davies whilst at the University of Auckland #&gt; wrote the original version of glm(). #&gt; #&gt; Julian Harris and Wing Kwong (Tiki) Wan whilst at the #&gt; University of Auckland assisted Ross Ihaka with the #&gt; original Macintosh port. #&gt; #&gt; R was inspired by the S environment which has been #&gt; principally developed by John Chambers, with substantial #&gt; input from Douglas Bates, Rick Becker, Bill Cleveland, #&gt; Trevor Hastie, Daryl Pregibon and Allan Wilks. #&gt; #&gt; A special debt is owed to John Chambers who has #&gt; graciously contributed advice and encouragement in the #&gt; early days of R and later became a member of the core team. #&gt; #&gt; The R Foundation may decide to give out #&gt; &lt;first.lastname&gt;@R-project.org email addresses to #&gt; contributors to the R Project (even without making them #&gt; members of the R Foundation) when in the view of the R #&gt; Foundation this would help advance the R project. #&gt; #&gt; The R Core Group, Roger Bivand, Jennifer Bryan, Di #&gt; Cook, Dirk Eddelbuettel, John Fox, Bettina Gr眉n, Frank #&gt; Harrell, Torsten Hothorn, Stefano Iacus, Julie Josse, #&gt; Balasubramanian Narasimhan, Marc Schwartz, Heather Turner, #&gt; Bill Venables, Hadley Wickham and Achim Zeileis are the #&gt; ordinary members of the R Foundation. In addition, David #&gt; Meyer and Simon Wood are also e-addressable by #&gt; &lt;Firstname&gt;.&lt;Lastname&gt;@R-project.org. # 除了段首，每一段的余下诸行都缩进5个字符 writeLines(strwrap(x, width = 60, exdent = 5)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; Michael A. Covington, Bill Cleveland, Robert #&gt; Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, #&gt; Paul Eggert, J. O. Evans, David M. Gay, H. Frick, G. #&gt; W. Hill, Richard H. Jones, Eric Grosse, Shelby #&gt; Haberman, Bruno Haible, John Hartigan, Andrew Harvey, #&gt; Trevor Hastie, Min Long Lam, George Marsaglia, K. J. #&gt; Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, #&gt; Cyrus Mehta, Fionn Murtagh, John C. Nash, Finbarr #&gt; O&#39;Sullivan, R. E. Odeh, William Patefield, Nitin #&gt; Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan #&gt; Tsang, Berwin Turlach, Gary V. Vaughan, Michael #&gt; Wichura, Jingbo Wang, M. A. Wong, and the Free #&gt; Software Foundation (for autoconf code and utilities). #&gt; See also files under src/extras. #&gt; #&gt; Many more, too numerous to mention here, have contributed #&gt; by sending bug reports and suggesting various #&gt; improvements. #&gt; #&gt; Simon Davies whilst at the University of Auckland wrote the #&gt; original version of glm(). #&gt; #&gt; Julian Harris and Wing Kwong (Tiki) Wan whilst at the #&gt; University of Auckland assisted Ross Ihaka with the #&gt; original Macintosh port. #&gt; #&gt; R was inspired by the S environment which has been #&gt; principally developed by John Chambers, with #&gt; substantial input from Douglas Bates, Rick Becker, #&gt; Bill Cleveland, Trevor Hastie, Daryl Pregibon and #&gt; Allan Wilks. #&gt; #&gt; A special debt is owed to John Chambers who has graciously #&gt; contributed advice and encouragement in the early days #&gt; of R and later became a member of the core team. #&gt; #&gt; The R Foundation may decide to give out #&gt; &lt;first.lastname&gt;@R-project.org email addresses to #&gt; contributors to the R Project (even without making #&gt; them members of the R Foundation) when in the view of #&gt; the R Foundation this would help advance the R #&gt; project. #&gt; #&gt; The R Core Group, Roger Bivand, Jennifer Bryan, Di Cook, #&gt; Dirk Eddelbuettel, John Fox, Bettina Gr眉n, Frank #&gt; Harrell, Torsten Hothorn, Stefano Iacus, Julie Josse, #&gt; Balasubramanian Narasimhan, Marc Schwartz, Heather #&gt; Turner, Bill Venables, Hadley Wickham and Achim #&gt; Zeileis are the ordinary members of the R Foundation. #&gt; In addition, David Meyer and Simon Wood are also #&gt; e-addressable by &lt;Firstname&gt;.&lt;Lastname&gt;@R-project.org. # 在输出的每一行前面添加前缀 writeLines(strwrap(x, prefix = &quot;THANKS&gt; &quot;)) #&gt; THANKS&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; THANKS&gt; Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. W. #&gt; THANKS&gt; Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. Evans, #&gt; THANKS&gt; David M. Gay, H. Frick, G. W. Hill, Richard H. Jones, Eric #&gt; THANKS&gt; Grosse, Shelby Haberman, Bruno Haible, John Hartigan, Andrew #&gt; THANKS&gt; Harvey, Trevor Hastie, Min Long Lam, George Marsaglia, K. J. #&gt; THANKS&gt; Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus #&gt; THANKS&gt; Mehta, Fionn Murtagh, John C. Nash, Finbarr O&#39;Sullivan, R. E. #&gt; THANKS&gt; Odeh, William Patefield, Nitin Patel, Alan Richardson, D. E. #&gt; THANKS&gt; Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, #&gt; THANKS&gt; Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul, #&gt; THANKS&gt; Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, #&gt; THANKS&gt; Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo Wang, #&gt; THANKS&gt; M. A. Wong, and the Free Software Foundation (for autoconf #&gt; THANKS&gt; code and utilities). See also files under src/extras. #&gt; THANKS&gt; #&gt; THANKS&gt; Many more, too numerous to mention here, have contributed by #&gt; THANKS&gt; sending bug reports and suggesting various improvements. #&gt; THANKS&gt; #&gt; THANKS&gt; Simon Davies whilst at the University of Auckland wrote the #&gt; THANKS&gt; original version of glm(). #&gt; THANKS&gt; #&gt; THANKS&gt; Julian Harris and Wing Kwong (Tiki) Wan whilst at the #&gt; THANKS&gt; University of Auckland assisted Ross Ihaka with the original #&gt; THANKS&gt; Macintosh port. #&gt; THANKS&gt; #&gt; THANKS&gt; R was inspired by the S environment which has been principally #&gt; THANKS&gt; developed by John Chambers, with substantial input from #&gt; THANKS&gt; Douglas Bates, Rick Becker, Bill Cleveland, Trevor Hastie, #&gt; THANKS&gt; Daryl Pregibon and Allan Wilks. #&gt; THANKS&gt; #&gt; THANKS&gt; A special debt is owed to John Chambers who has graciously #&gt; THANKS&gt; contributed advice and encouragement in the early days of R #&gt; THANKS&gt; and later became a member of the core team. #&gt; THANKS&gt; #&gt; THANKS&gt; The R Foundation may decide to give out #&gt; THANKS&gt; &lt;first.lastname&gt;@R-project.org email addresses to contributors #&gt; THANKS&gt; to the R Project (even without making them members of the R #&gt; THANKS&gt; Foundation) when in the view of the R Foundation this would #&gt; THANKS&gt; help advance the R project. #&gt; THANKS&gt; #&gt; THANKS&gt; The R Core Group, Roger Bivand, Jennifer Bryan, Di Cook, Dirk #&gt; THANKS&gt; Eddelbuettel, John Fox, Bettina Gr眉n, Frank Harrell, Torsten #&gt; THANKS&gt; Hothorn, Stefano Iacus, Julie Josse, Balasubramanian #&gt; THANKS&gt; Narasimhan, Marc Schwartz, Heather Turner, Bill Venables, #&gt; THANKS&gt; Hadley Wickham and Achim Zeileis are the ordinary members of #&gt; THANKS&gt; the R Foundation. In addition, David Meyer and Simon Wood are #&gt; THANKS&gt; also e-addressable by &lt;Firstname&gt;.&lt;Lastname&gt;@R-project.org. 再举一个烧脑的例子 x &lt;- paste(sapply( sample(10, 100, replace = TRUE), # 从1-10个数字中有放回的随机抽取100个数 function(x) substring(&quot;aaaaaaaaaa&quot;, 1, x) ), collapse = &quot; &quot;) sapply( 10:40, function(m) c(target = m, actual = max(nchar(strwrap(x, m)))) ) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #&gt; target 10 11 12 13 14 15 16 17 18 19 20 21 22 #&gt; actual 10 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #&gt; target 23 24 25 26 27 28 29 30 31 32 33 34 #&gt; actual 22 23 24 25 26 27 28 29 30 31 32 33 #&gt; [,26] [,27] [,28] [,29] [,30] [,31] #&gt; target 35 36 37 38 39 40 #&gt; actual 34 35 36 36 38 39 9.9.2 strtrim strtrim(x, width) strtrim 函数将字符串x修剪到特定的显示宽度，返回的字符串向量的长度等于字符串向量 x 的长度，如果 width 的参数值（它是一个整型向量）的长度小于 x 的，就循环补齐。 strtrim(c(&quot;abcdef&quot;, &quot;abcdef&quot;, &quot;abcdef&quot;), c(1, 5, 10)) #&gt; [1] &quot;a&quot; &quot;abcde&quot; &quot;abcdef&quot; 9.9.3 strrep strrep(x, times) 以给定的次数重复字符串向量中每个元素的个数，并连接字符串的各个副本 strrep(&quot;ABC&quot;, 2) #&gt; [1] &quot;ABCABC&quot; strrep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1 : 3) #&gt; [1] &quot;A&quot; &quot;BB&quot; &quot;CCC&quot; # 创建一个字符串向量，指定每个元素中空格的数量 strrep(&quot; &quot;, 1 : 5) #&gt; [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; 9.9.4 trimws trimws(x, which = c(&quot;both&quot;, &quot;left&quot;, &quot;right&quot;), whitespace = &quot;[ \\t\\r\\n]&quot;) trimws 函数用于移除字符串中的空格，这种空格可以来自制表符、回车符和换行符，位置可以位于字符串的开头或者结尾，which 参数指定空格的大致位置。举例如下 x &lt;- &quot; Some text. &quot; x #&gt; [1] &quot; Some text. &quot; trimws(x) #&gt; [1] &quot;Some text.&quot; trimws(x, &quot;l&quot;) #&gt; [1] &quot;Some text. &quot; trimws(x, &quot;r&quot;) #&gt; [1] &quot; Some text.&quot; https://homepage.divms.uiowa.edu/~luke/R/regexp.html↩ "],
["11-data-cleaning-with-stringr.html", "第 10 章 数据清洁工 10.1 处理性能 10.2 网络爬虫 10.3 文本挖掘", " 第 10 章 数据清洁工 相比于第9章，本章主要介绍字符串处理 stringr 包以及一些数据清理的高级应用。 Handling Strings with R 和 R for Data Science 提供字符串入门介绍 ，Sara Stoudt 整理了 stringr 包与 Base R 正则表达式函数的对应表 https://stringr.tidyverse.org/articles/from-base.html stringr 基于 stringi 包字符串处理包， re2r 包基于 Google 开发的 C++ 库 re2，Google 编程之夏项目提供了一份 正则表达式性能综述 janitor Manipulating strings with the stringr package filesstrings 基于 stringr 操作字符串 strex 一些没有包含在 stringr 或者 stringi 中的字符串操作函数 10.1 处理性能 当你对一个很长的字符串进行大量的正则表达式匹配的时候，你需要考虑性能问题了，这时候该考虑启用合适的选项，一般来讲， PCRE 比默认的正则表达式引擎快，fixed=TRUE 可以继续加快匹配速度，特别是当每个模式只匹配少量次数时。 连接字符串，paste/c/bfile/bracket 函数性能比较 https://wch.github.io/string_builder/index.html R 内置的默认正则表达式匹配方式是基于 PCRE 的匹配，options 控制 PCRE 默认的三个选项 PCRE_limit_recursion=NA 、PCRE_study=10 和 PCRE_use_JIT=TRUE，当前系统环境下 PCRE 的支持情况 pcre_config() #&gt; UTF-8 Unicode properties JIT stack #&gt; TRUE TRUE FALSE TRUE 查看R环境的 PCRE 配置 sapply(c(&quot;PCRE_limit_recursion&quot;, &quot;PCRE_study&quot;, &quot;PCRE_use_JIT&quot;), getOption) #&gt; PCRE_limit_recursion PCRE_study PCRE_use_JIT #&gt; NA 10 1 10.2 网络爬虫 用 R 语言写爬虫 curl、httr、 xml2、XML 和 rvest 解析网页27 # 查看 libcurl 库的版本 libcurlVersion() #&gt; [1] &quot;7.59.0&quot; #&gt; attr(,&quot;ssl_version&quot;) #&gt; [1] &quot;OpenSSL/1.0.2n (WinSSL)&quot; #&gt; attr(,&quot;libssh_version&quot;) #&gt; [1] &quot;libssh2/1.8.0&quot; #&gt; attr(,&quot;protocols&quot;) #&gt; [1] &quot;dict&quot; &quot;file&quot; &quot;ftp&quot; &quot;ftps&quot; &quot;gopher&quot; &quot;http&quot; &quot;https&quot; &quot;imap&quot; #&gt; [9] &quot;imaps&quot; &quot;ldap&quot; &quot;ldaps&quot; &quot;pop3&quot; &quot;pop3s&quot; &quot;rtsp&quot; &quot;scp&quot; &quot;sftp&quot; #&gt; [17] &quot;smtp&quot; &quot;smtps&quot; &quot;telnet&quot; &quot;tftp&quot; 于主编利用 tidyRSS 包 抓取解析博客站点的订阅信息，并将此设置为定时任务，创建自动更新内容的博客聚合网站 Daily R 抓取地震台信息 10.3 文本挖掘 How did Axios rectangle Trump’s PDF schedule? A try with R 使用 pdftools 和 magick 处理表格，这两个 R 包分别依赖 Poppler C++ 和 ImageMagick++，在 Ubuntu 上安装 pdftools 和 magick 包 sudo apt-get install libpoppler-cpp-dev libmagick++-dev install.packages(c(&quot;pdftools&quot;, &quot;magick&quot;)) 除了 pdftools 包外，PDF 文档中表格抽取工具还有 tabulizer。扫描版 PDF 文档需要OCR识别技术支持的 tesseract 包 Jeroen Ooms 已经确认 RCurl 早已经不再维护，取代它的是 curl/httr，不要使用不再维护的 R 包 https://frie.codes/curl-vs-rcurl/↩ "],
["12-data-cleaning-with-regexp.html", "第 11 章 正则表达式 11.1 字符常量 11.2 软件环境 11.3 基本概念 11.4 字符串匹配 11.5 级联表达式 11.6 反向引用 11.7 命名捕捉 11.8 表达式注释", " 第 11 章 正则表达式 维基百科关于 正则表达式的描述， 学习正则表达式 R 内置的三种匹配模式 fixed = TRUE: 字面意思匹配 exact matching. perl = TRUE: 使用 Perl 正则表达式. fixed = FALSE, perl = FALSE: 使用 POSIX 1003.2 extended 正则表达式 (默认设置). 不要拘泥于一种解决方案，比如清理数据中正则表达式有 Base R 提供的一套，stringr 又一套，提高效率的工具 RStudio 插件 regexplain 和辅助创建正则表达式 RVerbalExpressions 包 有几个名词需要单独拎出来解释的 literal character strings 字面字符串 metacharacters 元字符 extended regular expressions 在下文中约定翻译为默认正则表达式 character class 字符集 [abc] Perl-like regular expressions Perl 风格的正则表达式 以下所述，都不考虑函数中参数 perl=TRUE 的情况，R 语言中提供了扩展的（默认的）和 Perl 风格 的两套正则表达式。作为入门，我们这里只关注前者，启用 Perl 正则表达式只需在函数如 grep 中将选项 perl = TRUE 即可，并将后者统一命名为 Perl 正则表达式28。 正则表达式 (regular expression，简称 regexp)， 函数 regexpr 和 gregexpr 的名称就好理解了，在控制台输入 ?regex 查看 R 支持的正则表达式，这个文档看上百八十回也不过分。R 内支持正则表达式的函数有 grep、grepl、sub、gsub、regexpr、gregexpr 、 regexec 和 strsplit。函数 apropos，browseEnv，help.search，list.files 和 ls 是通过函数 grep 来使用正则表达式的，它们全都使用 extended regular expressions grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE) 匹配模式 pattern 的内容 可以用函数 cat 打印出来，注意反斜杠进入 R 字符串中时，需要用两个，反斜杠 \\ 本身是转义符，否则会报错。 cat(&quot;\\\\&quot;) # \\ 反斜杠是转义字符 #&gt; \\ cat(&quot;\\\\.&quot;) #&gt; \\. cat(&quot;\\\\\\n&quot;) # 注意 \\n 表示换行 #&gt; \\ 11.1 字符常量 单引号 ' 双引号 \" 和反引号 ` 三种类型的引用 (quotes) 是 R 语法的一部分29，此外反斜杠 \\ 用来转义下面的字符 表 11.1: 字符常量表 字符常量 含义 \\n 换行 newline \\r 回车 carriage return \\t 制表符 tab \\b 退格 backspace \\a 警报（铃）alert (bell) \\f 换页 form feed \\v 垂直制表符 vertical tab \\\\ 反斜杠 backslash \\ \\' 单引号 ASCII apostrophe ' \\\" 双引号 ASCII quotation mark \" \\` 反引号或沉音符 ASCII grave accent (backtick) ` \\nnn 八进制 character with given octal code (1, 2 or 3 digits) \\xnn 十六进制 character with given hex code (1 or 2 hex digits) \\unnnn Unicode character with given code (1–4 hex digits) \\Unnnnnnnn Unicode character with given code (1–8 hex digits) 11.2 软件环境 R 内置的正则表达式实现是基于 PCRE ICU TRE iconv 等第三方库，搞清楚自己使用的版本信息是重要的，一些字符集的解释与区域环境有关，如 [:alnum:] 和 [:alpha:]等，所以获取当前的区域设置也很重要 # find a suitable coding for the current locale localeToCharset(locale = Sys.getlocale(&quot;LC_CTYPE&quot;)) #&gt; [1] &quot;CP936&quot; # 软件版本信息 extSoftVersion() #&gt; zlib bzlib xz #&gt; &quot;1.2.11&quot; &quot;1.0.6, 6-Sept-2010&quot; &quot;5.2.3&quot; #&gt; PCRE ICU TRE #&gt; &quot;8.42 2018-03-20&quot; &quot;55.1&quot; &quot;TRE 0.8.0 R_fixes (BSD)&quot; #&gt; iconv readline BLAS #&gt; &quot;win_iconv&quot; &quot;&quot; &quot;&quot; # 区域及其编码信息 l10n_info() #&gt; $MBCS #&gt; [1] TRUE #&gt; #&gt; $`UTF-8` #&gt; [1] FALSE #&gt; #&gt; $`Latin-1` #&gt; [1] FALSE #&gt; #&gt; $codepage #&gt; [1] 936 # 表示数字、货币的细节 Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;CNY&quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;￥&quot; &quot;.&quot; &quot;,&quot; &quot;\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;4&quot; &quot;4&quot; # PCRE 启用的配置选项 pcre_config() #&gt; UTF-8 Unicode properties JIT stack #&gt; TRUE TRUE FALSE TRUE # 比较全的字符信息 stringi::stri_info() #&gt; Warning in stringi::stri_info(): Your native charset does not map to Unicode #&gt; well. This may cause serious problems. Consider switching to UTF-8. #&gt; Warning in stringi::stri_info(): Your current locale is not in the list #&gt; of available locales. Some functions may not work properly. Refer to #&gt; stri_locale_list() for more details on known locale specifiers. #&gt; $Unicode.version #&gt; [1] &quot;10.0&quot; #&gt; #&gt; $ICU.version #&gt; [1] &quot;61.1&quot; #&gt; #&gt; $Locale #&gt; $Locale$Language #&gt; [1] &quot;zh&quot; #&gt; #&gt; $Locale$Country #&gt; [1] &quot;CN&quot; #&gt; #&gt; $Locale$Variant #&gt; [1] &quot;&quot; #&gt; #&gt; $Locale$Name #&gt; [1] &quot;zh_CN&quot; #&gt; #&gt; #&gt; $Charset.internal #&gt; [1] &quot;UTF-8&quot; &quot;UTF-16&quot; #&gt; #&gt; $Charset.native #&gt; $Charset.native$Name.friendly #&gt; [1] &quot;GBK&quot; #&gt; #&gt; $Charset.native$Name.ICU #&gt; [1] &quot;windows-936-2000&quot; #&gt; #&gt; $Charset.native$Name.UTR22 #&gt; [1] &quot;windows-936-2000&quot; #&gt; #&gt; $Charset.native$Name.IBM #&gt; [1] NA #&gt; #&gt; $Charset.native$Name.WINDOWS #&gt; [1] &quot;windows-936&quot; #&gt; #&gt; $Charset.native$Name.JAVA #&gt; [1] &quot;GBK&quot; #&gt; #&gt; $Charset.native$Name.IANA #&gt; [1] &quot;GBK&quot; #&gt; #&gt; $Charset.native$Name.MIME #&gt; [1] NA #&gt; #&gt; $Charset.native$ASCII.subset #&gt; [1] TRUE #&gt; #&gt; $Charset.native$Unicode.1to1 #&gt; [1] NA #&gt; #&gt; $Charset.native$CharSize.8bit #&gt; [1] FALSE #&gt; #&gt; $Charset.native$CharSize.min #&gt; [1] 1 #&gt; #&gt; $Charset.native$CharSize.max #&gt; [1] 2 #&gt; #&gt; #&gt; $ICU.system #&gt; [1] FALSE #&gt; #&gt; $ICU.UTF8 #&gt; [1] FALSE 需要临时改变区域环境设置，配合特殊的画图和文本输出要求。 # 获取当前默认的区域设置 foo &lt;- Sys.getlocale() # 恢复默认的区域设置 Sys.setlocale(&quot;LC_ALL&quot;, locale = foo) 11.3 基本概念 正则表达式的构造方式类似算术表达式，通过各种操作组合子（更小的）表达式，整个表达式匹配一个或多个字符30。大多数字符，包括所有的字母和数字，是匹配自身的正则表达式。元字符 . \\ | ( ) [ { ^ $ * + ? 需要转义才能表达其自身的含义，转义的方式是在元字符前面添加反斜杠，如要表达点号 . 需要使用 \\.。要注意，它们是否有特殊意义取决于所在的内容。 一个字符集 (character class) 是用一对中括号[]括起来的字符列表，用来匹配列表中的任意单个字符，除非列表中的第一个字符是 ^，它用来匹配不在这个列表中的字符。 [0123456789] 用来匹配任意单个数字，[^abc] 用来匹配除字符 a,b,c 以外的任意字符。字符范围 (character ranges) 可以通过第一个和最后一个字符指定， 中间用连字符 (hyphen) 连接， 由于这种解释依赖于区域和具体实现，所以指定字符范围的使用方式最好避免。唯一可移植（便携，通用）的方式是作为字符集，在列表中列出所有的 ASCII 字母， [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]. 预定义的一些字符类，它们的解释依赖于当前的语言区域，下面是 POSIX locale 环境下的解释 [:alnum:] 表示 [:alpha:] 和 [:digit:]，含义是 [0-9A-Za-z]，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号 [] 是符号名的一部分，是必须要包含的。在字符集中，大多数元字符失去它们特殊的意义。 [:alpha:] 表示 [:lower:] 和 [:upper:] [:blank:] 表示 空格 space 制表符 tab [:cntrl:] 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。 [:digit:] 表示数字 0,1,2,3,4,5,6,7,8,9 [:graph:] 表示 [:alnum:] 和 [:punct:]. [:lower:] 表示当前区域下的小写字母 [:print:] 表示可打印的字符 [:alnum:], [:punct:] 和空格. [:punct:] 表示标点字符 ! &quot; # $ % &amp; &#39; ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { | } ~` [:space:] 表示空格字符： 水平制表符 tab， 换行符 newline，垂直制表符 vertical tab，换页符 form feed，回车符 carriage return，空格符 space [:xdigit:] 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f. 要包含字面的 ] 就把它放在列表的开头，类似地，要包含字面 ^，除了开头可以放在任意位置。要包含字面 - 把它放在开头或者结尾。只有 ^ - \\ ] 在字符集内是有特殊的含义 点号 . 匹配任意单个字符，\\w 匹配一个词 word 字符(是[[:alnum:]_]的同义词，一个扩展) ，而 \\W 是 \\w 取反，意味着 [^[:alnum:]_]。 \\d, \\s, \\D 和 \\S 表示数字和空格类和它们的取反 脱字符 caret ^ 和美元符号 $ 是元字符，分别匹配一行的开头和结尾。符号 \\&lt; 和 \\&gt; 分别匹配一个词的开头和结尾的空字符串。\\b 匹配词边缘的空字符串，\\B 匹配不在词边缘的空字符串。 词 word 的解释依赖于区域和实现。 11.4 字符串匹配 默认的匹配方式是贪婪的，会使用尽可能多的匹配次数，这个可以变为最小的匹配次数，通过在其之后添加 ?，一个正则表达式可能跟着重复量词，下面的限定符都是限定在它前面的正则表达式 表 11.2: 贪婪匹配限定符 符号 描述 ? 匹配至多 1 次 * 匹配 0 次或多次 + 匹配至少 1 次 {n} 匹配 n 次 {n,} 匹配至少 n 次 {n,m} 匹配至少 n 次，至多 m 次 11.5 级联表达式 Regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating the substrings that match the concatenated subexpressions. 正则表达式可以是级联 concatenation 的，是不是在讲一个正则表达式里面嵌套一个正则表达式？ 两个正则表达式可以通过中缀符号 | 联合，用两个子表达式的任意一个去匹配字符串，例如 abba | cde 要么匹配字符串 abba 要么匹配字符串 cde，要注意在字符集内，即 abba|cde，二选一的匹配不凑效，因为中缀符 | 有它的字面意思。 重复匹配 Repetition 的优先级高于级联，级联高于 | 。 整个子表达式可以括号括起来覆盖这些优先级规则。 11.6 反向引用 反向引用 \\N 这里 N 可取 1,2,…,9 匹配被之前第 N 个括起来的子表达式匹配的子字符串，例子见 COS 论坛 https://d.cosx.org/d/420570/5 11.7 命名捕捉 模式 (?:...) 包住的字符就是括号分组，但是不做反向查找。模式 (?&lt;=...) 和 (?&lt;!...) 都是反向查找，它们不允许跟限制符，在 ... 也不允许出现 \\C。表 11.3 展示四个反向引用 表 11.3: 环顾四周查找 符号 描述 ?= 正向肯定查找 ?! 正向否定查找 ?&lt;= 反向肯定查找 ?&lt;! 反向否定查找 函数 regexpr 和 gregexpr 支持命名捕捉 (named capture). 如果一个组被命名了，如 (?&lt;first&gt;[A-Z][a-z]+) 那么，匹配的位置是按名字返回。 下面举个例子说明，从字符串向量 notables 中获得了三组匹配 name.rex 是一段正则表达式，描述的模式是人名 ## named capture notables &lt;- c(&quot; Ben Franklin and Jefferson Davis&quot;, &quot;\\tMillard Fillmore&quot;) # name groups &#39;first&#39; and &#39;last&#39; name.rex &lt;- &quot;(?&lt;first&gt;[[:upper:]][[:lower:]]+) (?&lt;last&gt;[[:upper:]][[:lower:]]+)&quot; parsed &lt;- regexpr(name.rex, notables, perl = TRUE) parsed #&gt; [1] 3 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 12 16 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; attr(,&quot;capture.start&quot;) #&gt; first last #&gt; [1,] 3 7 #&gt; [2,] 2 10 #&gt; attr(,&quot;capture.length&quot;) #&gt; first last #&gt; [1,] 3 8 #&gt; [2,] 7 8 #&gt; attr(,&quot;capture.names&quot;) #&gt; [1] &quot;first&quot; &quot;last&quot; notables 是一个长度为2的字符串向量，所以获得两组匹配，捕捉到匹配开始的位置 capture.start 和匹配的长度 capture.length 都是两组，按列来看，字符 B 出现在字符串 Ben Franklin and Jefferson Davis 的第三个位置，匹配的长度 Ben 是三个字符，长度是 3，如图 11.1 所示，需要注意的是一定要设置 perl = TRUE 才能使用命名捕捉功能，函数 sub 不支持命名反向引用 Named backreferences knitr::include_graphics(path = &quot;figures/name-capture.png&quot;) 图 11.1: 命名捕捉 Atomic grouping 原子分组, possessive qualifiers 占有限定 and conditional 条件 and recursive 递归等模式超出介绍的范围，不在此处详述，感兴趣的读者可参考，此外，插播一条漫画 11.2 图 11.2: 正则表达式漫画 正则表达式的直观解释 https://github.com/gadenbuie/regexplain 11.8 表达式注释 The sequence (?# marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part at all in the pattern matching. If the extended option is set, an unescaped # character outside a character class introduces a comment that continues up to the next newline character in the pattern. 推荐的学习正则表达式的路径可以见统计之都论坛 https://d.cosx.org/d/420410↩ https://stat.ethz.ch/R-manual/R-devel/library/base/html/Quotes.html↩ useBytes = TRUE 表示把字符看作字节。字符、字节和比特的关系是，一个字节 byte 八个比特 bit，一个英文字符 character 用一个字节表示，而一个中、日、韩文字符需要两个字节表示↩ "],
["13-data-visualization-with-plot.html", "第 12 章 绘图素材库 12.1 基本要素 12.2 统计图形 12.3 TikZ 绘图 12.4 图形导出", " 第 12 章 绘图素材库 作为知识介绍，本章所有数据都来源于基础 R 包，即安装 R 软件后自带的数据集，图库在以 base R 中的数据集介绍完后，以相应真实数据扩展为案列，结合统计意义和探索性数据分析介绍各种常见统计图形 数据可视化是一种重要的数据分析手段， R 提供了两套图形系统，分别是 graphics 包提供的基础绘图系统和 grid 包提供的栅格绘图系统，后者主要以两个 R 包为大家所熟知，一个是 lattice 包，另一个是 ggplot2 包。 Base 图形系统的扩展包 prettyB 和 gridGraphics 为了方便记忆函数 par 的各个参数，Paul Murrell 整理了一份 助记符，此外，LaTeX 宏包 geometry 对版面设置有很多专业的说明 12.1 基本要素 12.1.1 点线 点和线是最常见的画图元素，在 plot 函数中，分别用参数 pch 和 lty 来设定类型，点的大小、线的宽度分别用参数 cex 和 lwd 来指定，颜色由参数 col 设置。参数 type 不同的值设置如下，p 显示点，l 绘制线，b 同时绘制空心点，并用线连接，c 只有线，o 在线上绘制点，s 和 S 点线连接绘制阶梯图，h 绘制类似直方图一样的垂线，最后 n 表示什么也不画。 点 points 、线 grid 背景线 abline lines rug 刻度线（线段segments、箭头arrows）、 ## -------- Showing all the extra &amp; some char graphics symbols --------- pchShow &lt;- function(extras = c(&quot;*&quot;, &quot;.&quot;, &quot;o&quot;, &quot;O&quot;, &quot;0&quot;, &quot;+&quot;, &quot;-&quot;, &quot;|&quot;, &quot;%&quot;, &quot;#&quot;), cex = 2, ## good for both .Device==&quot;postscript&quot; and &quot;x11&quot; col = &quot;red3&quot;, bg = &quot;gold&quot;, coltext = &quot;brown&quot;, cextext = 1.2, main = paste( &quot;plot symbols : points (... pch = *, cex =&quot;, cex, &quot;)&quot; )) { nex &lt;- length(extras) np &lt;- 26 + nex ipch &lt;- 0:(np - 1) k &lt;- floor(sqrt(np)) dd &lt;- c(-1, 1) / 2 rx &lt;- dd + range(ix &lt;- ipch %/% k) ry &lt;- dd + range(iy &lt;- 3 + (k - 1) - ipch %% k) pch &lt;- as.list(ipch) # list with integers &amp; strings if (nex &gt; 0) pch[26 + 1:nex] &lt;- as.list(extras) plot(rx, ry, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, main = main) abline(v = ix, h = iy, col = &quot;lightgray&quot;, lty = &quot;dotted&quot;) for (i in 1:np) { pc &lt;- pch[[i]] ## &#39;col&#39; symbols with a &#39;bg&#39;-colored interior (where available) : points(ix[i], iy[i], pch = pc, col = col, bg = bg, cex = cex) if (cextext &gt; 0) { text(ix[i] - 0.3, iy[i], pc, col = coltext, cex = cextext) } } } pchShow() 图 12.1: 不同的 pch 参数值 ## ------------ test code for various pch specifications ------------- # Try this in various font families (including Hershey) # and locales. Use sign = -1 asserts we want Latin-1. # Standard cases in a MBCS locale will not plot the top half. TestChars &lt;- function(sign = 1, font = 1, ...) { MB &lt;- l10n_info()$MBCS r &lt;- if (font == 5) { sign &lt;- 1 c(32:126, 160:254) } else if (MB) 32:126 else 32:255 if (sign == -1) r &lt;- c(32:126, 160:255) par(pty = &quot;s&quot;) plot(c(-1, 16), c(-1, 16), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxs = &quot;i&quot;, yaxs = &quot;i&quot;, main = sprintf(&quot;sign = %d, font = %d&quot;, sign, font) ) grid(17, 17, lty = 1) mtext(paste(&quot;MBCS:&quot;, MB)) for (i in r) try(points(i %% 16, i %/% 16, pch = sign * i, font = font, ...)) } TestChars() try(TestChars(sign = -1)) TestChars(font = 5) # Euro might be at 160 (0+10*16). # macOS has apple at 240 (0+15*16). try(TestChars(-1, font = 2)) # bold 图 12.2: pch 支持的字符 x &lt;- 0:12 y &lt;- sin(pi / 5 * x) par(mfrow = c(3, 3), mar = .1 + c(2, 2, 3, 1)) for (tp in c(&quot;p&quot;, &quot;l&quot;, &quot;b&quot;, &quot;c&quot;, &quot;o&quot;, &quot;h&quot;, &quot;s&quot;, &quot;S&quot;, &quot;n&quot;)) { plot(y ~ x, type = tp, main = paste0(&quot;plot(*, type = \\&quot;&quot;, tp, &quot;\\&quot;)&quot;)) if (tp == &quot;S&quot;) { lines(x, y, type = &quot;s&quot;, col = &quot;red&quot;, lty = 2) mtext(&quot;lines(*, type = \\&quot;s\\&quot;, ...)&quot;, col = &quot;red&quot;, cex = 0.8) } } 图 12.3: 不同的 type 参数值 颜色 col 连续型和离散型 线帽/端和字体的样式 # 合并为一个图 三条粗横线 横线上三种字形 plot(c(1, 20), c(1, 20), type = &quot;n&quot;, ann = FALSE) lines(x = c(5, 15), y = c(5, 5), lwd = 15, lend = &quot;round&quot;) text(10, 5, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;sans&quot;, pos = 1, offset = 1.5) text(5, 5, &quot;sans&quot;, cex = 1.5, family = &quot;sans&quot;, pos = 2, offset = .5) text(15, 5, &quot;lend = round&quot;, pos = 4, offset = .5) lines(x = c(5, 15), y = c(10, 10), lwd = 15, lend = &quot;butt&quot;) text(10, 10, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;mono&quot;, pos = 1, offset = 1.5) text(5, 10, &quot;mono&quot;, cex = 1.5, family = &quot;mono&quot;, pos = 2, offset = .5) text(15, 10, &quot;lend = butt&quot;, pos = 4, offset = .5) lines(x = c(5, 15), y = c(15, 15), lwd = 15, lend = &quot;square&quot;) text(10, 15, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;serif&quot;, pos = 1, offset = 1.5) text(5, 15, &quot;serif&quot;, cex = 1.5, family = &quot;serif&quot;, pos = 2, offset = .5) text(15, 15, &quot;lend = square&quot;, pos = 4, offset = .5) 图 12.4: 不同的线端样式 lend：线端的样式，可用一个整数或字符串指定： 0 或 “round” 圆形（默认） 1 或 “butt” 对接形 2 或 “square” 方形 12.1.2 区域 矩形，多边形，曲线交汇出来的区域 面（矩形rect，多边形polygon）、路径 polypath 面/多边形 rect 颜色填充 # From the manual ch.col &lt;- c( &quot;rainbow(n, start=.7, end=.1)&quot;, &quot;heat.colors(n)&quot;, &quot;terrain.colors(n)&quot;, &quot;topo.colors(n)&quot;, &quot;cm.colors(n)&quot; ) # 选择颜色 n &lt;- 16 nt &lt;- length(ch.col) i &lt;- 1:n j &lt;- n / nt d &lt;- j / 6 dy &lt;- 2 * d plot(i, i + d, type = &quot;n&quot;, yaxt = &quot;n&quot;, ylab = &quot;&quot;, xlab = &quot;&quot;, main = paste(&quot;color palettes; n=&quot;, n) ) for (k in 1:nt) { rect(i - .5, (k - 1) * j + dy, i + .4, k * j, col = eval(parse(text = ch.col[k])) ) # 咬人的函数/字符串解析为/转函数 text(2 * j, k * j + dy / 4, ch.col[k]) } 图 12.5: rect 函数画长方形 clip(x1, x2, y1, y2) 在用户坐标中设置剪切区域 x &lt;- rnorm(1000) hist(x, xlim = c(-4,4)) usr &lt;- par(&quot;usr&quot;) clip(usr[1], -2, usr[3], usr[4]) hist(x, col = &#39;red&#39;, add = TRUE) clip(2, usr[2], usr[3], usr[4]) hist(x, col = &#39;blue&#39;, add = TRUE) do.call(&quot;clip&quot;, as.list(usr)) # reset to plot region my.col &lt;- function(f, g, xmin, xmax, col, N = 200, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;) { x &lt;- seq(xmin, xmax, length = N) fx &lt;- f(x) gx &lt;- g(x) plot(0, 0, type = &quot;n&quot;, xlim = c(xmin, xmax), ylim = c(min(fx, gx), max(fx, gx)), xlab = xlab, ylab = ylab, main = main ) polygon(c(x, rev(x)), c(fx, rev(gx)), col = &quot;#EA4335&quot;, border = 0 ) lines(x, fx, lwd = 3, col = &quot;#34A853&quot;) lines(x, gx, lwd = 3, col = &quot;#4285f4&quot;) } my.col(function(x) x^2, function(x) x^2 + 10 * sin(x), -6, 6, main = &quot;The \\&quot;polygon\\&quot; function&quot; ) 图 12.6: 区域重叠 polygon 函数 各种符号 12.7 plot(0, 0, xlim = c(1, 5), ylim = c(-.5, 4), axes = F, xlab = &quot;&quot;, ylab = &quot;&quot; ) for (i in 0:4) { for (j in 1:5) { n &lt;- 5 * i + j points(j, i, pch = n, cex = 3 ) text(j, i - .3, as.character(n)) } } 图 12.7: cex 支持的符号 点、线、多边形和圆聚集在图 12.8 中 # https://jeroen.github.io/uros2018/#23 plot.new() plot.window(xlim = c(0, 100), ylim = c(0, 100)) polygon(c(10, 40, 80), c(10, 80, 40), col = &quot;hotpink&quot;) text(40, 90, labels = &quot;My drawing&quot;, col = &quot;navyblue&quot;, cex = 3) symbols(c(70, 80, 90), c(20, 50, 80), circles = c(10, 20, 10), bg = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;, &quot;red&quot;), add = TRUE, lty = &quot;dashed&quot; ) 图 12.8: 多边形和符号元素 在介绍各种统计图形之前，先介绍几个绘图函数 plot 和 text 还有 par 参数设置， 作为最简单的开始，尽量依次介绍其中的每个参数的含义并附上图形对比。 y &lt;- x &lt;- 1:4 plot(x, y, ann = F, col = &quot;blue&quot;, pch = 16) text(x, y, labels = c(&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;), col = &quot;red&quot;, pos = c(3, 4, 4, 1), offset = 0.6 ) ahat &lt;- &quot;sigma&quot; # title(substitute(hat(a) == ahat, list(ahat = ahat))) title(bquote(hat(a) == .(ahat))) 图 12.9: pos 位置参数 其中 labels， pos 都是向量化的参数 12.1.3 参考线 矩形网格线是用做背景参考线的，常常是淡灰色的细密虚线，plot 函数的 panel.first 参数和 grid 函数常用来画这种参考线 # modified from https://yihui.name/cn/2018/02/cohen-s-d/ n = 30 # 样本量（只是一个例子） x = seq(0, 12, 0.01) par(mar = c(4, 4, 0.2, 0.1)) plot(x/sqrt(n), 2 * (1 - pt(x, n - 1)), xlab = expression(d = x/sqrt(n)), type = &quot;l&quot;, panel.first = grid()) abline(v = c(0.01, 0.2, 0.5, 0.8, 1.2, 2), lty = 2) 图 12.10: 添加背景参考线 12.1.4 坐标轴 # 双Y轴 N &lt;- 200 x &lt;- seq(-4, 4, length = N) y1 &lt;- sin(x) y2 &lt;- cos(x) op &lt;- par(mar = c(5, 4, 4, 4)) # Add some space in the right margin # The default is c(5,4,4,2) + .1 xlim &lt;- range(x) ylim &lt;- c(-1.1, 1.1) plot(x, y1, col = &quot;blue&quot;, type = &quot;l&quot;, xlim = xlim, ylim = ylim, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Title&quot; ) axis(1) axis(2, col = &quot;blue&quot;) par(new = TRUE) plot(x, y2, col = &quot;red&quot;, type = &quot;l&quot;, xlim = xlim, ylim = ylim, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot; ) axis(4, col = &quot;red&quot;) mtext(&quot;First Y axis&quot;, 2, line = 2, col = &quot;blue&quot;, cex = 1.2) mtext(&quot;Second Y axis&quot;, 4, line = 2, col = &quot;red&quot;, cex = 1.2) # 1,2,3,4 分别代表下左上右四个位置 图 12.11: 两个 Y 轴 调整坐标轴标签的距离 ## Changing default gap between labels: plot(c(0,100),c(0,50), type=&quot;n&quot;, axes=FALSE, ann=FALSE) title(quote(&quot;axis(1, .., gap.axis = f),&quot; ~~ f &gt;= 0)) axis(2, at = 5*(0:10), las = 1, gap.axis = 1/4) gaps &lt;- c(4, 2, 1, 1/2, 1/4, 0.1, 0) chG &lt;- paste0(ifelse(gaps == 1, &quot;default: &quot;, &quot;&quot;), &quot;gap.axis=&quot;, formatC(gaps)) jj &lt;- seq_along(gaps) linG &lt;- -2.5*(jj-1) for(j in jj) { isD &lt;- gaps[j] == 1 # is default axis (1, at=5*(0:20), gap.axis = gaps[j], padj=-1, line = linG[j], col.axis = if(isD) &quot;forest green&quot; else 1, font.axis= 1+isD) } mtext(chG, side=1, padj=-1, line = linG -1/2, cex=3/4, col = ifelse(gaps == 1, &quot;forest green&quot;, &quot;blue3&quot;)) ## now shrink the window (in x- and y-direction) and observe the axis labels drawn 图 12.12: gap.axis用法 旋转坐标轴标签 # Rotated axis labels in R plots # https://menugget.blogspot.com/2014/08/rotated-axis-labels-in-r-plots.html # Example data tmin &lt;- as.Date(&quot;2000-01-01&quot;) tmax &lt;- as.Date(&quot;2001-01-01&quot;) tlab &lt;- seq(tmin, tmax, by = &quot;month&quot;) lab &lt;- format(tlab, format = &quot;%Y-%b&quot;) set.seed(111) x &lt;- seq(tmin, tmax, length.out = 100) y &lt;- cumsum(rnorm(100)) # Plot # png(&quot;plot_w_rotated_axis_labels.png&quot;, height = 3, # width = 6, units = &quot;in&quot;, res = 300) op &lt;- par(mar = c(6, 4, 1, 1)) plot(x, y, t = &quot;l&quot;, xaxt = &quot;n&quot;, xlab = &quot;&quot;) axis(1, at = tlab, labels = FALSE) text( x = tlab, y = par()$usr[3] - 0.1 * (par()$usr[4] - par()$usr[3]), labels = lab, srt = 45, adj = 1, xpd = TRUE ) par(op) # dev.off() 旋转坐标抽标签的例子来自手册《R FAQ》的第7章第27个问题 (Hornik 2018)，在基础图形中，旋转坐标轴标签需要 text() 而不是 mtext()，因为后者不支持par(\"srt\") ## Increase bottom margin to make room for rotated labels par(mar = c(5, 4, .5, 2) + 0.1) ## Create plot with no x axis and no x axis label plot(1:8, xaxt = &quot;n&quot;, xlab = &quot;&quot;) ## Set up x axis with tick marks alone axis(1, labels = FALSE) ## Create some text labels labels &lt;- paste(&quot;Label&quot;, 1:8, sep = &quot; &quot;) ## Plot x axis labels at default tick marks text(1:8, par(&quot;usr&quot;)[3] - 0.5, srt = 45, adj = 1, labels = labels, xpd = TRUE ) ## Plot x axis label at line 6 (of 7) mtext(side = 1, text = &quot;X Axis Label&quot;, line = 4) 图 12.13: 旋转坐标轴标签 srt = 45 表示文本旋转角度， xpd = TRUE 允许文本越出绘图区域，adj = 1 to place the right end of text at the tick marks；You can adjust the value of the 0.5 offset as required to move the axis labels up or down relative to the x axis. 详细地参考 (Murrell 2003) 12.1.5 标题 添加多个标题 N &lt;- 200 x &lt;- runif(N, -4, 4) y &lt;- sin(x) + .5 * rnorm(N) plot(x, y, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;) mtext(&quot;Subtitle&quot;, 3, line = .8) mtext(&quot;Title&quot;, 3, line = 2, cex = 1.5) mtext(&quot;X axis&quot;, 1, line = 2.5, cex = 1.5) mtext(&quot;X axis subtitle&quot;, 1, line = 3.7) 图 12.14: 图标题/子标题 x轴标题/子标题 12.1.6 注释 数学符号注释，图12.15 自定义坐标轴 (Murrell and Ihaka 2000)。 # 自定义坐标轴 plot(c(1, 1e6), c(-pi, pi), type = &quot;n&quot;, axes = FALSE, ann = FALSE, log = &quot;x&quot; ) axis(1, at = c(1, 1e2, 1e4, 1e6), labels = expression(1, 10^2, 10^4, 10^6) ) axis(2, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) text(1e3, 0, expression(italic(&quot;Customized Axes&quot;))) box() 图 12.15: 创建自定义的坐标轴和刻度标签 在标题中添加数学公式 x &lt;- seq(-5, 5, length = 200) y &lt;- sqrt(1 + x^2) plot(y ~ x, type = &quot;l&quot;, ylab = expression(sqrt(1 + x^2)) ) title(main = expression( &quot;graph of the function f&quot;(x) == sqrt(1 + x^2) )) 图 12.16: 标题含有数学公式 修改参数使用 substitute 函数批量生成 x &lt;- seq(-5, 5, length = 200) for (i in 1:4) { # 画四个图 y &lt;- sqrt(i + x^2) plot(y ~ x, type = &quot;l&quot;, ylim = c(0, 6), ylab = substitute( expression(sqrt(i + x^2)), list(i = i) ) ) title(main = substitute( &quot;graph of the function f&quot;(x) == sqrt(i + x^2), list(i = i) )) } 图 12.17: 批量生成函数图形 基础绘图函数，如 plot 标签 xlab 支持 Unicode 代码表示的希腊字母，常用字母表备查，公式环境下，也可以用在绘图中 表 12.1: 希腊字母表 希腊字母 LaTeX 代码 Unicode 代码 希腊字母 LaTeX 代码 Unicode 代码 \\(\\alpha\\) \\alpha \\u03B1 \\(\\mu\\) \\mu \\u03BC \\(\\beta\\) \\beta \\u03B2 \\(\\nu\\) \\nu \\u03BD \\(\\gamma\\) \\gamma \\u03B3 \\(\\xi\\) \\xi \\u03BE \\(\\delta\\) \\delta \\u03B4 \\(\\varphi\\) \\varphi \\u03C6 \\(\\epsilon\\) \\epsilon \\u03B5 \\(\\pi\\) \\pi \\u03C0 \\(\\zeta\\) \\zeta \\u03B6 \\(\\rho\\) \\rho \\u03C1 \\(\\eta\\) \\eta \\u03B7 \\(\\upsilon\\) \\upsilon \\u03C5 \\(\\theta\\) \\theta \\u03B8 \\(\\phi\\) \\phi \\u03C6 \\(\\iota\\) \\iota \\u03B9 \\(\\chi\\) \\chi \\u03C7 \\(\\kappa\\) \\kappa \\u03BA \\(\\psi\\) \\psi \\u03C8 \\(\\lambda\\) \\lambda \\u03BB \\(\\omega\\) \\omega \\u03C9 \\(\\sigma\\) \\sigma \\u03C3 \\(\\tau\\) \\tau \\u03C4 表 12.2: 数字上下标 上标数字 LaTeX 代码 Unicode 代码 下标数字 LaTeX 代码 Unicode 代码 \\({}^0\\) {}^0 \\u2070 \\({}_0\\) {}_0 \\u2080 \\({}^1\\) {}^1 \\u00B9 \\({}_1\\) {}_1 \\u2081 \\({}^2\\) {}^2 \\u00B2 \\({}_2\\) {}_2 \\u2082 \\({}^3\\) {}^3 \\u00B2 \\({}_3\\) {}_3 \\u2083 \\({}^4\\) {}^4 \\u2074 \\({}_4\\) {}_4 \\u2084 \\({}^5\\) {}^5 \\u2075 \\({}_5\\) {}_5 \\u2085 \\({}^6\\) {}^6 \\u2076 \\({}_6\\) {}_6 \\u2086 \\({}^7\\) {}^7 \\u2077 \\({}_7\\) {}_7 \\u2087 \\({}^8\\) {}^8 \\u2078 \\({}_8\\) {}_8 \\u2088 \\({}^9\\) {}^9 \\u2079 \\({}_9\\) {}_9 \\u2089 \\({}^n\\) {}^n \\u207F \\({}_n\\) {}_n - 其它字母，请查看 Unicode 字母表 12.1.7 图例 x &lt;- seq(-6, 6, length = 200) y &lt;- sin(x) z &lt;- cos(x) plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(-6, -1, yjust = 0, c(&quot;Sine&quot;, &quot;Cosine&quot;), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 12.18: 三角函数添加图例 xmin &lt;- par(&quot;usr&quot;)[1] xmax &lt;- par(&quot;usr&quot;)[2] ymin &lt;- par(&quot;usr&quot;)[3] ymax &lt;- par(&quot;usr&quot;)[4] plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(&quot;bottomleft&quot;, c(&quot;Sine&quot;, &quot;Cosine&quot;), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 12.19: 设置图例的位置 plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(&quot;bottomleft&quot;, c(&quot;Sine&quot;, &quot;Cosine&quot;), inset = c(.03, .03), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 12.20: insert 函数微调图例位置 op &lt;- par(no.readonly = TRUE) plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) par(xpd = TRUE) # Do not clip to the drawing area 关键一行/允许出界 lambda &lt;- .025 legend(par(&quot;usr&quot;)[1], (1 + lambda) * par(&quot;usr&quot;)[4] - lambda * par(&quot;usr&quot;)[3], c(&quot;Sine&quot;, &quot;Cosine&quot;), xjust = 0, yjust = 0, lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) par(op) 图 12.21: 将图例放在绘图区域外面 Hmisc 包的 labcurve 函数可以在曲线上放置名称，而不是遥远的图例上 12.1.8 边空 N &lt;- 200 x &lt;- runif(N, -4, 4) y &lt;- sin(x) + .5 * rnorm(N) plot(x, y, xlab = &quot;&quot;, ylab = &quot;&quot;, main = paste( &quot;The \\&quot;mtext\\&quot; function&quot;, paste(rep(&quot; &quot;, 60), collapse = &quot;&quot;) ) ) mtext(&quot;Line 0&quot;, 3, line = 0) mtext(&quot;Line 1&quot;, 3, line = 1) mtext(&quot;Line 2&quot;, 3, line = 2) mtext(&quot;Line 3&quot;, 3, line = 3) 图 12.22: 外边空在图的边缘添加文字 par # 多图排列/分屏 page 47 # 最常用的是 par mfrow mfcol分别按行/列放置图形 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 4, 0) # Outer margins ) for (i in 1:4) plot(runif(20), runif(20), main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) par(op) mtext(&quot;Four plots, without enough room for this title&quot;, side = 3, font = 2, cex = 1.5, col = &quot;red&quot; ) # 总/大标题放不下 图 12.23: 多图排列共享一个大标题 par 的 oma 用来设置外边空的大小 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 3, 0) # Outer margins ) for (i in 1:4) plot(runif(20), runif(20), main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) par(op) mtext(&quot;Four plots, with some room for this title&quot;, side = 3, line = 1.5, font = 1, cex = 1.5, col = &quot;red&quot; ) 图 12.24: 设置外边空放置大标题 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 3, 0), mar = c(3, 3, 4, 1) + .1 # Margins ) for (i in 1:4) plot(runif(20), runif(20), xlab = &quot;&quot;, ylab = &quot;&quot;, main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) par(op) mtext(&quot;Title&quot;, side = 3, line = 1.5, font = 2, cex = 2, col = &quot;red&quot; ) 图 12.25: 设置每个子图的边空 mar 12.1.9 图层 覆盖图形 add = T or par(new=TRUE) plot(runif(5), runif(5), xlim = c(0, 1), ylim = c(0, 1) ) points(runif(5), runif(5), col = &quot;#EA4335&quot;, pch = 16, cex = 3 ) lines(runif(5), runif(5), col = &quot;red&quot;) segments(runif(5), runif(5), runif(5), runif(5), col = &quot;blue&quot; ) title(main = &quot;Overlaying points, segments, lines...&quot;) 图 12.26: 添加图层 12.1.10 布局 layout 函数布局， 绘制复杂组合图形 op &lt;- par(oma = c(0, 0, 3, 0)) layout(matrix(c( 1, 1, 1, 2, 3, 4, 2, 3, 4 ), nr = 3, byrow = TRUE)) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) mtext(&quot;The \\&quot;layout\\&quot; function&quot;, side = 3, outer = TRUE, font = 2, cex = 1.2 ) 图 12.27: 更加复杂的组合图形 12.1.11 组合 par 之 fig 参数很神奇，使得多个图可以叠加在一起，它接受一个数值向量c(x1, x2, y1, y2) ，是图形设备显示区域中的绘图区域的(NDC, normalized device coordinates)坐标。 plot(1:12, type = &quot;b&quot;, main = &quot;&#39;fg&#39; : axes, ticks and box in gray&quot;, fg = gray(0.7), bty = &quot;7&quot;, sub = R.version.string ) par(fig = c(1, 6, 5, 10) / 10, new = T) plot(6:10, type = &quot;b&quot;, main = &quot;&quot;, fg = gray(0.7), bty = &quot;7&quot;, xlab = R.version.string ) 图 12.28: 多图叠加 fig 参数控制图形的位置，用来绘制组合图形 n &lt;- 1000 x &lt;- rt(n, df = 10) hist(x, col = &quot;light blue&quot;, probability = &quot;TRUE&quot;, main = &quot;&quot;, ylim = c(0, 1.2 * max(density(x)$y)) ) lines(density(x), col = &quot;red&quot;, lwd = 3 ) op &lt;- par( fig = c(.02, .4, .5, .98), new = TRUE ) qqnorm(x, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;, axes = FALSE ) qqline(x, col = &quot;red&quot;, lwd = 2) box(lwd = 2) par(op) 图 12.29: 组合图形 12.1.12 分屏 split.screen 分屏组合 random.plot &lt;- function() { N &lt;- 200 f &lt;- sample( list( rnorm, function(x) { rt(x, df = 2) }, rlnorm, runif ), 1 ) [[1]] x &lt;- f(N) hist(x, col = &quot;lightblue&quot;, main = &quot;&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, axes = F) axis(1) } op &lt;- par(bg = &quot;white&quot;, mar = c(2.5, 2, 1, 2)) split.screen(c(2, 1)) #&gt; [1] 1 2 split.screen(c(1, 3), screen = 2) #&gt; [1] 3 4 5 screen(1) random.plot() # screen(2); random.plot() # Screen 2 was split into three screens: 3, 4, 5 screen(3) random.plot() screen(4) random.plot() screen(5) random.plot() close.screen(all = TRUE) par(op) 图 12.30: 分屏 12.1.13 交互 辅助绘图 identify locator 12.2 统计图形 按图的类型划分，最后在小结部分给出各图适用的数据类型 根据数据类型划分： 对于一元数据，可用什么图来描述；多元数据呢，连续数据和离散数据（分类数据） 先找一个不重不漏的划分，指导原则是根据数据类型选择图，根据探索到的数据中的规律，选择图 其它 assocplot fourfoldplot sunflowerplot 12.2.1 条形图 条形图 简单条形图 data(diamonds, package = &quot;ggplot2&quot;) # 加载数据 par(mar = c(2, 5, 1, 1)) barCenters &lt;- barplot(table(diamonds$cut), col = &quot;lightblue&quot;, axes = FALSE, axisnames = FALSE, horiz = TRUE, border = &quot;white&quot; ) text( y = barCenters, x = par(&quot;usr&quot;)[3], adj = 1, labels = names(table(diamonds$cut)), xpd = TRUE ) axis(1, labels = seq(0, 25000, by = 5000), at = seq(0, 25000, by = 5000), las = 1, col = &quot;gray&quot; ) grid() 图 12.31: 条形图 简单柱形图 set.seed(123456) barPois &lt;- table(stats::rpois(1000, lambda = 5)) plot(barPois, col = &quot;lightblue&quot;, type = &quot;h&quot;, lwd = 10, main = &quot;&quot;) box(col = &quot;gray&quot;) 图 12.32: 柱形图 复合条形图 par(mar = c(4.1,2.1,0.5,4.5)) barplot(VADeaths, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(5), legend.text = rownames(VADeaths), xpd = TRUE, beside = TRUE, cex.names = 0.9, args.legend = list(x = &quot;right&quot;,border = &quot;white&quot;, title = &quot;Age&quot;, box.col = NA, horiz = FALSE, inset = c(-.2, 0), xpd = TRUE), panel.first = grid(nx = 0, ny=7)) 图 12.33: 复合条形图 堆积条形图 par(mar = c(4.1,2.1,0.5,4.5)) barplot(VADeaths, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(5), legend.text = rownames(VADeaths), xpd = TRUE, beside = FALSE, cex.names = 0.9, args.legend = list(x = &quot;right&quot;,border = &quot;white&quot;, title = &quot;Age&quot;, box.col = NA, horiz = FALSE, inset = c(-.2, 0), xpd = TRUE), panel.first = grid(nx = 0, ny=4)) 图 12.34: 堆积条形图 堆积条形图 spineplot 简单条形图 barplot(data = BOD, demand ~ Time, ylim = c(0, 20), border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(1)) pg_mean = aggregate(weight ~ group, data = PlantGrowth, mean) barplot(data = pg_mean, weight ~ group, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(3)) Titanic 数据集是 table 数据类型 简单条形图 复合条形图 barplot(Freq ~ Class + Survived, data = Titanic, subset = Age == &quot;Adult&quot; &amp; Sex == &quot;Male&quot;, beside = TRUE, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(4), args.legend = list(border = &quot;white&quot;, title = &quot;Class&quot;, box.col = NA, horiz = FALSE, xpd = TRUE), ylab = &quot;# {passengers}&quot;, legend = TRUE) 堆积条形图 barplot(Freq ~ Class + Survived, data = Titanic, subset = Age == &quot;Adult&quot; &amp; Sex == &quot;Male&quot;, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(4), args.legend = list(border = &quot;white&quot;, title = &quot;Class&quot;, box.col = NA, horiz = FALSE, xpd = TRUE), ylab = &quot;# {passengers}&quot;, legend = TRUE) 12.2.2 直方图 set.seed(1234) n &lt;- 2^24 x &lt;- runif(n, 0, 1) delta &lt;- 0.01 len &lt;- diff(c(0, which(x &lt; delta), n + 1)) - 1 ylim &lt;- seq(0, 1800, by = 300) xlim &lt;- seq(0, 100, by = 20) p &lt;- hist(len[len &lt; 101], breaks = -1:100 + 0.5, plot = FALSE) plot(p, ann = FALSE, axes = FALSE, col = &quot;lightblue&quot;, border = &quot;white&quot;, main = &quot;&quot;) axis(1, labels = xlim, at = xlim, las = 1) # x 轴 axis(2, labels = ylim, at = ylim, las = 0) # y 轴 box(col = &quot;gray&quot;) 图 12.35: 直方图 with(data = faithful, { hist(eruptions, seq(1.6, 5.2, 0.2), prob = TRUE, main = &quot;&quot;, col = &quot;lightblue&quot;, border = &quot;white&quot;) lines(density(eruptions, bw = 0.1), col = &quot;#EA4335&quot;) rug(eruptions, col = &quot;#EA4335&quot;) # 添加数据点 }) 图 12.36: 老忠实泉间歇性喷水的时间间隔分布 hist(longley$Unemployed, probability = TRUE, col = &quot;light blue&quot;, main = &quot;&quot; ) # 添加密度估计 lines(density(longley$Unemployed), col = &quot;red&quot;, lwd = 3 ) 图 12.37: 概率密度分布 直方图有很多花样的，添加阴影线，angle 控制倾斜的角度 # hist(longley$Unemployed, density = 1, angle = 45) # hist(longley$Unemployed, density = 3, angle = 15) # hist(longley$Unemployed, density = 1, angle = 15) hist(longley$Unemployed, density = 3, angle = 45, main = &quot;&quot;) 图 12.38: density 数值越大阴影线越密 12.2.3 密度图 library(MASS) data(galaxies) galaxies &lt;- galaxies / 1000 # Bandwidth Selection by Pilot Estimation of Derivatives c(width.SJ(galaxies, method = &quot;dpi&quot;), width.SJ(galaxies)) #&gt; [1] 3.26 2.57 plot( x = c(5, 40), y = c(0, 0.2), type = &quot;n&quot;, bty = &quot;l&quot;, xlab = &quot;velocity of galaxy (km/s)&quot;, ylab = &quot;density&quot; ) rug(galaxies) lines(density(galaxies, width = 3.25, n = 200), col = &quot;blue&quot;, lty = 1) lines(density(galaxies, width = 2.56, n = 200), col = &quot;red&quot;, lty = 3) x &lt;- seq(from = 110, to = 174, by = 0.5) y1 &lt;- dnorm(x, mean = 145, sd = 9) y2 &lt;- dnorm(x, mean = 138, sd = 8) plot(x, y1, type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;, main = &quot;Systolic Blood Pressure Before and After Treatment&quot;, xlab = &quot;Systolic Blood Pressure (mmHg)&quot;, ylab = &quot;Frequency&quot;, yaxt = &quot;n&quot;, xlim = c(110, 175), ylim = c(0, 0.05) ) lines(x, y2) polygon(c(110, x, 175), c(0, y2, 0), col = &quot;firebrick3&quot;, border = &quot;white&quot; ) polygon(c(117, x, 175), c(0, y1, 0), col = &quot;dodgerblue4&quot;, border = &quot;white&quot; ) ylab &lt;- c(seq(from = 0, to = 175, by = 25)) y &lt;- c(seq(from = 0, to = 0.05, length.out = 8)) axis(2, at = y, labels = ylab, las = 1) text(x = 120, y = 0.045, &quot;- Pre-Treatment BP&quot;, col = &quot;dodgerblue4&quot;, cex = 0.9) text(x = 120, y = 0.04, &quot; - Post-Treatment BP&quot;, col = &quot;firebrick3&quot;, cex = 0.9) points(109, 0.0445, pch = 15, col = &quot;dodgerblue4&quot;) points(109, 0.0395, pch = 15, col = &quot;firebrick3&quot;) days &lt;- abs(rnorm(1000, 80, 125)) plot(density(days, from = 0), main = &quot;Density plot&quot;, xlab = &quot;Number of days since trial started&quot; ) plot(density(days, from = 0, to = 180, adjust = 0.2), main = &quot;Density plot - Up to 180 days (86% of data)&quot;, xlab = &quot;Number of days since trial started&quot; ) library(survival) surv.days &lt;- Surv(days) surv.fit &lt;- survfit(surv.days ~ 1) plot(surv.fit, main = &quot;Kaplan-Meier estimate with 95% confidence bounds (86% of data)&quot;, xlab = &quot;Days since trial started&quot;, xlim = c(0, 180), ylab = &quot;Survival function&quot; ) grid(20, 10, lwd = 2) 12.2.4 经验图 with(data = faithful, { long &lt;- eruptions[eruptions &gt; 3] plot(ecdf(long), do.points = FALSE, verticals = TRUE, main = &quot;&quot;) x &lt;- seq(3, 5.4, 0.01) lines(x, pnorm(x, mean = mean(long), sd = sqrt(var(long))), lty = 3) }) 图 12.39: 累积经验分布图 12.2.5 QQ 图 with(data = faithful, { long &lt;- eruptions[eruptions &gt; 3] par(pty = &quot;s&quot;) # arrange for a square figure region qqnorm(long, main = &quot;&quot;) qqline(long) }) 12.2.6 时序图 时序图最适合用来描述股价走势 matplot(time(EuStockMarkets), EuStockMarkets, main = &quot;&quot;, xlab = &quot;Date&quot;, ylab = &quot;closing prices&quot;, pch = 17, type = &quot;l&quot;, col = 1:4 ) legend(&quot;topleft&quot;, colnames(EuStockMarkets), pch = 17, lty = 1, col = 1:4) 图 12.40: 1991–1998年间主要欧洲股票市场日闭市价格指数图 德国 DAX (Ibis), Switzerland SMI, 法国 CAC 和 英国 FTSE 12.2.7 饼图 clockwise 参数 pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) names(pie.sales) &lt;- c( &quot;Blueberry&quot;, &quot;Cherry&quot;, &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot; ) pie(pie.sales, clockwise = TRUE, main = &quot;&quot;) segments(0, 0, 0, 1, col = &quot;red&quot;, lwd = 2) text(0, 1, &quot;init.angle = 90&quot;, col = &quot;red&quot;) 12.2.8 茎叶图 stem(longley$Unemployed) #&gt; #&gt; The decimal point is 2 digit(s) to the right of the | #&gt; #&gt; 1 | 99 #&gt; 2 | 134899 #&gt; 3 | 46789 #&gt; 4 | 078 12.2.9 散点图 在一维空间上，绘制散点图，其实是在看散点的疏密程度随坐标轴的变化 stripchart(longley$Unemployed, method = &quot;jitter&quot;, jitter = 0.1, pch = 16, col = &quot;lightblue&quot;) stripchart(longley$Unemployed, method = &quot;overplot&quot;, pch = 16, col = &quot;lightblue&quot;) 图 12.41: 一维散点图 气泡图是二维散点图的一种变体，气泡的大小可以用来描述第三个变量，下面以数据集 topo 为例展示气泡图 # 加载数据集 data(topo, package = &quot;MASS&quot;) # 查看数据集 str(topo) #&gt; &#39;data.frame&#39;: 52 obs. of 3 variables: #&gt; $ x: num 0.3 1.4 2.4 3.6 5.7 1.6 2.9 3.4 3.4 4.8 ... #&gt; $ y: num 6.1 6.2 6.1 6.2 6.2 5.2 5.1 5.3 5.7 5.6 ... #&gt; $ z: int 870 793 755 690 800 800 730 728 710 780 ... topo 是空间地形数据集，包含有52行3列，数据点是310平方英尺范围内的海拔高度数据，x 坐标每单位50英尺，y 坐标单位同 x 坐标，海拔高度 z 单位是英尺 plot(y ~ x, cex = (960 - z) / (960 - 690) * 3, data = topo, xlab = &quot;X Coordinates&quot;, ylab = &quot;Y coordinates&quot; ) 图 12.42: 地形图之海拔高度 散点图也适合分类数据的展示，在图中用不同颜色或符号标记数据点所属类别，即在普通散点图的基础上添加一分类变量的描述 plot(mpg ~ hp, data = subset(mtcars, am == 1), pch = 16, col = &quot;blue&quot;, xlim = c(50, 350), ylim = c(10, 35) ) points(mpg ~ hp, col = &quot;red&quot;, pch = 16, data = subset(mtcars, am == 0) ) legend(300, 35, c(&quot;1&quot;, &quot;0&quot;), title = &quot;am&quot;, col = c(&quot;blue&quot;, &quot;red&quot;), pch = c(16, 16) ) 图 12.43: 分类散点图 plot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16) legend(&quot;topright&quot;, legend = unique(iris$Species), box.col = &quot;gray&quot;, pch = 16, col = unique(iris$Species) ) box(col = &quot;gray&quot;) 图 12.44: 分类散点图 分组散点图和平滑 library(car) scatterplot(Sepal.Length ~ Sepal.Width, col = c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;), pch=c(16,16,16), smooth = TRUE, boxplots = &quot;xy&quot;, groups = iris$Species, xlab = &quot;Sepal.Width&quot;, ylab = &quot;Sepal.Length&quot;, data = iris ) 有时为了实现特定的目的，需要高亮其中某些点，按类别或者因子变量分组绘制散点图，这里继续采用 stripchart 函数绘制二维散点图12.45， 由左图可知，函数 stripchart 提供的参数 pch 不接受向量，实际只是取了前三个值 16 16 17 对应于 Species 的三类，关键是高亮的分界点是有区分意义的 data(&quot;iris&quot;) pch &lt;- rep(16, length(iris$Petal.Length)) pch[which(iris$Petal.Length &lt; 1.4)] &lt;- 17 stripchart(Petal.Length ~ Species, data = iris, vertical = TRUE, method = &quot;jitter&quot;, pch = pch ) # 对比一下 stripchart(Petal.Length ~ Species, data = iris, subset = Petal.Length &gt; 1.4, vertical = TRUE, method = &quot;jitter&quot;, ylim = c(1, 7), pch = 16 ) stripchart(Petal.Length ~ Species, data = iris, subset = Petal.Length &lt; 1.4, vertical = TRUE, method = &quot;jitter&quot;, add = TRUE, pch = 17, col = &quot;red&quot; ) 图 12.45: 高亮图中部分散点 如果存在大量散点 densCols(x, y = NULL, nbin = 128, bandwidth, colramp = colorRampPalette(blues9[-(1:3)])) densCols 函数根据点的局部密度生成颜色，密度估计采用核平滑法，由 KernSmooth 包的 bkde2D 函数实现。参数 colramp 传递一个函数，colorRampPalette 根据给定的几种颜色生成函数，参数 bandwidth 实际上是传给 bkde2D 函数 x1 &lt;- matrix(rnorm(1e3), ncol = 2) x2 &lt;- matrix(rnorm(1e3, mean = 3, sd = 1.5), ncol = 2) x &lt;- rbind(x1, x2) dcols &lt;- densCols(x) graphics::plot(x, col = dcols, pch = 20, panel.first = grid()) # title(main = &quot;n = 1000&quot;, xpd = TRUE) 图 12.46: 根据点的密度生成颜色 气泡图也是散点图的一种 plot(Volume ~ Height, data = trees, pch = 16, cex = Girth / 8, col = rev(terrain.colors(nrow(trees), alpha = .5)) ) box(col = &quot;gray&quot;) 图 12.47: 气泡图 12.2.10 抖动图 抖动散点图 mat &lt;- matrix(1:length(colors()), ncol = 9, byrow= TRUE) df &lt;- data.frame(col = colors(), x = as.integer(cut(1:length(colors()), 9)), y = rep(1:73, 9), stringsAsFactors=FALSE) par(mar = c(4, 4, 1, 0.1)) plot(y ~ jitter(x), data = df, col = df$col, pch=16, main = &quot;Visualizing colors() split in 9 groups&quot;, xlab = &quot;Group&quot;, ylab = &quot;Element of the group (min = 1, max = 73)&quot;, sub = &quot;x = 3, y = 1 means that it&#39;s the 2 * 73 + 1 = 147th color&quot;) 图 12.48: 抖动散点图 12.2.11 箱线图 boxplotdbl: Double Box Plot for Two-Axes Correlation Correlation chart of two set (x and y) of data. Using Quartiles with boxplot style. Visualize the effect of factor. 复合箱线图 https://tomizonor.wordpress.com/2013/11/24/double-box-plot-1-2/ https://tomizonor.wordpress.com/2013/03/15/double-box-plot/ A &lt;- c( 79.98, 80.04, 80.02, 80.04, 80.03, 80.03, 80.04, 79.97, 80.05, 80.03, 80.02, 80, 80.02 ) B &lt;- c(80.02, 79.94, 79.98, 79.97, 79.97, 80.03, 79.95, 79.97) boxplot(A, B) with(data = iris, { op &lt;- par(mfrow = c(2, 2), mar = c(4, 4, 2, .5)) plot(Sepal.Length ~ Species) plot(Sepal.Width ~ Species) plot(Petal.Length ~ Species) plot(Petal.Width ~ Species) par(op) mtext(&quot;Edgar Anderson&#39;s Iris Data&quot;, side = 3, line = 4) }) 图 12.49: 安德森的鸢尾花数据 箱线图的花样也很多 boxplot(longley$Unemployed) # 水平放置 boxplot(longley$Unemployed, horizontal = TRUE, col = &quot;pink&quot;, main = &quot;&quot; ) data(InsectSprays) boxplot(count ~ spray, data = InsectSprays, col = &quot;pink&quot;, xlab = &quot;Spray&quot;, ylab = &quot;Count&quot;, main = &quot;&quot; ) 水平放置 boxplot(count ~ spray, data = InsectSprays, col = &quot;pink&quot;, horizontal = TRUE, las = 1, # Horizontal labels xlab = &quot;Count&quot;, ylab = &quot;Spray&quot;, main = &quot;&quot; ) 12.2.12 残差图 iris 四个测量指标 vec_mean &lt;- colMeans(iris[,-5]) vec_sd &lt;- apply(iris[, -5], 2, sd) plot(seq(4), vec_mean, ylim = range(c(vec_mean - vec_sd, vec_mean + vec_sd)), xlab = &quot;Species&quot;, ylab = &quot;Mean +/- SD&quot;, lwd = 1, pch = 19, axes = FALSE ) axis(1, at = seq(4), labels = colnames(iris)[-5]) axis(2, at = seq(7), labels = seq(7)) arrows(seq(4), vec_mean - vec_sd, seq(4), vec_mean + vec_sd, length = 0.05, angle = 90, code = 3 ) box() 图 12.50: 带标准差的均值散点图 12.2.13 提琴图 Tom Kelly 维护的 vioplot 包 https://github.com/TomKellyGenetics/vioplot 12.2.14 轮廓图 topo 是地形数据 等高线图 12.2.15 折线图 函数曲线，样条曲线，核密度曲线，平行坐标图 折线图 点线图 plot(type=\"b\") 函数曲线图 curve matplot X 样条曲线 xspline 时序图 太阳黑子活动数据 sunspot.month Monthly Sunspot Data, from 1749 to “Present” sunspot.year Yearly Sunspot Data, 1700-1988 sunspots Monthly Sunspot Numbers, 1749-1983 plot(AirPassengers) box(col = &quot;gray&quot;) 图 12.51: 折线图 12.2.16 函数图 library(pracma) ## First zero on the critical line s = 0.5 + i t x &lt;- seq(0, 20, len = 1001) z &lt;- 0.5 + x * 1i fr &lt;- Re(zeta(z)) fi &lt;- Im(zeta(z)) fa &lt;- abs(zeta(z)) plot(x, fa, type = &quot;n&quot;, xlim = c(0, 20), ylim = c(-1.5, 2.5), xlab = &quot;Imaginary part (on critical line)&quot;, ylab = &quot;Function value&quot;, main = &quot;Riemann&#39;s Zeta Function along the critical line&quot; ) grid() lines(x, fr, col = &quot;blue&quot;) lines(x, fi, col = &quot;darkgreen&quot;) lines(x, fa, col = &quot;red&quot;, lwd = 2) points(14.1347, 0, col = &quot;darkred&quot;) legend(0, 2.4, c(&quot;real part&quot;, &quot;imaginary part&quot;, &quot;absolute value&quot;), lty = 1, lwd = c(1, 1, 2), col = c(&quot;blue&quot;, &quot;darkgreen&quot;, &quot;red&quot;) ) 还有 eta 函数和 gammaz 函数 12.2.17 马赛克图 马赛克图 mosaicplot plot(HairEyeColor, col = &quot;lightblue&quot;, border = &quot;white&quot;, main = &quot;&quot;) 图 12.52: 马赛克图 12.2.18 克利夫兰点图 dotchart 条件图 coplot 12.2.19 矩阵图 在对角线上添加平滑曲线、密度曲线 pairs(longley, gap = 0, diag.panel = function(x, ...) { par(new = TRUE) hist(x, col = &quot;light blue&quot;, probability = TRUE, axes = FALSE, main = &quot;&quot; ) lines(density(x), col = &quot;red&quot;, lwd = 3 ) rug(x) } ) 图 12.53: 变量关系 # 自带 layout plot(iris[, -5], col = iris$Species) 图 12.54: 矩阵图 12.2.20 雷达图 星图 stars 多元数据 12.2.21 玫瑰图 12.2.22 地形图 轮廓图 contour 等高线图 热图 image # 代码来自 ?map par(mar = c(0, 0, 2, 0)) library(mapproj) data(unemp) data(county.fips) colors &lt;- c(&quot;#F1EEF6&quot;, &quot;#D4B9DA&quot;, &quot;#C994C7&quot;, &quot;#DF65B0&quot;, &quot;#DD1C77&quot;, &quot;#980043&quot;) unemp$colorBuckets &lt;- as.numeric(cut(unemp$unemp, c(0, 2, 4, 6, 8, 10, 100))) leg.txt &lt;- c(&quot;&lt;2%&quot;, &quot;2-4%&quot;, &quot;4-6%&quot;, &quot;6-8%&quot;, &quot;8-10%&quot;, &quot;&gt;10%&quot;) cnty.fips &lt;- county.fips$fips[match( map(&quot;county&quot;, plot = FALSE)$names, county.fips$polyname )] colorsmatched &lt;- unemp$colorBuckets [match(cnty.fips, unemp$fips)] # draw map map(&quot;county&quot;, col = colors[colorsmatched], fill = TRUE, resolution = 0, lty = 0, projection = &quot;polyconic&quot; ) map(&quot;state&quot;, col = &quot;white&quot;, fill = FALSE, add = TRUE, lty = 1, lwd = 0.2, projection = &quot;polyconic&quot; ) title(&quot;unemployment by county, 2009&quot;) legend(&quot;bottomleft&quot;, leg.txt, horiz = FALSE, fill = colors, border = &quot;gray&quot; ) 图 12.55: 2009年美国各城镇失业率 if (!&quot;spDataLarge&quot; %in% .packages(TRUE)) { install.packages(&quot;spDataLarge&quot;, repos = &quot;https://nowosad.github.io/drat/&quot;, type = &quot;source&quot; ) } raster 图形，Elevation raster data from SRTM of the Zion National Park area library(sp) library(raster) library(spDataLarge) plot(elevation, asp = NA) 图 12.56: raster 图形 注意与 image 函数区别 # A prettier display of the volcano x &lt;- 10*(1:nrow(volcano)) y &lt;- 10*(1:ncol(volcano)) image(x, y, volcano, col = terrain.colors(100), axes = FALSE) contour(x, y, volcano, levels = seq(90, 200, by = 5), add = TRUE, col = &quot;peru&quot;) axis(1, at = seq(100, 800, by = 100)) axis(2, at = seq(100, 600, by = 100)) box() title(main = &quot;Maunga Whau Volcano&quot;, font.main = 4) 图 12.57: image 图形 12.3 TikZ 绘图 用 Base R 绘制带有复杂数学公式的图形，tikzDevice 包结合 R Markdown 的使用，引入 LaTeX 绘图引擎 TikZ 主要是借助 LaTeX 对数学符号的强大支持，让R 语言绘制的图形上出现优美的复杂的数学符号表达式 以 tikzDevice 绘图， out.width='35%' 设置一幅子图占页面的宽度，在 _common.R 设置页面宽度为 out.width='70%'，即全宽图占页面 70% 的宽度。 fig.asp=1 设置子图的长宽比例为 1:1，即正方形。设置图片的宽度，默认是 fig.width = 6 相应地，图片的高度是 fig.height = fig.width * fig.asp = 6 * 0.618 = 3.708 但是这个比例使得图片上的字很小，所以设置fig.width=2.5。设置图形设备 dev='tikz'，此时会自动调用 tikzDevice 包处理图上的数学公式，tikzDevice 包将 LaTeX 中的 TikZ 绘图引擎引入到基础 R 绘图中，由于该引擎将R代码块转化为 .tex 文件，接着调用 LaTeX 编译，默认生成 PDF 格式图片，因此设置 tikz2png='-density 300' 调用 ImageMgick 的 convert 命令将 PDF 格式图片转化为 PNG 格式图片，转化前需要用 Ghostscript 读取该 PDF 文件，转化成功后，需要将该 PNG 格式文件路径返回，以插入到文档中。bessel-function 是给该图片的命名，这段代码生成两张图片，两个图片就分别叫做 bessel-function-1.pdf 和 bessel-function-2.pdf。在 LaTeX 里并排插入两个图片，需要在导言区加载 subfig 宏包。 knitr 提供 Tikz 图形的模版， system.file('misc', 'tikz2pdf.tex', package = 'knitr')，tikzDevice 包可以方便的把 R 代码转化为 tikz 代码，然后使用 LaTeX 引擎编译成 PDF 文档，特别地，它很好地支持了图里的数学公式 library(tikzDevice) tf &lt;- file.path(getwd(), &quot;demo-tikzDevice.tex&quot;) tikz(tf, width = 6, height = 4, pointsize = 30, standAlone = TRUE) # 绘图的代码，仅支持 Base R Graphics System source(file = &quot;code/chapter_03/matern.R&quot;) dev.off() tools::texi2dvi(tf, pdf = T) system(&quot;rm demo-tikzDevice.tex *.log *.aux *.dvi&quot;) system(&quot;convert -density 300 -trim demo-tikzDevice.pdf -quality 100 demo-tikzDevice.png&quot;) system(&quot;mv demo-tikzDevice.* figures/&quot;) # convert test.svg test.png 如图所示 两个利用 tikzDevice 包的例子 # 带有图标题 x &lt;- rnorm(10) y &lt;- x + rnorm(5, sd = 0.25) model &lt;- lm(y ~ x) rsq &lt;- summary(model)$r.squared rsq &lt;- signif(rsq, 4) plot(x, y, main = &quot;Hello \\\\LaTeX!&quot;, xlab = &quot;$x$&quot;, ylab = &quot;$y$&quot;) abline(model, col = &quot;red&quot;) mtext(paste(&quot;Linear model: $R^{2}=&quot;, rsq, &quot;$&quot;), line = 0.5) legend(&quot;bottomright&quot;, legend = paste(&quot;$y = &quot;, round(coef(model)[2], 3), &quot;x +&quot;, round(coef(model)[1], 3), &quot;$&quot;, sep = &quot;&quot; ), bty = &quot;n&quot;) plot(x, y, main = &quot;Hello \\\\LaTeX!&quot;, xlab = &quot;$x$&quot;, ylab = &quot;$y$&quot;) abline(model, col = &quot;red&quot;) mtext(paste(&quot;Linear model: $R^{2}=&quot;, rsq, &quot;$&quot;), line = 0.5) legend(&quot;bottomright&quot;, legend = paste(&quot;$y = &quot;, round(coef(model)[2], 3), &quot;x +&quot;, round(coef(model)[1], 3), &quot;$&quot;, sep = &quot;&quot; ), bty = &quot;n&quot;) 图 12.58: 线性回归模型 x0 &lt;- 2^(-20:10) nus &lt;- c(0:5, 10, 20) x &lt;- seq(0, 4, length.out = 501) plot(x0, x0^-8, frame.plot = TRUE, # 添加绘图框 log = &quot;xy&quot;, # x 和 y 轴都取对数尺度 axes = FALSE, # 去掉坐标轴 xlab = &quot;$u$&quot;, ylab = &quot;$\\\\mathcal{K}_{\\\\kappa}(u)$&quot;, # 设置坐标轴标签 type = &quot;n&quot;, # 清除绘图区域的内容 ann = TRUE, # 添加标题 x和y轴标签 panel.first = grid() # 添加背景参考线 ) axis(1, at = 10^seq(from = -8, to = 2, by = 2), labels = paste0(&quot;$\\\\mathsf{10^{&quot;, seq(from = -8, to = 2, by = 2), &quot;}}$&quot;) ) axis(2, at = 10^seq(from = -8, to = 56, by = 16), labels = paste0(&quot;$\\\\mathsf{10^{&quot;, seq(from = -8, to = 56, by = 16), &quot;}}$&quot;), las = 1 ) for (i in seq(length(nus))) { lines(x0, besselK(x0, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2) } legend(&quot;topright&quot;, legend = paste0(&quot;$\\\\kappa=&quot;, rev(nus), &quot;$&quot;), col = hcl.colors(9, rev = T), lwd = 2, cex = 1 ) x &lt;- seq(0, 4, length.out = 501) x &lt;- x[x &gt; 0] plot(x, x, frame.plot = TRUE, ylim = c(1e+0, 1e+20), log = &quot;y&quot;, xlab = &quot;$u$&quot;, type = &quot;n&quot;, yaxt = &quot;n&quot;, ylab = &quot;$\\\\mathcal{K}_{\\\\kappa}(u)$&quot;, ann = TRUE, panel.first = grid() ) axis(2, at = c(1e+0, 1e+05, 1e+10, 1e+15, 1e+20), labels = paste0(&quot;$\\\\mathsf{10^{&quot;, seq(from = 0, to = 20, by = 5), &quot;}}$&quot;), las = 1 ) for (i in seq(length(nus))) { lines(x, besselK(x, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2) } legend(&quot;topright&quot;, legend = paste0(&quot;$\\\\kappa=&quot;, rev(nus), &quot;$&quot;), col = hcl.colors(9, rev = T), lwd = 2, cex = 1 ) 图 12.59: 贝塞尔函数 如图 12.60 所示 \\usetikzlibrary{arrows} \\begin{tikzpicture}[node distance=2cm, auto,&gt;=latex&#39;, thick, scale = 0.5] \\node (P) {$P$}; \\node (B) [right of=P] {$B$}; \\node (A) [below of=P] {$A$}; \\node (C) [below of=B] {$C$}; \\node (P1) [node distance=1.4cm, left of=P, above of=P] {$\\hat{P}$}; \\draw[-&gt;] (P) to node {$f$} (B); \\draw[-&gt;] (P) to node [swap] {$g$} (A); \\draw[-&gt;] (A) to node [swap] {$f$} (C); \\draw[-&gt;] (B) to node {$g$} (C); \\draw[-&gt;, bend right] (P1) to node [swap] {$\\hat{g}$} (A); \\draw[-&gt;, bend left] (P1) to node {$\\hat{f}$} (B); \\draw[-&gt;, dashed] (P1) to node {$k$} (P); \\end{tikzpicture} 图 12.60: Funky tikz \\begin{tikzpicture} \\begin{scope}[blend group = soft light] \\fill[red!30!white] ( 90:1.2) circle (2); \\fill[green!30!white] (210:1.2) circle (2); \\fill[blue!30!white] (330:1.2) circle (2); \\end{scope} \\node at ( 90:2) {Typography}; \\node at ( 210:2) {Design}; \\node at ( 330:2) {Coding}; \\node [font=\\Large] {\\LaTeX}; \\end{tikzpicture} 图 12.61: Venn 图 12.4 图形导出 图形导出的格式主要看面向的呈现方式，如插入 HTML 网页中，可选 png， svg， rgl 和 gif 格式，插入 LaTeX 文档中，可选 eps，ps，pdf 和 png 等格式 保存绘制的图形，R 使用的图形渲染库的版本 grSoftVersion() #&gt; cairo libpng jpeg #&gt; &quot;1.16.0&quot; &quot;1.6.34&quot; &quot;8.0&quot; #&gt; libtiff #&gt; &quot;LIBTIFF, Version 4.0.9&quot; 当前 R 环境中支持的图形设备 capabilities() #&gt; jpeg png tiff tcltk X11 aqua #&gt; TRUE TRUE TRUE TRUE FALSE FALSE #&gt; http/ftp sockets libxml fifo cledit iconv #&gt; TRUE TRUE TRUE TRUE FALSE TRUE #&gt; NLS profmem cairo ICU long.double libcurl #&gt; TRUE TRUE TRUE TRUE TRUE TRUE 表 12.3: 图形设备列表 设备 函数 windows cairo_pdf, cairo_ps pdf svg postscript png xfig jpeg bitmap bmp pictex tiff 图形设备控制函数 apropos(&quot;dev.&quot;) #&gt; [1] &quot;.Device&quot; &quot;.Devices&quot; &quot;dev.capabilities&quot; #&gt; [4] &quot;dev.capture&quot; &quot;dev.control&quot; &quot;dev.copy&quot; #&gt; [7] &quot;dev.copy2eps&quot; &quot;dev.copy2pdf&quot; &quot;dev.cur&quot; #&gt; [10] &quot;dev.flush&quot; &quot;dev.hold&quot; &quot;dev.interactive&quot; #&gt; [13] &quot;dev.list&quot; &quot;dev.new&quot; &quot;dev.next&quot; #&gt; [16] &quot;dev.off&quot; &quot;dev.prev&quot; &quot;dev.print&quot; #&gt; [19] &quot;dev.set&quot; &quot;dev.size&quot; &quot;dev2bitmap&quot; #&gt; [22] &quot;deval&quot; &quot;devAskNewPage&quot; &quot;deviance&quot; #&gt; [25] &quot;deviceIsInteractive&quot; 导入导出 SVG 格式矢量图形 The Butterfly Affectation: A case study in embedding an external image in an R plot Improved Importing of Vector Graphics in R 参考文献 "],
["14-data-visualization-with-plot3d.html", "第 13 章 三维可视化 13.1 饼图 13.2 柱形图 13.3 散点图 13.4 函数图 13.5 透视图", " 第 13 章 三维可视化 画图 graphics 使用基础 R 包和基于基础包的扩展包绘图 plotrix (Lemon 2006) 13.1 饼图 13.2 柱形图 13.3 散点图 13.4 函数图 13.5 透视图 第一个例子来自 Eric Lecoutre 的图库31，这是我见过的图形中含有巨量公式，并且用 R 实现的例子。在他的基础上我修改了颜色，设置图片尺寸，基于 persp 实现的透视图，唯一不足的是 persp 不支持表达式形式的坐标轴标签。 # library(latex2exp) # 代码来自 http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf mu1 &lt;- 0 # setting the expected value of x1 mu2 &lt;- 0 # setting the expected value of x2 s11 &lt;- 10 # setting the variance of x1 s12 &lt;- 15 # setting the covariance between x1 and x2 s22 &lt;- 10 # setting the variance of x2 rho &lt;- 0.5 # setting the correlation coefficient between x1 and x2 x1 &lt;- seq(-10, 10, length = 41) # generating the vector series x1 x2 &lt;- x1 # copying x1 to x2 # setting up the function of the multivariate normal density f &lt;- function(x1, x2) { term1 &lt;- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2))) term2 &lt;- -1 / (2 * (1 - rho^2)) term3 &lt;- (x1 - mu1)^2 / s11 term4 &lt;- (x2 - mu2)^2 / s22 term5 &lt;- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22)) term1 * exp(term2 * (term3 + term4 - term5)) } z &lt;- outer(x1, x2, f) # calculating the density values nrz &lt;- nrow(z) ncz &lt;- ncol(z) nbcol &lt;- 100 color &lt;- hcl.colors(100) # Compute the z-value at the facet centres zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz] # Recode facet z-values into color indices facetcol &lt;- cut(zfacet, nbcol) par(mar = c(4.1, 4.1, 4.5, 1.5), ps = 10) persp(x1, x2, z, xlab = &quot;\\n x1&quot;, ylab = &quot;\\n x2&quot;, zlab = &quot;\\n\\n f(x1,x2)&quot;, # xlab = TeX(&#39;$x_{1}$&#39;), # latex2exp 其实是使用 LaTeX 语法将 LaTeX 公式翻译为 R 能接受的表达式形式 # ylab = TeX(&#39;$x_{2}$&#39;), # zlab = TeX(&#39;$f(x_{1},x_{2})$&#39;), main = &quot;Two dimensional Normal Distribution&quot;, col = color[facetcol], border = NA, theta = 30, phi = 20, r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180, shade = 0.1, ticktype = &quot;detailed&quot;, nticks = 5, box = TRUE ) mtext(expression(list(mu[1] == 0, mu[2] == 0, sigma[11] == 10, sigma[22] == 10, sigma[12] == 15, rho == 0.5)), side = 3) mtext(expression(italic(f) ~ group(&quot;(&quot;,list(x[1],x[2]),&quot;)&quot;) == frac(1, 2 ~ pi ~ sqrt(sigma[11] ~ sigma[22] ~ (1 - rho^2))) ~ exp ~ bgroup(&quot;{&quot;, paste( - frac(1, 2(1 - rho^2)) * phantom(0), bgroup(&quot;[&quot;, frac((x[1] ~ -~mu[1])^2, sigma[11]) ~ -~2 ~ rho ~ frac(x[1] ~ -~mu[1], sqrt(sigma[11])) ~ frac(x[2] ~ -~mu[2], sqrt(sigma[22])) ~ +~frac((x[2] ~ -~mu[2])^2, sigma[22]), &quot;]&quot;) ), &quot;}&quot;) ), side = 1, line = 3) 图 13.1: 二元正态概率密度函数 早在 2006 年的时候，Paul Murrell 就提出来一种解决方法32，可是比较复杂，后来谢大大接手了 tikzDevice 包 (Sharpsteen and Bracken 2018) 的开发，算是比较好的解决了这个问题。 # 代码来自 http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf mu1 &lt;- 0 # setting the expected value of x1 mu2 &lt;- 0 # setting the expected value of x2 s11 &lt;- 10 # setting the variance of x1 s12 &lt;- 15 # setting the covariance between x1 and x2 s22 &lt;- 10 # setting the variance of x2 rho &lt;- 0.5 # setting the correlation coefficient between x1 and x2 x1 &lt;- seq(-10, 10, length = 41) # generating the vector series x1 x2 &lt;- x1 # copying x1 to x2 f &lt;- function(x1, x2) { term1 &lt;- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2))) term2 &lt;- -1 / (2 * (1 - rho^2)) term3 &lt;- (x1 - mu1)^2 / s11 term4 &lt;- (x2 - mu2)^2 / s22 term5 &lt;- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22)) term1 * exp(term2 * (term3 + term4 - term5)) } # setting up the function of the multivariate normal density z &lt;- outer(x1, x2, f) # calculating the density values nrz &lt;- nrow(z) ncz &lt;- ncol(z) nbcol &lt;- 100 color &lt;- hcl.colors(100) # Compute the z-value at the facet centres zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz] # Recode facet z-values into color indices facetcol &lt;- cut(zfacet, nbcol) par(mar = c(4.1, 4.1, 4.5, 1.5)) persp(x1, x2, z, xlab = &quot;$x_{1}$&quot;, ylab = &quot;$x_{2}$&quot;, zlab = &quot;$f(x_{1},x_{2})$&quot;, main = &quot;Two dimensional Normal Distribution&quot;, col = color[facetcol], border = NA, theta = 30, phi = 20, r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180, shade = 0.1, ticktype = &quot;detailed&quot;, nticks = 5, box = TRUE ) mtext(&quot;$\\\\mu_1 = 0,\\\\mu_2 = 0,\\\\sigma_{11} = 10,\\\\sigma_{22} = 10,\\\\sigma_{12} = 15, \\\\rho = 0.5$&quot;, side = 3) mtext(&quot;$f(x_{1},x_{2}) = \\\\frac{1}{2\\\\pi\\\\sqrt{\\\\sigma_{11}\\\\sigma_{22}(1-\\\\rho^2)}}\\\\exp\\\\big\\\\{-\\\\frac{1}{2(1-\\\\rho^2)}[\\\\frac{(x_1 - \\\\mu_1)^2}{\\\\sigma_{11}} - 2\\\\rho\\\\frac{(x_1 - \\\\mu_1)(x_2 - \\\\mu_2)}{\\\\sqrt{\\\\sigma_{11}}\\\\sqrt{\\\\sigma_{22}}} + \\\\frac{(x_2 - \\\\mu_2)^2}{\\\\sigma_{22}}]\\\\big\\\\}$&quot;, side = 1, line = 2, cex = 1.5) 图 13.2: 二元正态密度函数 library(lattice) wireframe(z ~ x1 + x2, data = data.frame(x1 = x1, x2 = rep(x2, each = length(x1)), z = z), xlab = expression(x[1]), ylab = expression(x[2]), zlab = expression(italic(f) ~ group(&quot;(&quot;,list(x[1],x[2]),&quot;)&quot;)), colorkey = TRUE, drape = TRUE) 图 12.1: 表达式二元密度函数 ## volcano ## 87 x 61 matrix wireframe(volcano, shade = TRUE, aspect = c(61/87, 0.4), light.source = c(10,0,10)) 希腊字母用 unicode 字符代替，不要使用 pdf 不然数学符号 \\(\\sigma\\) 不能正确渲染，推荐选择 cairo_pdf # https://stackoverflow.com/questions/41190525/adjust-margins-in-persp-persp3d-in-r # https://stackoverflow.com/questions/37571376/how-to-customize-nticks-in-persp-r # https://stackoverflow.com/questions/43507680/are-xlab-ylab-and-zlab-in-persp-incompatible-with-bquote x &lt;- seq(-10, 10, len = 30) y &lt;- seq(0, 5, len = 30) f &lt;- function(x, y) { dnorm(2, x, y) } z &lt;- outer(x, y, f) persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = &quot;lightblue&quot;, xlab = &quot;\\u03bc&quot;, ylab = &quot;\\u03c3\\u207F&quot;, zlab = paste(&quot;Likelihood &quot;, &quot;(\\u03bc,\\u03c3\\u207F)&quot;, sep = &quot;&quot;) ) 图 13.3: unicode 字符代替希腊字母 plotrix 包含231页手册 pie3D scatterplot3d 三维图形 plot3D 三维图形 barsurf 三维条形图 barsurf: Bar, Surface and Other Plots library(barsurf) # ls(&quot;package:barsurf&quot;) library(plotrix) ls(&quot;package:plotrix&quot;) # 161 个函数 library(scatterplot3d) # 1 个函数 ls(&quot;package:scatterplot3d&quot;) library(plot3D) ls(&quot;package:plot3D&quot;) # 51个函数 library(rgl) library(barsurf) library(colorspace) x &lt;- y &lt;- 1:4 f &lt;- function(x, y) x^2 + y^2 z &lt;- outer(x, y, f) plot3d.bar(, , z) plot3d.bar(, , volcano) plot3d.surf(, , volcano) 参考文献 "],
["15-data-visualization-with-ggplot2.html", "第 14 章 数据可视化 14.1 基础语法 14.2 统计图形 14.3 空间数据 14.4 网络数据 14.5 CRAN 分析 14.6 软件信息", " 第 14 章 数据可视化 David Robinson 给出为何使用 ggplot233 当然也有 Jeff Leek 指出在某些重要场合不适合 ggplot234 并且给出强有力的 证据，其实不管怎么样，适合自己的才是好的。也不枉费 Garrick Aden-Buie 花费 160 页幻灯片逐步分解介绍 优雅的ggplot2，Malcolm Barrett 也介绍了 ggplot2 基础用法，还有 Selva Prabhakaran 精心总结给出了 50 个 ggplot2 数据可视化的 例子 以及 Victor Perrier 为小白用 ggplot2 操碎了心地开发 RStudio 插件 esquisse 包，Claus O. Wilke 教你一步步创建出版级的图形 https://github.com/clauswilke/practical_ggplot2。 GGplot2 是十分方便的统计作图工具，相比 Base R，为了一张出版级的图形，不需要去调整每个参数，实现快速出图。集成了很多其它统计计算的 R 包，支持丰富的统计分析和计算功能，如回归、平滑等，实现了作图和模型的无缝连接。比如图14.1，使用 loess 局部多项式平滑得到数据的趋势，不仅仅是散点图，代码量也非常少。 library(ggplot2) ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = TRUE, method = &quot;loess&quot;) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) 图 14.1: 简洁美观 故事源于一幅图片，我不记得第一次见到这幅图是什么时候了，只因多次在多个场合中见过，所以留下了深刻的印象，后来才知道它出自于一篇博文 — Using R packages and education to scale Data Science at Airbnb，作者 Ricardo Bion 还在其 Github 上传了相关代码35。除此之外还有几篇重要的参考资料： Pablo Barberá 的 Data Visualization with R and ggplot2 Kieran Healy 的新书 Data Visualization: A Practical Introduction Matt Leonawicz 的新作 mapmate, 可以去其主页欣赏系列作品36 bbplot tidytuesday 可视化挑战官方项目 还有 tidytuesday 14.1 基础语法 以数据集 airquality 为例介绍GGplot2 图层、主题、配色、坐标、尺度、注释和组合等 14.1.1 图层 ls(&quot;package:ggplot2&quot;, pattern = &quot;^geom_&quot;) #&gt; [1] &quot;geom_abline&quot; &quot;geom_area&quot; &quot;geom_bar&quot; &quot;geom_bin2d&quot; #&gt; [5] &quot;geom_blank&quot; &quot;geom_boxplot&quot; &quot;geom_col&quot; &quot;geom_contour&quot; #&gt; [9] &quot;geom_count&quot; &quot;geom_crossbar&quot; &quot;geom_curve&quot; &quot;geom_density&quot; #&gt; [13] &quot;geom_density_2d&quot; &quot;geom_density2d&quot; &quot;geom_dotplot&quot; &quot;geom_errorbar&quot; #&gt; [17] &quot;geom_errorbarh&quot; &quot;geom_freqpoly&quot; &quot;geom_hex&quot; &quot;geom_histogram&quot; #&gt; [21] &quot;geom_hline&quot; &quot;geom_jitter&quot; &quot;geom_label&quot; &quot;geom_line&quot; #&gt; [25] &quot;geom_linerange&quot; &quot;geom_map&quot; &quot;geom_path&quot; &quot;geom_point&quot; #&gt; [29] &quot;geom_pointrange&quot; &quot;geom_polygon&quot; &quot;geom_qq&quot; &quot;geom_qq_line&quot; #&gt; [33] &quot;geom_quantile&quot; &quot;geom_raster&quot; &quot;geom_rect&quot; &quot;geom_ribbon&quot; #&gt; [37] &quot;geom_rug&quot; &quot;geom_segment&quot; &quot;geom_sf&quot; &quot;geom_sf_label&quot; #&gt; [41] &quot;geom_sf_text&quot; &quot;geom_smooth&quot; &quot;geom_spoke&quot; &quot;geom_step&quot; #&gt; [45] &quot;geom_text&quot; &quot;geom_tile&quot; &quot;geom_violin&quot; &quot;geom_vline&quot; 生成一个散点图 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 14.1.2 主题 ls(&quot;package:ggplot2&quot;, pattern = &quot;^theme_&quot;) #&gt; [1] &quot;theme_bw&quot; &quot;theme_classic&quot; &quot;theme_dark&quot; &quot;theme_get&quot; #&gt; [5] &quot;theme_gray&quot; &quot;theme_grey&quot; &quot;theme_light&quot; &quot;theme_linedraw&quot; #&gt; [9] &quot;theme_minimal&quot; &quot;theme_replace&quot; &quot;theme_set&quot; &quot;theme_test&quot; #&gt; [13] &quot;theme_update&quot; &quot;theme_void&quot; 这里只展示 theme_bw() theme_void() theme_minimal() 和 theme_void() 等四个常见主题，更多主题参考 ggthemes 、hrbrthemes 和 ggthemr 包 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_bw() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_void() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_minimal() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_void() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 14.1.3 配色 ls(&quot;package:ggplot2&quot;, pattern = &quot;^scale_(color|fill)_&quot;) #&gt; [1] &quot;scale_color_brewer&quot; &quot;scale_color_continuous&quot; &quot;scale_color_discrete&quot; #&gt; [4] &quot;scale_color_distiller&quot; &quot;scale_color_gradient&quot; &quot;scale_color_gradient2&quot; #&gt; [7] &quot;scale_color_gradientn&quot; &quot;scale_color_grey&quot; &quot;scale_color_hue&quot; #&gt; [10] &quot;scale_color_identity&quot; &quot;scale_color_manual&quot; &quot;scale_color_viridis_c&quot; #&gt; [13] &quot;scale_color_viridis_d&quot; &quot;scale_fill_brewer&quot; &quot;scale_fill_continuous&quot; #&gt; [16] &quot;scale_fill_date&quot; &quot;scale_fill_datetime&quot; &quot;scale_fill_discrete&quot; #&gt; [19] &quot;scale_fill_distiller&quot; &quot;scale_fill_gradient&quot; &quot;scale_fill_gradient2&quot; #&gt; [22] &quot;scale_fill_gradientn&quot; &quot;scale_fill_grey&quot; &quot;scale_fill_hue&quot; #&gt; [25] &quot;scale_fill_identity&quot; &quot;scale_fill_manual&quot; &quot;scale_fill_ordinal&quot; #&gt; [28] &quot;scale_fill_viridis_c&quot; &quot;scale_fill_viridis_d&quot; ggplot(airquality, aes(x = Temp, y = Ozone, color = as.factor(Month))) + geom_point() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone, color = as.ordered(Month))) + geom_point() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 14.1.4 刻度 ls(&quot;package:ggplot2&quot;, pattern = &quot;^scale_(x|y)_&quot;) #&gt; [1] &quot;scale_x_continuous&quot; &quot;scale_x_date&quot; &quot;scale_x_datetime&quot; #&gt; [4] &quot;scale_x_discrete&quot; &quot;scale_x_log10&quot; &quot;scale_x_reverse&quot; #&gt; [7] &quot;scale_x_sqrt&quot; &quot;scale_x_time&quot; &quot;scale_y_continuous&quot; #&gt; [10] &quot;scale_y_date&quot; &quot;scale_y_datetime&quot; &quot;scale_y_discrete&quot; #&gt; [13] &quot;scale_y_log10&quot; &quot;scale_y_reverse&quot; &quot;scale_y_sqrt&quot; #&gt; [16] &quot;scale_y_time&quot; range(airquality$Temp, na.rm = TRUE) #&gt; [1] 56 97 range(airquality$Ozone, na.rm = TRUE) #&gt; [1] 1 168 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + scale_x_continuous(breaks = seq(50, 100, 5)) + scale_y_continuous(breaks = seq(0, 200, 20)) #&gt; Warning: Removed 37 rows containing missing values (geom_point). 14.1.5 注释 ls(&quot;package:ggplot2&quot;, pattern = &quot;^annotation_&quot;) #&gt; [1] &quot;annotation_custom&quot; &quot;annotation_logticks&quot; &quot;annotation_map&quot; #&gt; [4] &quot;annotation_raster&quot; ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + labs(title = substitute(paste(d * bolditalic(x)[italic(t)] == alpha * (theta - bolditalic(x)[italic(t)]) * d * italic(t) + lambda * d * italic(B)[italic(t)]), list(lambda = 4))) #&gt; Warning: Removed 37 rows containing missing values (geom_point). 14.1.6 图例 14.1.7 组合 ggplot(airquality) + geom_point(aes(x = Temp, y = Ozone)) + facet_wrap(~ as.ordered(Month)) #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality) + geom_point(aes(x = Temp, y = Ozone)) + facet_wrap(~ as.ordered(Month), nrow = 1) #&gt; Warning: Removed 37 rows containing missing values (geom_point). gridExtra 和 patchwork 14.1.8 坐标系 极坐标，直角坐标 ls(&quot;package:ggplot2&quot;, pattern = &quot;^coord_&quot;) #&gt; [1] &quot;coord_cartesian&quot; &quot;coord_equal&quot; &quot;coord_fixed&quot; &quot;coord_flip&quot; #&gt; [5] &quot;coord_map&quot; &quot;coord_munch&quot; &quot;coord_polar&quot; &quot;coord_quickmap&quot; #&gt; [9] &quot;coord_sf&quot; &quot;coord_trans&quot; 14.1.9 坐标轴 坐标轴标签位置、大小、字体 14.2 统计图形 14.2.1 散点图 下面以 diamonds 数据集为例展示 ggplot2 的绘图过程，首先加载 diamonds 数据集，查看数据集的内容 data(diamonds) str(diamonds) #&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 53940 obs. of 10 variables: #&gt; $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... #&gt; $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... #&gt; $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... #&gt; $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... #&gt; $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... #&gt; $ table : num 55 61 65 58 58 57 57 55 61 61 ... #&gt; $ price : int 326 326 327 334 335 336 336 337 337 338 ... #&gt; $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... #&gt; $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... #&gt; $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... 数值型变量 carat 作为 x 轴 ggplot(diamonds, aes(x = carat)) ggplot(diamonds, aes(x = carat, y = price)) ggplot(diamonds, aes(x = carat, color = cut)) ggplot(diamonds, aes(x = carat), color = &quot;steelblue&quot;) 图 14.2: 指定统一颜色 图 14.2 的基础上添加数据图层 ggplot(diamonds, aes(x = carat, y = price)) + geom_point() 图 14.3: 添加数据图层 给散点图14.3上色 ggplot(diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) 图 14.4: 散点图配色 ggplot(diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) + scale_y_continuous( labels = scales::unit_format(unit = &quot;k&quot;, scale = 1e-3), breaks = seq(0, 20000, 4000) ) 图 14.5: 格式化坐标轴刻度标签 让另一变量 cut 作为颜色分类指标 ggplot(diamonds, aes(x = carat, y = price, color = cut)) + geom_point() 图 14.6: 分类散点图 当然还有一种类似的表示就是分组，默认情况下，ggplot2将所有观测点视为一组，以分类变量 cut 来分组 ggplot(diamonds, aes(x = carat, y = price, group = cut)) + geom_point() 图 14.7: 分组 在图14.7 上没有体现出来分组的意思，下面以 cut 分组线性回归为例 ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;lm&quot;) 图 14.8: 分组线性回归 我们当然可以选择更加合适的拟合方式，如局部多项式平滑 loess 但是该方法不太适用观测值比较多的情况，因为它会占用比较多的内存，建议使用广义可加模型作平滑拟合 ggplot(diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;loess&quot;) ggplot(diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) 图 14.9: 数据分组应用广义可加平滑 ggfortify 包支持更多的统计分析结果的可视化 为了更好地区分开组别，我们在图14.9的基础上分面或者配色 ggplot(diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) + facet_grid(~cut) ggplot(diamonds, aes(x = carat, y = price, group = cut, color = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) 图 14.10: 分组配色 在分类散点图的另一种表示方法就是分面图，以 cut 变量作为分面的依据 ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + facet_grid(~cut) 图 14.11: 分面散点图 给图 14.11 上色 ggplot(diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) + facet_grid(~cut) 图 14.12: 给分面散点图上色 在图14.12的基础上，给不同的类上不同的颜色 ggplot(diamonds, aes(x = carat, y = price, color = cut)) + geom_point() + facet_grid(~cut) 图 14.13: 给不同的类上不同的颜色 去掉图例，此时图例属于冗余信息了 ggplot(diamonds, aes(x = carat, y = price, color = cut)) + geom_point(show.legend = FALSE) + facet_grid(~cut) 图 14.14: 去掉图例 四块土地，所施肥料不同，肥力大小顺序 4 &lt; 2 &lt; 3 &lt; 1 小麦产量随肥力的变化 library(nlme) data(Wheat2) # Wheat Yield Trials library(colorspace) ggplot(Wheat2, aes(longitude, latitude)) + geom_point(aes(size = yield, colour = Block)) + scale_color_discrete_sequential(palette = &quot;Viridis&quot;) + scale_x_continuous(breaks = seq(0, 30, 5)) + scale_y_continuous(breaks = seq(0, 50, 10)) 图 12.20: 多个图例 ggplot(mtcars, aes(x = hp, y = mpg, color = factor(am))) + geom_point() + theme_bw() 图 14.15: 分类散点图 图层、分组、分面和散点图介绍完了，接下来就是其它统计图形，如箱线图，小提琴图和条形图 dat &lt;- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers)) colnames(dat) &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;passengers&quot;) ggplot(data = dat, aes(x = as.factor(year), y = as.factor(month))) + stat_sum(aes(size = passengers), colour = &quot;lightblue&quot;) + scale_size(range = c(1, 10), breaks = seq(100, 650, 50)) + labs(x = &quot;Year&quot;, y = &quot;Month&quot;, colour = &quot;Passengers&quot;) + theme_minimal() 图 12.21: 1948年至1960年航班乘客人数变化 14.2.2 箱线图 以 PlantGrowth 数据集为例展示箱线图，在两组不同实验条件下，植物生长的情况，纵坐标是干燥植物的量，横坐标表示不同的实验条件。这是非常典型的适合用箱线图来表达数据的场合，Y 轴对应数值型变量，X 轴对应分类变量，在 R 语言中，分类变量的类型是 factor data(&quot;PlantGrowth&quot;) str(PlantGrowth) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggplot(data = PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() PlantGrowth 数据量比较小，此时比较适合采用抖动散点图，抖动是为了避免点之间相互重叠，为了增加不同类别之间的识别性，我们可以用不同的点的形状或者不同的颜色来表示类别 ggplot(data = PlantGrowth, aes(x = group, y = weight, shape = group)) + geom_jitter() ggplot(data = PlantGrowth, aes(x = group, y = weight, color = group)) + geom_jitter() boxplot(weight ~ group, data = PlantGrowth, ylab = &quot;Dried weight of plants&quot;, col = &quot;lightgray&quot;, notch = FALSE, varwidth = TRUE ) 以钻石切割质量 cut 为分面依据，以钻石颜色类别 color 为 x 轴，钻石价格为 y 轴，绘制箱线图14.16 ggplot(diamonds, aes(x = color, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(~cut) 图 14.16: 箱线图 我们当然还可以添加钻石的纯净度 clarity 作为分面依据，那么箱线图可以为图 14.17，但是经过观察，我们发现水平分类过多，考虑用切割质量 cut 替换钻石颜色 color 绘图，但是由于分类过细，图信息展示不简练，反而不好，如图 14.18 ggplot(diamonds, aes(x = color, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ cut) 图 14.17: 复合分面箱线图 ggplot(diamonds, aes(x = cut, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ color) ggplot(diamonds, aes(x = cut, y = price, color = color)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ color) 图 14.18: 钻石颜色配色 14.2.3 条形图 条形图特别适合分类变量的展示，我们这里展示钻石切割质量 cut 不同等级的数量，当然我们可以直接展示各类的数目，在图层 geom_bar 中指定 stat=\"identity\" # 需要映射数据框的两个变量，相当于自己先计算了每类的数量 with(diamonds, table(cut)) cut_df &lt;- as.data.frame(table(diamonds$cut)) ggplot(cut_df, aes(x = Var1, y = Freq)) + geom_bar(stat = &quot;identity&quot;) ggplot(diamonds, aes(x = cut)) + geom_bar() 图 14.19: 频数条形图 还有另外三种表示方法 ggplot(diamonds, aes(x = cut)) + geom_bar(stat = &quot;count&quot;) ggplot(diamonds, aes(x = cut, y = ..count..)) + geom_bar() ggplot(diamonds, aes(x = cut, y = stat(count))) + geom_bar() 我们还可以在图 14.19 的基础上再添加一个分类变量钻石的纯净度 clarity，形成堆积条形图 ggplot(diamonds, aes(x = cut, fill = clarity)) + geom_bar() 图 14.20: 堆积条形图 再添加一个分类变量钻石颜色 color 比较好的做法是分面 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() + facet_grid(~cut) 图 14.21: 分面堆积条形图 实际上，绘制图14.21包含了对分类变量的分组计数过程，如下 with(diamonds, table(cut, color)) #&gt; color #&gt; cut D E F G H I J #&gt; Fair 163 224 312 314 303 175 119 #&gt; Good 662 933 909 871 702 522 307 #&gt; Very Good 1513 2400 2164 2299 1824 1204 678 #&gt; Premium 1603 2337 2331 2924 2360 1428 808 #&gt; Ideal 2834 3903 3826 4884 3115 2093 896 还有一种堆积的方法是按比例，而不是按数量，如图14.22 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;fill&quot;) + facet_grid(~cut) 图 14.22: 比例堆积条形图 接下来就是复合条形图 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) 图 14.23: 复合条形图 再添加一个分类变量，就是需要分面大法了，图 14.23 展示了三个分类变量，其实我们还可以再添加一个分类变量用作分面的列依据 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) + facet_grid(rows = vars(cut)) 图 14.24: 分面复合条形图 图 14.24 展示的数据如下 with(diamonds, table(color, clarity, cut)) #&gt; , , cut = Fair #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 4 56 58 25 5 9 3 3 #&gt; E 9 78 65 42 14 13 3 0 #&gt; F 35 89 83 53 33 10 5 4 #&gt; G 53 80 69 45 45 17 3 2 #&gt; H 52 91 75 41 32 11 1 0 #&gt; I 34 45 30 32 25 8 1 0 #&gt; J 23 27 28 23 16 1 1 0 #&gt; #&gt; , , cut = Good #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 8 223 237 104 43 25 13 9 #&gt; E 23 202 355 160 89 52 43 9 #&gt; F 19 201 273 184 132 50 35 15 #&gt; G 19 163 207 192 152 75 41 22 #&gt; H 14 158 235 138 77 45 31 4 #&gt; I 9 81 165 110 103 26 22 6 #&gt; J 4 53 88 90 52 13 1 6 #&gt; #&gt; , , cut = Very Good #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 5 314 494 309 175 141 52 23 #&gt; E 22 445 626 503 293 298 170 43 #&gt; F 13 343 559 466 293 249 174 67 #&gt; G 16 327 474 479 432 302 190 79 #&gt; H 12 343 547 376 257 145 115 29 #&gt; I 8 200 358 274 205 71 69 19 #&gt; J 8 128 182 184 120 29 19 8 #&gt; #&gt; , , cut = Premium #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 12 421 556 339 131 94 40 10 #&gt; E 30 519 614 629 292 121 105 27 #&gt; F 34 523 608 619 290 146 80 31 #&gt; G 46 492 566 721 566 275 171 87 #&gt; H 46 521 655 532 336 118 112 40 #&gt; I 24 312 367 315 221 82 84 23 #&gt; J 13 161 209 202 153 34 24 12 #&gt; #&gt; , , cut = Ideal #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 13 356 738 920 351 284 144 28 #&gt; E 18 469 766 1136 593 507 335 79 #&gt; F 42 453 608 879 616 520 440 268 #&gt; G 16 486 660 910 953 774 594 491 #&gt; H 38 450 763 556 467 289 326 226 #&gt; I 17 274 504 438 408 178 179 95 #&gt; J 2 110 243 232 201 54 29 25 14.2.4 折线图 时间序列数据的展示，时序图 ggplot(economics, aes(date, unemploy)) + geom_line() 图 12.28: 时序图 14.2.5 直方图 直方图用来查看连续变量的分布 ggplot(diamonds, aes(price)) + geom_histogram(bins = 30) 图 12.29: 钻石价格的分布 堆积直方图 ggplot(diamonds, aes(x = price, fill = cut)) + geom_histogram(bins = 30) 图 12.30: 钻石价格随切割质量的分布 基础 R 包与 Ggplot2 包绘制的直方图的对比，Base R 绘图速度快，代码更加稳定，Ggplot2 代码简洁，更美观 par(mar = c(2.1, 2.1, 1.5, 0.5)) plot(c(50, 350), c(0, 10), type = &quot;n&quot;, font.main = 1, xlab = &quot;&quot;, ylab = &quot;&quot;, frame.plot = FALSE, axes = FALSE, # xlab = &quot;hp&quot;, ylab = &quot;Frequency&quot;, main = paste(&quot;Histogram with Base R&quot;, paste(rep(&quot; &quot;, 60), collapse = &quot;&quot;)) ) axis( side = 1, at = seq(50, 350, 50), labels = seq(50, 350, 50), tick = FALSE, las = 1, padj = 0, mgp = c(3, 0.1, 0) ) axis( side = 2, at = seq(0, 10, 2), labels = seq(0, 10, 2), # col = &quot;white&quot;, 坐标轴的颜色 # col.ticks 刻度线的颜色 tick = FALSE, # 取消刻度线 las = 1, # 水平方向 hadj = 1, # 右侧对齐 mgp = c(3, 0.1, 0) # 纵轴边距线设置为 0.1 ) abline(h = seq(0, 10, 2), v = seq(50, 350, 50), col = &quot;gray90&quot;, lty = &quot;solid&quot;) abline(h = seq(1, 9, 2), v = seq(75, 325, 50), col = &quot;gray95&quot;, lty = &quot;solid&quot;) hist(mtcars$hp, col = &quot;#56B4E9&quot;, border = &quot;white&quot;, freq = TRUE, add = TRUE # labels = TRUE, axes = TRUE, ylim = c(0, 10.5), # xlab = &quot;hp&quot;,main = &quot;Histogram with Base R&quot; ) mtext(&quot;hp&quot;, 1, line = 1.0) mtext(&quot;Frequency&quot;, 2, line = 1.0) ggplot(mtcars) + geom_histogram(aes(x = hp), fill = &quot;#56B4E9&quot;, color = &quot;white&quot;, breaks = seq(50, 350, 50)) + scale_x_continuous(breaks = seq(50, 350, 50)) + scale_y_continuous(breaks = seq(0, 12, 2)) + labs(x = &quot;hp&quot;, y = &quot;Frequency&quot;, title = &quot;Histogram with Ggplot2&quot;) + theme_minimal(base_size = 12) 图 12.32: 直方图 14.2.6 提琴图 提琴图 ggplot(diamonds, aes(x = cut, y = price)) + geom_boxplot() ggplot(diamonds, aes(x = cut, y = price)) + geom_violin() 图 14.25: 小提琴图 ggplot(mpg, aes(class, cty)) + geom_violin() + labs( title = &quot;Violin plot&quot;, subtitle = &quot;City Mileage vs Class of vehicle&quot;, caption = &quot;Source: mpg&quot;, x = &quot;Class of Vehicle&quot;, y = &quot;City Mileage&quot; ) + theme_minimal() 图 14.26: 城市里程与车辆类别 蜂群图 ggbeeswarm 是分类散点图加箱线图的合体 ggplot(mpg, aes(x = class, y = hwy, color = class)) + ggbeeswarm::geom_quasirandom() 14.2.7 抖动图 抖动图适合数据量比较小的情况 ggplot(mpg, aes(x = class, y = hwy, color = class)) + geom_jitter() 在数据量比较大的时候，可以用箱线图、密度图、提琴图 ggplot(diamonds, aes(x = cut, y = price)) + geom_jitter() 图 12.35: 抖动图的反例 上色和分面都不好使的抖动图，因为区分度变小 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_jitter() + facet_grid(clarity ~ cut) 图 12.37: 根据钻石颜色上色 箱线图此时不宜分的过细 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() + facet_grid(cut ~ clarity) 图 12.38: 箱线图 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() + facet_grid(~clarity) 最好只比较一个维度 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() ggplot(diamonds) + ggridges::geom_density_ridges(aes(y = color, x = price, fill = color)) #&gt; Picking joint bandwidth of 535 14.2.8 密度图 ggplot(mpg, aes(cty)) + geom_density(aes(fill = factor(cyl)), alpha = 0.8) + labs( title = &quot;Density plot&quot;, subtitle = &quot;City Mileage Grouped by Number of cylinders&quot;, caption = &quot;Source: mpg&quot;, x = &quot;City Mileage&quot;, fill = &quot;# Cylinders&quot; ) 图 14.27: 按汽缸数分组的城市里程 添加透明度，解决遮挡 ggplot(diamonds, aes(x = price, fill = cut)) + geom_density() ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(alpha = 0.5) 图 14.28: 添加透明度的密度图 堆积密度图 ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(position = &quot;stack&quot;) 图 14.29: 堆积密度图 条件密度估计 # You can use position=&quot;fill&quot; to produce a conditional density estimate ggplot(diamonds, aes(carat, stat(count), fill = cut)) + geom_density(position = &quot;fill&quot;) 图 12.40: 条件密度估计图 岭线图是密度图的一种变体，可以防止密度曲线重叠在一起 ggplot(diamonds) + ggridges::geom_density_ridges(aes(x = price, y = color, fill = color)) #&gt; Picking joint bandwidth of 535 二维的密度图又是一种延伸 ggplot(diamonds, aes(x = carat, y = price)) + geom_density_2d(aes(color = cut)) + facet_grid(~cut) + scale_fill_viridis_d() stat 函数，特别是 nlevel 参数，在密度曲线之间填充我们又可以得到热力图 ggplot(diamonds, aes(x = carat, y = price)) + stat_density_2d(aes(fill = stat(nlevel)), geom = &quot;polygon&quot;) + facet_grid(. ~ cut) + scale_fill_viridis_c() #&gt; Warning in validDetails.polygon(x): NAs introduced by coercion #&gt; Warning in validDetails.polygon(x): NAs introduced by coercion #&gt; Warning in validDetails.polygon(x): NAs introduced by coercion #&gt; Warning in validDetails.polygon(x): NAs introduced by coercion #&gt; Warning in validDetails.polygon(x): NAs introduced by coercion gemo_hex 也是二维密度图的一种变体，特别适合数据量比较大的情形 ggplot(diamonds, aes(x = carat, y = price)) + geom_hex() + scale_fill_viridis_c() 14.2.9 玫瑰图 南丁格尔风玫瑰图37 可以作为堆积条形图，分组条形图 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() + coord_polar() 图 14.30: 堆积条形图转风玫瑰图 # 风玫瑰图 http://blog.csdn.net/Bone_ACE/article/details/47624987 library(ggplot2) set.seed(2018) # 随机生成100次风向，并汇集到16个区间内 direction &lt;- cut_interval(runif(100, 0, 360), n = 16) # 随机生成100次风速，并划分成4种强度 mag &lt;- cut_interval(rgamma(100, 15), 4) dat &lt;- data.frame(direction = direction, mag = mag) # 将风向映射到X轴，频数映射到Y轴，风速大小映射到填充色，生成条形图后再转为极坐标形式即可 p &lt;- ggplot(dat, aes(x = direction, y = ..count.., fill = mag)) p + geom_bar(colour = &quot;white&quot;) + coord_polar() + theme_minimal() + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) + labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Magnitude&quot;) # p + geom_bar(position = &quot;stack&quot;) + # coord_polar() + # theme_minimal() + # theme(axis.ticks = element_line(colour = &quot;white&quot;)) 图 14.31: 风玫瑰图 词云 ggwordcloud 14.3 空间数据 课程案例学习 2018-Introduction to Geospatial Raster and Vector Data with R 空间数据分析课程 Peter Ellis 新西兰大选和普查数据 More cartograms of New Zealand census data: district and city level 2017-Mapping oil production by country in R 石油产量在全球的分布 2017-How to highlight countries on a map 高亮地图上的国家 2017-Mapping With Sf: Part 3 美国各州的犯罪率数据 USArrests 准备数据集 crimes &lt;- data.frame(state = tolower(rownames(USArrests)), USArrests) crimesm &lt;- reshape2::melt(crimes, id = 1) head(crimesm) #&gt; state variable value #&gt; 1 alabama Murder 13.2 #&gt; 2 alaska Murder 10.0 #&gt; 3 arizona Murder 8.1 #&gt; 4 arkansas Murder 8.8 #&gt; 5 california Murder 9.0 #&gt; 6 colorado Murder 7.9 添加地图数据 library(maps) states_map &lt;- map_data(&quot;state&quot;) head(states_map) #&gt; long lat group order region subregion #&gt; 1 -87.5 30.4 1 1 alabama &lt;NA&gt; #&gt; 2 -87.5 30.4 1 2 alabama &lt;NA&gt; #&gt; 3 -87.5 30.4 1 3 alabama &lt;NA&gt; #&gt; 4 -87.5 30.3 1 4 alabama &lt;NA&gt; #&gt; 5 -87.6 30.3 1 5 alabama &lt;NA&gt; #&gt; 6 -87.6 30.3 1 6 alabama &lt;NA&gt; 绘图 ggplot(crimes, aes(map_id = state)) + geom_map(aes(fill = Murder), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + coord_map() 图 14.32: 1973年美国各州的犯罪率数据 ggplot(crimesm, aes(map_id = state)) + geom_map(aes(fill = value), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + facet_wrap(~variable) 图 14.33: 四类犯罪在各州的分布 比较 viridis 和 Spectral 两块调色板，如图 14.34 所示，可见 Spectral 的可识别性高些 dat &lt;- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers)) colnames(dat) &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;passengers&quot;) library(colormap) ggplot(data = dat, aes(as.factor(year), as.factor(month))) + geom_point(aes(colour = passengers), pch = 15, size = 8) + scale_colour_distiller(palette = &quot;Spectral&quot;) + labs(x = &quot;Year&quot;, y = &quot;Month&quot;) + theme_minimal() 图 14.34: viridis 和 Spectral对比 再举栗子，图14.35是正负例对比，其中好在哪里呢？这张图要表达美国黄石国家公园的老忠实泉间歇喷发的时间规律，那么好的标准就是层次分明，以突出不同颜色之间的时间差异。这个差异，还要看起来不那么费眼睛，越一目了然越好。 library(gridExtra) erupt &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) + geom_raster() + scale_x_continuous(NULL, expand = c(0, 0)) + scale_y_continuous(NULL, expand = c(0, 0)) + theme(legend.position = &quot;none&quot;) erupt1 &lt;- erupt + scale_fill_gradientn(colours = gray.colors(7)) erupt2 &lt;- erupt + scale_fill_distiller(palette = &quot;Spectral&quot;) erupt3 &lt;- erupt + scale_fill_gradientn(colours = terrain.colors(7)) erupt4 &lt;- erupt + scale_fill_colormap(colormap = colormaps$RdBu) grid.arrange(erupt1, erupt2, erupt3, erupt4, ncol = 2) 图 14.35: 美国黄石国家公园的老忠实泉 此处调用 RColorBrewer 中 Spectral 调色板，它本来只有11中颜色，通过 scale_colour_distiller 却可以把它映射到连续型数值变量 mag 上，发散型调色板本身的对比性也可以起到很好的区分度，如图 14.36 所示 library(mapdata) FijiMap &lt;- map_data(&quot;worldHires&quot;, region = &quot;Fiji&quot;) ggplot(FijiMap, aes(x = long, y = lat)) + geom_map(map = FijiMap, aes(map_id = region), size = .2) + geom_point(data = quakes, aes(x = long, y = lat, colour = mag), pch = 16) + xlim(160, 195) + scale_colour_distiller(palette = &quot;Spectral&quot;) + scale_y_continuous(breaks = (-18:18) * 5) + coord_map(&quot;ortho&quot;, orientation = c(-10, 180, 0)) + labs(colour = &quot;Magnitude&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + theme_bw() 图 14.36: 斐济地震带 此外， colormap 包提供更加丰富的调色板，通过 scale_color_colormap 支持 ggplot2 绘图风格 # 数据来源 http://datasets.flowingdata.com/unemployment09.csv unemp &lt;- read.csv( file = &quot;http://datasets.flowingdata.com/unemployment09.csv&quot;, header = FALSE, stringsAsFactors = FALSE ) names(unemp) &lt;- c( &quot;id&quot;, &quot;state_fips&quot;, &quot;county_fips&quot;, &quot;name&quot;, &quot;year&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;rate&quot; ) unemp$county &lt;- tolower(gsub(&quot; County, [A-Z]{2}&quot;, &quot;&quot;, unemp$name)) unemp$state &lt;- gsub(&quot;^.*([A-Z]{2}).*$&quot;, &quot;\\\\1&quot;, unemp$name) county_df &lt;- map_data(&quot;county&quot;) names(county_df) &lt;- c(&quot;long&quot;, &quot;lat&quot;, &quot;group&quot;, &quot;order&quot;, &quot;state_name&quot;, &quot;county&quot;) county_df$state &lt;- state.abb[match(county_df$state_name, tolower(state.name))] county_df$state_name &lt;- NULL state_df &lt;- map_data(&quot;state&quot;) # Combine together choropleth &lt;- merge(county_df, unemp, by = c(&quot;state&quot;, &quot;county&quot;)) choropleth &lt;- choropleth[order(choropleth$order), ] choropleth$rate_d &lt;- cut(choropleth$rate, breaks = c(seq(0, 10, by = 2), 35)) library(ggthemes) ggplot(choropleth, aes(long, lat, group = group)) + geom_polygon(aes(fill = rate_d), colour = alpha(&quot;white&quot;, 1 / 4), size = 0.2) + geom_polygon(data = state_df, colour = &quot;white&quot;, fill = NA) + scale_fill_brewer(palette = &quot;PuRd&quot;) + labs( fill = &quot;ratio of unemployment&quot;, title = &quot;unemployment by county, 2009&quot;, caption = &quot;data source: http://datasets.flowingdata.com/unemployment09.csv&quot; ) + coord_map(&quot;polyconic&quot;) + theme_map() 图 14.37: 2009年美国各城镇失业率 美国各地区失业率地图，配不同颜色， colormap 适合给静态图配色 14.3.1 raster raster 包定义了获取和操作空间 raster 类型数据集的类和方法，rasterVis 补充加强了 raster 包在数据可视化和交互方面的功能。可视化是基于 lattice 的 raster 包的开发已经被作者 Robert J. Hijmans 迁移到 Github 上啦，官方文档 https://www.rspatial.org/ 星号 * 标记的是 S3 方法 methods(plot) #&gt; [1] plot,ANY,ANY-method #&gt; [2] plot,color,ANY-method #&gt; [3] plot,hexbin,missing-method #&gt; [4] plot,Spatial,missing-method #&gt; [5] plot,SpatialGrid,missing-method #&gt; [6] plot,SpatialGridDataFrame,missing-method #&gt; [7] plot,SpatialLines,missing-method #&gt; [8] plot,SpatialMultiPoints,missing-method #&gt; [9] plot,SpatialPixels,missing-method #&gt; [10] plot,SpatialPixelsDataFrame,missing-method #&gt; [11] plot,SpatialPoints,missing-method #&gt; [12] plot,SpatialPolygons,missing-method #&gt; [13] plot.acf* #&gt; [14] plot.ACF* #&gt; [15] plot.augPred* #&gt; [16] plot.bclust* #&gt; [17] plot.classIntervals* #&gt; [18] plot.compareFits* #&gt; [19] plot.correspondence* #&gt; [20] plot.data.frame* #&gt; [21] plot.decomposed.ts* #&gt; [22] plot.default #&gt; [23] plot.dendrogram* #&gt; [24] plot.density* #&gt; [25] plot.ecdf #&gt; [26] plot.factor* #&gt; [27] plot.formula* #&gt; [28] plot.function #&gt; [29] plot.ggplot* #&gt; [30] plot.gls* #&gt; [31] plot.gtable* #&gt; [32] plot.hcl_palettes* #&gt; [33] plot.hclust* #&gt; [34] plot.histogram* #&gt; [35] plot.HoltWinters* #&gt; [36] plot.ica* #&gt; [37] plot.intervals.lmList* #&gt; [38] plot.isoreg* #&gt; [39] plot.lda* #&gt; [40] plot.lm* #&gt; [41] plot.lme #&gt; [42] plot.lmList* #&gt; [43] plot.mca* #&gt; [44] plot.medpolish* #&gt; [45] plot.mlm* #&gt; [46] plot.nffGroupedData* #&gt; [47] plot.nfnGroupedData* #&gt; [48] plot.nls* #&gt; [49] plot.nmGroupedData* #&gt; [50] plot.pdMat* #&gt; [51] plot.ppr* #&gt; [52] plot.prcomp* #&gt; [53] plot.princomp* #&gt; [54] plot.profile* #&gt; [55] plot.profile.nls* #&gt; [56] plot.R6* #&gt; [57] plot.ranef.lme* #&gt; [58] plot.ranef.lmList* #&gt; [59] plot.raster* #&gt; [60] plot.ridgelm* #&gt; [61] plot.sf* #&gt; [62] plot.sfc_CIRCULARSTRING* #&gt; [63] plot.sfc_GEOMETRY* #&gt; [64] plot.sfc_GEOMETRYCOLLECTION* #&gt; [65] plot.sfc_LINESTRING* #&gt; [66] plot.sfc_MULTILINESTRING* #&gt; [67] plot.sfc_MULTIPOINT* #&gt; [68] plot.sfc_MULTIPOLYGON* #&gt; [69] plot.sfc_POINT* #&gt; [70] plot.sfc_POLYGON* #&gt; [71] plot.sfg* #&gt; [72] plot.shingle* #&gt; [73] plot.simulate.lme* #&gt; [74] plot.SOM* #&gt; [75] plot.somgrid* #&gt; [76] plot.spec* #&gt; [77] plot.stars* #&gt; [78] plot.stars_proxy* #&gt; [79] plot.stepfun #&gt; [80] plot.stft* #&gt; [81] plot.stl* #&gt; [82] plot.svm* #&gt; [83] plot.table* #&gt; [84] plot.trellis* #&gt; [85] plot.ts #&gt; [86] plot.tskernel* #&gt; [87] plot.TukeyHSD* #&gt; [88] plot.tune* #&gt; [89] plot.units* #&gt; [90] plot.Variogram* #&gt; see &#39;?methods&#39; for accessing help and source code 查看函数的定义 getAnywhere(plot.raster) #&gt; A single object matching &#39;plot.raster&#39; was found #&gt; It was found in the following places #&gt; registered S3 method for plot from namespace graphics #&gt; namespace:graphics #&gt; with value #&gt; #&gt; function (x, y, xlim = c(0, ncol(x)), ylim = c(0, nrow(x)), xaxs = &quot;i&quot;, #&gt; yaxs = &quot;i&quot;, asp = 1, add = FALSE, ...) #&gt; { #&gt; if (!add) { #&gt; plot.new() #&gt; plot.window(xlim = xlim, ylim = ylim, asp = asp, xaxs = xaxs, #&gt; yaxs = yaxs) #&gt; } #&gt; rasterImage(x, 0, 0, ncol(x), nrow(x), ...) #&gt; } #&gt; &lt;bytecode: 0x00000000336a66f8&gt; #&gt; &lt;environment: namespace:graphics&gt; rasterImage 函数来绘制图像，如果想知道 rasterImage 的内容可以继续看 getAnywhere(rasterImage) getAnywhere(rasterImage) #&gt; A single object matching &#39;rasterImage&#39; was found #&gt; It was found in the following places #&gt; package:graphics #&gt; namespace:graphics #&gt; with value #&gt; #&gt; function (image, xleft, ybottom, xright, ytop, angle = 0, interpolate = TRUE, #&gt; ...) #&gt; { #&gt; .External.graphics(C_raster, if (inherits(image, &quot;nativeRaster&quot;)) image else as.raster(image), #&gt; as.double(xleft), as.double(ybottom), as.double(xright), #&gt; as.double(ytop), as.double(angle), as.logical(interpolate), #&gt; ...) #&gt; invisible() #&gt; } #&gt; &lt;bytecode: 0x0000000034395960&gt; #&gt; &lt;environment: namespace:graphics&gt; 通过查看函数的帮助 ?rasterImage ，我们需要重点关注一下 参数 image 传递的 raster 对象 plot(c(100, 250), c(300, 450), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) image &lt;- as.raster(matrix(0:1, ncol = 5, nrow = 3)) rasterImage(image, 100, 300, 150, 350, interpolate = FALSE) rasterImage(image, 100, 400, 150, 450) rasterImage(image, 200, 300, 200 + xinch(.5), 300 + yinch(.3), interpolate = FALSE ) rasterImage(image, 200, 400, 250, 450, angle = 15, interpolate = FALSE) 图 14.38: raster 图像 Edzer Pebesma 开发了 stars 包 # https://resources.rstudio.com/rstudio-conf-2019/spatial-data-science-in-the-tidyverse library(abind) library(sf) library(stars) x &lt;- system.file(&quot;tif/L7_ETMs.tif&quot;, package = &quot;stars&quot;) %&gt;% read_stars() ggplot() + geom_stars(data = x) + coord_equal() + facet_wrap(~band) + theme_void() + scale_fill_viridis_c() + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) 14.3.2 sp 空间数据对象，以类 sp 方式存储 (Pebesma and Bivand 2005) library(sp) data(meuse) coords &lt;- SpatialPoints(meuse[c(&quot;x&quot;, &quot;y&quot;)]) meuse &lt;- SpatialPointsDataFrame(coords, meuse) plot(meuse, pch = 1, cex = .05 * sqrt(meuse$zinc)) 图 12.51: 气泡图 library(maptools) fname &lt;- system.file(&quot;shapes/sids.shp&quot;, package = &quot;maptools&quot;) p4s &lt;- CRS(&quot;+proj=longlat +datum=NAD27&quot;) nc &lt;- readShapePoly(fname, proj4string = p4s) #&gt; Warning: readShapePoly is deprecated; use rgdal::readOGR or sf::st_read plot(nc, axes = TRUE, col = grey(1 - nc$SID79 / 57)) # Trellis maps arrow &lt;- list(&quot;SpatialPolygonsRescale&quot;, layout.north.arrow(2), offset = c(-76, 34), scale = 0.5, which = 2 ) spplot(nc, c(&quot;SID74&quot;, &quot;SID79&quot;), as.table = TRUE, scales = list(draw = T), sp.layout = arrow ) maptools 提供的 readShapePoly 函数去读取 shp 文件的方式已经过时，推荐使用 rgdal::readOGR 或者 sf::st_read 方式读取 14.3.3 sf maps mapdata maptools mapproj rgeos rgdal sp ggmap sf nc &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package = &quot;sf&quot;) %&gt;% read_sf() nc2 &lt;- nc %&gt;% select(SID74, SID79) %&gt;% gather(VAR, SID, -geom) ggplot() + geom_sf(data = nc2, aes(fill = SID)) + facet_wrap(~VAR, ncol = 1) library(GADMTools) data(&quot;Corsica&quot;) # basefile 文件存放路径 # FRA Corse 的国家代码 map &lt;- gadm_sf_loadCountries(&quot;FRA&quot;, basefile = &quot;./&quot;) gadm_plot(map) + theme_minimal() library(maps) # For map data library(mapdata) library(ggplot2) east_asia &lt;- map_data(&quot;worldHires&quot;, region = c(&quot;Japan&quot;, &quot;China&quot;, &quot;North Korea&quot;, &quot;South Korea&quot;)) # Map region to fill color ggplot(east_asia, aes(x = long, y = lat, group = group, fill = region)) + geom_polygon(colour = &quot;black&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) 14.4 网络数据 igraph 提供了 R 和 Python 接口 https://github.com/igraph。 qgraph 开发者 Sacha Epskamp 在个人主页上提供了很多网络数据分析的学习资料， Rgraphviz 基于 Graphviz BiocManager::install(&quot;Rgraphviz&quot;, version = &quot;3.8&quot;) Gephi (Bastian, Heymann, and Jacomy 2009) 和 igraph 能处理的最大网络，R 包和作者依赖关系图 14000+ 包和 7000+ 作者，CRAN 是全球R包开发者之网，自发布 R 1.0.0 (February, 2000) 距今19年 案例学习 2017-Help Us Map TrumpWorld 2017-Trumpworld Analysis: Ownership Relations in his Business Network 2017-Social Network Analysis and Topic Modeling of codecentric’s Twitter friends and followers library(DiagrammeR) library(DiagrammeRsvg) svg &lt;- export_svg( grViz(&quot; digraph neato { graph [layout = neato] node [shape = circle, style = filled, color = grey, label = &#39;&#39;] node [fillcolor = red] yihui_pkgs$Package node [fillcolor = green] unique(unlist(ctb)) node [fillcolor = orange] edge [color = grey] yihui_pkgs$Package[1] -&gt; ctb[[1]] yihui_pkgs$Package[2] -&gt; ctb[[2]] yihui_pkgs$Package[3] -&gt; ctb[[3]] yihui_pkgs$Package[4] -&gt; ctb[[4]] }&quot;) ) # this can then be used with htmltools and can save significantly # on size of output using svg rather than unrendered grViz library(htmltools) HTML(svg) # 将输出结果保存在svg格式矢量文件 即可 html_print(HTML(svg)) igraph 使用 # https://smallstats.blogspot.jp/2012/12/loading-huge-graphs-with-igraph-and-r.html # Loading huge graphs with igraph and R df &lt;- data.frame( src = sample(1:1000, 1000000, replace = TRUE), dst = sample(1:1000, 1000000, replace = TRUE) ) library(igraph) cat(&quot;--- Creating data.frame ---&quot;) start &lt;- proc.time() df &lt;- data.frame( src = sample(1:1000, 10000000, replace = TRUE), dst = sample(1:1000, 10000000, replace = TRUE) ) cat(sprintf(&quot;— elapsed time: %fs &quot;, (proc.time() - start)[1])) cat(&quot;— Creating graph… &quot;) start &lt;- proc.time() G &lt;- graph.data.frame(df, directed = TRUE) cat(sprintf(&quot;---elapsed user-time: %fs &quot;, (proc.time() - start)[1])) cat(&quot;...Creating graph...&quot;) start &lt;- proc.time() vertex.attrs &lt;- list(name = unique(c(df$src, df$dst))) edges &lt;- rbind( match(df$src, vertex.attrs$name), match(df$dst, vertex.attrs$name) ) G &lt;- graph.empty(n = 0, directed = T) G &lt;- add.vertices(G, length(vertex.attrs$name), attr = vertex.attrs) G &lt;- add.edges(G, edges) remove(edges) remove(vertex.attrs) cat(sprintf(&quot;--- elapsed user-time: %fs &quot;, (proc.time() - start)[1])) 14.5 CRAN 分析 ggraph 和 igraph 可视化 首先我们从 CRAN 官网下载 R 包描述信息38 # CRAN R 包 metadata 信息 if (file.exists(&quot;data/packages.rds&quot;)) { pdb &lt;- readRDS(&quot;data/packages.rds&quot;) } else { pdb &lt;- readRDS(file = file(sprintf(&quot;%s/web/packages/packages.rds&quot;, getOption(&quot;repos&quot;)[&quot;CRAN&quot;]))) } 接着，我们可以看看CRAN 上发布的 R 包数量 pdb[, &quot;Package&quot;] %&gt;% length() #&gt; [1] 14339 经过与官网发布的数据来对比，我们发现这里计算的结果与实际不符，多出来了几十个R包，所以我们再观察一下是否有重复的 R 包描述信息 pdb[, &quot;Package&quot;][duplicated(pdb[, &quot;Package&quot;])] #&gt; [1] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; &quot;codetools&quot; &quot;foreign&quot; #&gt; [6] &quot;KernSmooth&quot; &quot;lattice&quot; &quot;MASS&quot; &quot;Matrix&quot; &quot;mgcv&quot; #&gt; [11] &quot;nlme&quot; &quot;nnet&quot; &quot;rpart&quot; &quot;spatial&quot; &quot;survival&quot; 不难发现，果然有！所以去掉重复的 R 包信息，就是 CRAN 上实际发布的 R 包数量 subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;]), select = c(&quot;Package&quot;)) %&gt;% length() #&gt; [1] 14324 接下来，我们再来查看一些比较高产的 R 包开发者谢益辉都维护了哪些R包，如表 14.1 所示 yihui_pkg &lt;- subset(pdb, subset = grepl(&quot;Yihui Xie&quot;, pdb[, &quot;Maintainer&quot;]), select = c(&quot;Package&quot;, &quot;Maintainer&quot;, &quot;Title&quot;) ) yihui_pkg[, &quot;Title&quot;] &lt;- gsub(&quot;(\\\\\\n)&quot;, &quot; &quot;, yihui_pkg[, &quot;Title&quot;]) yihui_pkg %&gt;% knitr::kable(caption = &quot;谢益辉维护的 R Markdown 生态&quot;, booktabs = TRUE) 表 14.1: 谢益辉维护的 R Markdown 生态 Package Maintainer Title animation Yihui Xie xie@yihui.name A Gallery of Animations in Statistics and Utilities to Create Animations blogdown Yihui Xie xie@yihui.name Create Blogs and Websites with R Markdown bookdown Yihui Xie xie@yihui.name Authoring Books and Technical Documents with R Markdown DT Yihui Xie xie@yihui.name A Wrapper of the JavaScript Library ‘DataTables’ evaluate Yihui Xie xie@yihui.name Parsing and Evaluation Tools that Provide More Details than the Default formatR Yihui Xie xie@yihui.name Format R Code Automatically fun Yihui Xie xie@yihui.name Use R for Fun highr Yihui Xie xie@yihui.name Syntax Highlighting for R Source Code knitr Yihui Xie xie@yihui.name A General-Purpose Package for Dynamic Report Generation in R markdown Yihui Xie xie@yihui.name ‘Markdown’ Rendering for R mime Yihui Xie xie@yihui.name Map Filenames to MIME Types MSG Yihui Xie xie@yihui.name Data and Functions for the Book Modern Statistical Graphics pagedown Yihui Xie xie@yihui.name Paginate the HTML Output of R Markdown with CSS for Print printr Yihui Xie xie@yihui.name Automatically Print R Objects to Appropriate Formats According to the ‘knitr’ Output Format Rd2roxygen Yihui Xie xie@yihui.name Convert Rd to ‘Roxygen’ Documentation rmarkdown Yihui Xie xie@yihui.name Dynamic Documents for R rticles Yihui Xie xie@yihui.name Article Formats for R Markdown servr Yihui Xie xie@yihui.name A Simple HTTP Server to Serve Static Files or Dynamic Documents testit Yihui Xie xie@yihui.name A Simple Package for Testing R Packages tinytex Yihui Xie xie@yihui.name Helper Functions to Install and Maintain ‘TeX Live’, and Compile ‘LaTeX’ Documents tufte Yihui Xie xie@yihui.name Tufte’s Styles for R Markdown Documents xaringan Yihui Xie xie@yihui.name Presentation Ninja xfun Yihui Xie xie@yihui.name Miscellaneous Functions by ‘Yihui Xie’ 接下来，我们想看看 R 包维护者数量有多少 subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;]), select = &quot;Maintainer&quot; ) %&gt;% unique() %&gt;% length() #&gt; [1] 8448 可实际上没有这么多的开发者，因为存在这样的情况，以 R 包维护者 Hadley Wickham 为例，由于他曾使用过不同的邮箱，所以在维护者字段出现了不一致的情况，实际却是同一个人。 subset(pdb, subset = grepl(&quot;Hadley Wickham&quot;, pdb[, &quot;Maintainer&quot;]), select = c(&quot;Package&quot;, &quot;Maintainer&quot;) ) #&gt; Package Maintainer #&gt; [1,] &quot;assertthat&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [2,] &quot;babynames&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [3,] &quot;bigrquery&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [4,] &quot;classifly&quot; &quot;Hadley Wickham &lt;h.wickham@gmail.com&gt;&quot; #&gt; [5,] &quot;clusterfly&quot; &quot;Hadley Wickham &lt;h.wickham@gmail.com&gt;&quot; #&gt; [6,] &quot;conflicted&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [7,] &quot;dbplyr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [8,] &quot;dplyr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [9,] &quot;ellipsis&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [10,] &quot;feather&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [11,] &quot;forcats&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [12,] &quot;fueleconomy&quot; &quot;&#39;Hadley Wickham&#39; &lt;h.wickham@gmail.com&gt;&quot; #&gt; [13,] &quot;ggplot2&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [14,] &quot;ggplot2movies&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [15,] &quot;gtable&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [16,] &quot;haven&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [17,] &quot;hflights&quot; &quot;Hadley Wickham &lt;h.wickham@gmail.com&gt;&quot; #&gt; [18,] &quot;httr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [19,] &quot;lazyeval&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [20,] &quot;lvplot&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [21,] &quot;meifly&quot; &quot;Hadley Wickham &lt;h.wickham@gmail.com&gt;&quot; #&gt; [22,] &quot;modelr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [23,] &quot;nasaweather&quot; &quot;&#39;Hadley Wickham&#39; &lt;h.wickham@gmail.com&gt;&quot; #&gt; [24,] &quot;nycflights13&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [25,] &quot;pkgdown&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [26,] &quot;plyr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [27,] &quot;productplots&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [28,] &quot;profr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [29,] &quot;proto&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [30,] &quot;pryr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [31,] &quot;rappdirs&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [32,] &quot;reshape&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [33,] &quot;reshape2&quot; &quot;Hadley Wickham &lt;h.wickham@gmail.com&gt;&quot; #&gt; [34,] &quot;rggobi&quot; &quot;Hadley Wickham &lt;h.wickham@gmail.com&gt;&quot; #&gt; [35,] &quot;roxygen2&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [36,] &quot;rvest&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [37,] &quot;scales&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [38,] &quot;sloop&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [39,] &quot;stringr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [40,] &quot;testthat&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [41,] &quot;tidyr&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [42,] &quot;tidyverse&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; #&gt; [43,] &quot;vctrs&quot; &quot;Hadley Wickham &lt;hadley@rstudio.com&gt;&quot; 因此，有必要先把 Maintainer 字段中的邮箱部分去掉 clean_maintainer &lt;- function(x) { # 去掉邮箱 x &lt;- gsub(&quot;&lt;([^&lt;&gt;]*)&gt;&quot;, &quot;&quot;, x) # 去掉 \\n \\t \\&#39; \\&quot; 和 &#39; x &lt;- gsub(&quot;(\\\\\\n)|(\\\\\\t)|(\\\\\\&quot;)|(\\\\\\&#39;)|(&#39;)&quot;, &quot;&quot;, x) # 去掉末尾空格 x &lt;- gsub(&quot; +$&quot;, &quot;&quot;, x) } 这样我们可以得到比较靠谱的R包维护者数量了！ # 去重之后 cran_maintainers &lt;- subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;]), select = &quot;Maintainer&quot; ) %&gt;% lapply(clean_maintainer) %&gt;% # 清理 Maintainer 字段 unlist() # 列表转成字符串向量 cran_maintainers %&gt;% unique() %&gt;% # 去重 length() #&gt; [1] 7828 接下来，我们还想把 R 包维护者，按照其维护的R包数量排个序，用条形图14.39 表示 myData &lt;- cran_maintainers %&gt;% table() %&gt;% # 按照维护者分组计数 sort(decreasing = T) %&gt;% # 降序排列 head(20) # 取 Top 20 par(mar = c(2, 7, 1, 1)) barCenters &lt;- barplot(myData, col = &quot;lightblue&quot;, axes = FALSE, axisnames = FALSE, horiz = TRUE, border = &quot;white&quot; ) text( y = barCenters, x = par(&quot;usr&quot;)[3], adj = 1, labels = names(myData), xpd = TRUE ) axis(1, labels = seq(0, 90, by = 10), at = seq(0, 90, by = 10), las = 1, col = &quot;gray&quot; ) grid() 图 14.39: 维护R包数量最多的20个人39 调用 ggplot2 包绘图要求输入的数据类型是 data.frame，所以我们首先将 myData 转化为数据框类型 myData &lt;- as.data.frame(myData) colnames(myData) &lt;- c(&quot;Maintainer&quot;, &quot;Freq&quot;) ggplot(myData) + geom_bar(aes(x = Maintainer, y = Freq), stat = &quot;identity&quot;) + coord_flip() + xlab(&quot;Maintainer&quot;) + ylab(&quot;Numbers of Package&quot;) 条形图在柱子很多的情况下，点线图是一种更加简洁的替代方式 ggplot(myData, aes(x = Freq, y = Maintainer)) + geom_segment(aes(x = 20, xend = Freq, yend = Maintainer), colour = &quot;grey50&quot;) + geom_point(size = 2, colour = &quot;red&quot;) + labs(x = &quot; # of Packages &quot;, y = &quot; Maintainer &quot;) 接下来，我们想看看开发者维护的 R 包数量的分布，仅从上图，我们知道有的人能维护 80 多个 R 包，总体的分布情况又是如何呢？如图所示，我们将纵轴刻度设置为 log 模式，随着开发的R包数量的增加，开发者人数是指数级递减，可见开发R包依然是一个门槛很高的工作！ cran_maintainers %&gt;% table() %&gt;% table %&gt;% barplot(col = &quot;lightblue&quot;, log = &quot;y&quot;, border = &quot;white&quot;, xlab = &quot;# of Packages&quot;, ylab = &quot;# of Maintainers (log)&quot;, panel.first = grid()) 只开发一个 R 包的人数达到 5276 人，占开发者总数的 67.31%，约为2/3。我们还想进一步了解这些人是不是就自己开发自己维护，没有其他人参与，而且他们也不参与其它 R 包的贡献？如果是，则他们对社区的贡献非常有限，仅限于为社区带来数量上的堆积！那么社区的主要推动者是余下的 1/3，他们相互之间的合作应该比较多，我们接下来想分析一下他们之间的贡献网络。 # 为这张图寻求一个完美的解释 # 每天更新的 R包数量随日期的分布，发布数量最多的日期，好好想想是不是这样 largest_update_num &lt;- sort(table(pdb$Published), decreasing = T)[1] smallest_update_num &lt;- sort(table(pdb$Published), decreasing = F)[1] pdb_df &lt;- as.data.frame(pdb) ggplot(pdb_df[, c(&quot;Package&quot;, &quot;Published&quot;)], aes(as.Date(Published))) + geom_bar(color = &quot;firebrick&quot;) + geom_line( data = data.frame( date = as.Date(c(&quot;2011-01-01&quot;, &quot;2012-10-20&quot;)), count = c(130, 155) ), aes(x = date, y = count), arrow = arrow(angle = 15, length = unit(0.15, &quot;inches&quot;)) ) + annotate(&quot;text&quot;, x = as.Date(&quot;2010-11-01&quot;), y = 128, label = &quot;(2012-10-29,172)&quot;) + scale_x_date(date_breaks = &quot;1 year&quot;, date_labels = &quot;%Y&quot;) + labs(x = &quot;Published Date&quot;, y = &quot;Count&quot;) + theme_minimal() 14.6 软件信息 sessionInfo() #&gt; R version 3.6.0 (2019-04-26) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 8.1 x64 (build 9600) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=Chinese (Simplified)_China.936 #&gt; [2] LC_CTYPE=Chinese (Simplified)_China.936 #&gt; [3] LC_MONETARY=Chinese (Simplified)_China.936 #&gt; [4] LC_NUMERIC=C #&gt; [5] LC_TIME=Chinese (Simplified)_China.936 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] hexbin_1.27.3 maptools_0.9-5 sp_1.3-1 stars_0.3-1 #&gt; [5] sf_0.7-4 abind_1.4-5 ggthemes_4.2.0 mapdata_2.3.0 #&gt; [9] gridExtra_2.3 colormap_0.1.4 maps_3.3.0 colorspace_1.4-1 #&gt; [13] nlme_3.1-140 forcats_0.4.0 stringr_1.4.0 dplyr_0.8.1 #&gt; [17] purrr_0.3.2 readr_1.3.1 tidyr_0.8.3 tibble_2.1.2 #&gt; [21] ggplot2_3.1.1 tidyverse_1.2.1 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] Rcpp_1.0.1 lubridate_1.7.4 lattice_0.20-38 #&gt; [4] class_7.3-15 assertthat_0.2.1 digest_0.6.19 #&gt; [7] V8_2.2 R6_2.4.0 cellranger_1.1.0 #&gt; [10] plyr_1.8.4 backports_1.1.4 evaluate_0.14 #&gt; [13] e1071_1.7-1 highr_0.8 httr_1.4.0 #&gt; [16] pillar_1.4.1 rlang_0.3.4 lazyeval_0.2.2 #&gt; [19] curl_3.3 readxl_1.3.1 rstudioapi_0.10 #&gt; [22] rmarkdown_1.13 foreign_0.8-71 munsell_0.5.0 #&gt; [25] broom_0.5.2 compiler_3.6.0 modelr_0.1.4 #&gt; [28] xfun_0.7 pkgconfig_2.0.2 htmltools_0.3.6 #&gt; [31] tidyselect_0.2.5 bookdown_0.11 codetools_0.2-16 #&gt; [34] crayon_1.3.4 withr_2.1.2 grid_3.6.0 #&gt; [37] jsonlite_1.6 gtable_0.3.0 DBI_1.0.0 #&gt; [40] magrittr_1.5 units_0.6-3 scales_1.0.0 #&gt; [43] KernSmooth_2.23-15 cli_1.1.0 stringi_1.4.3 #&gt; [46] xml2_1.2.0 generics_0.0.2 tools_3.6.0 #&gt; [49] glue_1.3.1 hms_0.4.2 parallel_3.6.0 #&gt; [52] yaml_2.2.0 classInt_0.3-3 rvest_0.3.4 #&gt; [55] knitr_1.23 haven_2.1.0 参考文献 "],
["16-data-visualization-with-colors-fonts.html", "第 15 章 色彩与字体 15.1 配色 15.2 字体", " 第 15 章 色彩与字体 15.1 配色 调色板合集 paletteer，其收录了很多 R 包制作的调色板，其中包括 r-color-palettes 和 wesanderson，根据电影 Harry Potter 制作的调色板 harrypotter，根据网站 CARTO 设计的 rcartocolor 包 # https://github.com/hadley/ggplot2-book library(tidyverse) hcl &lt;- expand.grid(x = seq(-1, 1, length = 100), y = seq(-1, 1, length=100)) %&gt;% tbl_df() %&gt;% filter(x^2 + y^2 &lt; 1) %&gt;% mutate( r = sqrt(x^2 + y^2), c = 100 * r, h = 180 / pi * atan2(y, x), l = 65, colour = hcl(h, c, l) ) # sin(h) = y / (c / 100) # y = sin(h) * c / 100 cols &lt;- scales::hue_pal()(5) selected &lt;- colorspace::RGB(t(col2rgb(cols)) / 255) %&gt;% as(&quot;polarLUV&quot;) %&gt;% colorspace::coords() %&gt;% as.data.frame() %&gt;% mutate( x = cos(H / 180 * pi) * C / 100, y = sin(H / 180 * pi) * C / 100, colour = cols ) ggplot(hcl, aes(x, y)) + geom_raster(aes(fill = colour)) + scale_fill_identity() + scale_colour_identity() + coord_equal() + scale_x_continuous(&quot;&quot;, breaks = NULL) + scale_y_continuous(&quot;&quot;, breaks = NULL) + geom_point(data = selected, size = 10, color = &quot;white&quot;) + geom_point(data = selected, size = 5, aes(colour = colour)) 图 12.1: HCL调色 R 内置了 502 种不同颜色的名称，下面随机地选取 20 种颜色 sample(colors(TRUE), 20) #&gt; [1] &quot;azure4&quot; &quot;gray48&quot; &quot;palevioletred4&quot; &quot;gray4&quot; #&gt; [5] &quot;orangered2&quot; &quot;lightblue1&quot; &quot;mediumvioletred&quot; &quot;mediumorchid2&quot; #&gt; [9] &quot;orange4&quot; &quot;mediumorchid1&quot; &quot;brown4&quot; &quot;orangered&quot; #&gt; [13] &quot;rosybrown3&quot; &quot;darkorchid3&quot; &quot;darkred&quot; &quot;mediumpurple3&quot; #&gt; [17] &quot;pink2&quot; &quot;green&quot; &quot;bisque3&quot; &quot;gray14&quot; R 包 grDevices 提供 hcl 调色板40 调制两个色板 # Colors from https://github.com/johannesbjork/LaCroixColoR color_pal &lt;- c(&quot;#FF3200&quot;, &quot;#E9A17C&quot;, &quot;#E9E4A6&quot;, &quot;#1BB6AF&quot;, &quot;#0076BB&quot;, &quot;#172869&quot;) n &lt;- 16 more_colors &lt;- (grDevices::colorRampPalette(color_pal))(n) scales::show_col(colours = more_colors) 图 15.1: 桃色至梨色的渐变 # colors in colortools from http://www.gastonsanchez.com/ fish_pal &lt;- c( &quot;#69D2E7&quot;, &quot;#6993E7&quot;, &quot;#7E69E7&quot;, &quot;#BD69E7&quot;, &quot;#E769D2&quot;, &quot;#E76993&quot;, &quot;#E77E69&quot;, &quot;#E7BD69&quot;, &quot;#D2E769&quot;, &quot;#93E769&quot;, &quot;#69E77E&quot;, &quot;#69E7BD&quot; ) more_colors &lt;- (grDevices::colorRampPalette(fish_pal))(n) scales::show_col(colours = more_colors) 图 15.2: Hue-Saturation-Value (HSV) color model rgb(red = 86, green = 180, blue = 233, maxColorValue = 255) # &quot;#56B4E9&quot; #&gt; [1] &quot;#56B4E9&quot; rgb(red = 0, green = 158, blue = 115, maxColorValue = 255) # &quot;#009E73&quot; #&gt; [1] &quot;#009E73&quot; rgb(red = 240, green = 228, blue = 66, maxColorValue = 255) # &quot;#F0E442&quot; #&gt; [1] &quot;#F0E442&quot; rgb(red = 0, green = 114, blue = 178, maxColorValue = 255) # &quot;#0072B2&quot; #&gt; [1] &quot;#0072B2&quot; 举例子，直方图配色与不配色 # library(pander) # evalsOptions(&#39;graph.unify&#39;, TRUE) # panderOptions(&#39;graph.colors&#39;) 获取调色板 # https://www.fontke.com/tool/rgbschemes/ 在线配色 cols &lt;- c( &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;, &quot;#999999&quot;, &quot;#E69F00&quot; ) hist(mtcars$hp, col = &quot;#56B4E9&quot;, border = &quot;white&quot;, grid = grid()) 图 12.4: 直方图 ggplot(mtcars) + geom_histogram(aes(x = hp, fill = as.factor(..count..)), color = &quot;white&quot;, bins = 6 ) + scale_fill_manual(values = rep(&quot;#56B4E9&quot;, 10)) + ggtitle(&quot;Histogram with ggplot2&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;) 图 12.5: 直方图 15.1.1 colourlovers colourlovers 包借助 XML, jsonlite 和 httr 包可以在线获取网站 COLOURlovers 的调色板 library(colourlovers) palette1 &lt;- clpalette(&#39;113451&#39;) palette2 &lt;- clpalette(&#39;92095&#39;) palette3 &lt;- clpalette(&#39;629637&#39;) palette4 &lt;- clpalette(&#39;694737&#39;) 使用调色板 layout(matrix(1:4, nrow = 2)) par(mar = c(2, 2, 2, 2)) barplot(VADeaths, col = swatch(palette1)[[1]], border = NA) barplot(VADeaths, col = swatch(palette2)[[1]], border = NA) barplot(VADeaths, col = swatch(palette3)[[1]], border = NA) barplot(VADeaths, col = swatch(palette4)[[1]], border = NA) 调色板的描述信息 palette1 #&gt; Palette ID: 113451 #&gt; Title: Anaconda #&gt; Created by user: kunteper #&gt; Date created: 2007-08-05 14:14:15 #&gt; Views: 664 #&gt; Votes: 2 #&gt; Comments: 2 #&gt; Hearts: 0 #&gt; Rank: 0 #&gt; URL: http://www.colourlovers.com/palette/113451/Anaconda #&gt; Image URL: #&gt; Colors: #2B2D42, #7A7D7F, #B1BBCF, #6E0B21, #9B4D73 获取调色板中的颜色向量 swatch(palette1)[[1]] #&gt; [1] &quot;#2B2D42&quot; &quot;#7A7D7F&quot; &quot;#B1BBCF&quot; &quot;#6E0B21&quot; &quot;#9B4D73&quot; 15.2 字体 firatheme 包提供基于 fira sans 字体的 GGplot2 主题，类似的字体主题包还有 trekfont 、 fontHind， fontquiver 包与 fontBitstreamVera（Bitstream Vera 字体）、 fontLiberation（Liberation 字体）包和 fontDejaVu （DejaVu 字体）包一道提供了一些可允许使用的字体文件，这样，我们可以不依赖系统制作可重复的图形。 library(firatheme) ggplot(mtcars, aes(x = mpg * 0.43, y = wt * 0.4535924, colour = factor(cyl))) + geom_point(size = 2) + geom_smooth(se = FALSE) + labs( title = &quot;Car weight vs efficiency&quot;, x = &quot;Efficiency (km/l)&quot;, y = &quot;Weight (1000 kg)&quot;, colour = &quot;Cylinders&quot; ) + theme_fira() + scale_colour_fira() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 在 Ubuntu 系统上安装微软字体，如果因为网络原因，下载出现问题，也有可能是长期没有维护更新，默认字体下载链接失效了 sudo apt-get install ttf-mscorefonts-installer 因此，需要手动下载字体到目录 ~/msfonts/下 baseurl &lt;- &quot;https://nchc.dl.sourceforge.net/project/corefonts/the%20fonts/final&quot; fonts &lt;- c( &quot;webdin32&quot;, &quot;verdan32&quot;, &quot;trebuc32&quot;, &quot;times32&quot;, &quot;impact32&quot;, &quot;georgi32&quot;, &quot;courie32&quot;, &quot;comic32&quot;, &quot;arialb32&quot;, &quot;arial32&quot;, &quot;andale32&quot; ) fonts_exe &lt;- paste0(fonts, &quot;.exe&quot;) fonts_url &lt;- paste(baseurl, fonts_exe, sep = &quot;/&quot;) if (!dir.exists(&quot;~/msfonts&quot;)) { dir.create(&quot;~/msfonts&quot;) } for (i in seq(length(fonts))) download.file( url = fonts_url[i], destfile = paste(&quot;~/msfonts&quot;, fonts_exe[i], sep = &quot;/&quot;), method = &quot;auto&quot; ) 字体下载完后，手动配置字体 sudo dpkg-reconfigure ttf-mscorefonts-installer 注意要输入字体存放的完整路径 /home/ubuntu/msfonts 而不是相对路径 ~/msfonts，安装完成后，字体存放在系统目录/usr/share/fonts/truetype/msttcorefonts/下，接下来可以查看已经安装的字体 fc-list :lang=zh | sort fc-list :lang=en | sort 此外，安装常见的等宽字体 inconsolata sudo apt install fonts-inconsolata 以常用的新罗马字体为例，在 R 绘图代码中全局设置字体 par(family=\"Times\") 或者 par(family=\"serif\")，数据集 cars 的含义，散点图 15.3 表达的统计意义 # plot(speed ~ dist, data = cars) # # plot(speed ~ dist, data = cars, panel.first = grid(8, 8), # pch = 0, cex = 1.2, col = &quot;blue&quot;, xlab = &quot;speed&quot;, ylab = &quot;dist&quot; # ) # # plot(speed ~ dist, data = cars, # panel.first = lines(stats::lowess(cars$speed, cars$dist), lty = &quot;dashed&quot;), # pch = 0, cex = 1.2, col = &quot;blue&quot;, xlab = &quot;speed&quot;, ylab = &quot;dist&quot; # ) plot(Ozone ~ Wind, data = airquality, pch = as.character(Month), subset = Month != 7) 图 15.3: 数学字体 pdf 设备使用 sans 字体 ArialMT + SymbolMT 字体显示，默认字体，添加代码块设置 dev.args=list(family = \"sans\") 图15.4 par(mar = c(4, 4, 2, 1)) x &lt;- seq(-4, 4, len = 101) y &lt;- cbind(sin(x), cos(x)) matplot(x, y, type = &quot;l&quot;, xaxt = &quot;n&quot;, main = expression(paste( plain(sin) * phi, &quot; and &quot;, plain(cos) * phi )), ylab = expression(&quot;sin&quot; * phi, &quot;cos&quot; * phi), # only 1st is taken xlab = expression(paste(&quot;Phase Angle &quot;, phi)), col.main = &quot;blue&quot; ) axis(1, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) 图 15.4: 默认 sans 字体 CM &lt;- Type1Font( &quot;CM&quot;, c(file.path( system.file(&quot;fonts&quot;, &quot;metrics&quot;, package = &quot;fontcm&quot;), c( &quot;fcmr8a.afm&quot;, &quot;fcmb8a.afm&quot;, &quot;fcmri8a.afm&quot;, &quot;fcmbi8a.afm&quot;, &quot;cmsyase.afm&quot; ) )) ) pdfFonts(CM = CM) family 指定字体，默认字体 Helvetica pdf(&quot;cm.pdf&quot;, family = &quot;CM&quot;, width = 4, height = 4) par(mar = c(4.1, 4.1, 0.5, 0.5)) x &lt;- seq(-4, 4, len = 101) y &lt;- cbind(sin(x), cos(x)) matplot(x, y, type = &quot;l&quot;, xaxt = &quot;n&quot;, main = expression(paste( plain(sin) * phi, &quot; and &quot;, plain(cos) * phi )), ylab = expression(&quot;sin&quot; * phi, &quot;cos&quot; * phi), # only 1st is taken xlab = expression(paste(&quot;Phase Angle &quot;, phi)), col.main = &quot;blue&quot; ) axis(1, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) dev.off() knitr::include_graphics(path = &quot;figures/missing-fonts.png&quot;) Sys.setenv(R_GSCMD = &quot;C:/Program Files/gs/gs9.26/bin/gswin64c.exe&quot;) # embedFonts(file = &quot;cm.pdf&quot;, outfile = &quot;cm-embed.pdf&quot;) # GS 默认搜索路径不对 embedFonts( file = &quot;cm.pdf&quot;, outfile = &quot;cm-embed.pdf&quot;, fontpaths = system.file(&quot;fonts&quot;, package = &quot;fontcm&quot;) # 指定字体搜索路径 ) 参考 (Murrell and Ripley 2006) fontcm 字体 调用系统字体，安装使用网络字体 library(showtext, quietly = TRUE) showtext_auto() pdf(&quot;google-fonts.pdf&quot;) font_add_google(&quot;Alegreya Sans&quot;, &quot;aleg&quot;) par(family = &quot;serif&quot;) plot(0:5, 0:5, type = &quot;n&quot;) text(1:4, 1:4, &quot;Serif&quot;, font = 1:4, cex = 2) par(family = &quot;fira-sans&quot;) plot(0:5, 0:5, type = &quot;n&quot;) text(1:4, 1:4, &quot;Sans&quot;, font = 1:4, cex = 2) dev.off() knitr 支持的引擎有： names(knitr::knit_engines$get()) #&gt; [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; #&gt; [6] &quot;haskell&quot; &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; #&gt; [11] &quot;perl&quot; &quot;psql&quot; &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; #&gt; [16] &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; &quot;stata&quot; &quot;zsh&quot; #&gt; [21] &quot;highlight&quot; &quot;Rcpp&quot; &quot;tikz&quot; &quot;dot&quot; &quot;c&quot; #&gt; [26] &quot;fortran&quot; &quot;fortran95&quot; &quot;asy&quot; &quot;cat&quot; &quot;asis&quot; #&gt; [31] &quot;stan&quot; &quot;block&quot; &quot;block2&quot; &quot;js&quot; &quot;css&quot; #&gt; [36] &quot;sql&quot; &quot;go&quot; &quot;python&quot; &quot;julia&quot; &quot;sass&quot; #&gt; [41] &quot;scss&quot; &quot;theorem&quot; &quot;lemma&quot; &quot;corollary&quot; &quot;proposition&quot; #&gt; [46] &quot;conjecture&quot; &quot;definition&quot; &quot;example&quot; &quot;exercise&quot; &quot;proof&quot; #&gt; [51] &quot;remark&quot; &quot;solution&quot; 导入系统TTF类型字体到 R 环境中，这样绘图可以使用更多的字体 install.packages(&quot;extrafont&quot;) library(extrafont) font_import() # 查看可用的字体 # Vector of font family names fonts() # Show entire table fonttable() # 加载字体 # Only necessary in session where you ran font_import() loadfonts() # For PostScript output, use loadfonts(device=&quot;postscript&quot;) # Suppress output with loadfonts(quiet=TRUE) 测试字体是否被正确调用 pdf(&quot;font_Impact.pdf&quot;, family = &quot;Impact&quot;, width = 4, height = 4) par(mar = c(4.1, 4.1, 2.1, 0.5)) plot(mtcars$mpg, mtcars$wt, main = &quot;Fuel Efficiency of 32 Cars&quot;, xlab = &quot;Weight (x1000 lb)&quot;, ylab = &quot;Miles per Gallon&quot; ) dev.off() PDF 格式图片转 PNG 格式 convert -quality 100 -density 300x300 font_Impact.pdf font_Impact.png knitr::include_graphics(path = &quot;figures/font_Impact.png&quot;) 图 15.5: Impact 字体 参考文献 "],
["99-references.html", "参考文献", " 参考文献 "]
]
